diff --git a/README.md b/README.md
index 304ffa8..ae03dd2 100644
--- a/README.md
+++ b/README.md
@@ -4,6 +4,8 @@ Smart contracts and the dApp powering mUSD on Mezo.
 
 ## Development
 
+Developer documentation can be found in the [docs](docs) directory. Particularly, the [README](docs/README.md), which contains a system overview and breakdown of the main contracts.
+
 ### Installation
 
 This project uses [pnpm](https://pnpm.io/) as a package manager ([installation documentation](https://pnpm.io/installation)).
@@ -11,9 +13,26 @@ This project uses [pnpm](https://pnpm.io/) as a package manager ([installation d
 To install dependencies run:
 
 ```bash
-pnpm install
+pnpm install --frozen-lockfile
+cd solidity
+pnpm install --frozen-lockfile
+```
+
+### Running Tests
+
+To run tests:
+
+```bash
+cd solidity
+pnpm test
 ```
 
+### Deployment
+
+1. `$ cd solidity`
+1. `$ cp .env.example .env` and fill in the values.
+1. `$ pnpm run deploy --network matsnet` to deploy the contracts. This will resolve and use the current deployment at `deployments/matsnet`, so if you want to deploy a fresh set of contracts, delete (or archive) the `deployments/matsnet` directory.
+
 ### Pre-commit hooks
 
 Setup [pre-commit](https://pre-commit.com/) hooks to automatically discover code issues before submitting the code.
diff --git a/docs/README.md b/docs/README.md
index 3f7ac2f..7cc5ad9 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -45,9 +45,10 @@ The arbitrageur started with $100k and ended with $109k (ignoring fees). This tr
 
 ### Fees
 
-The protocol collects fees in three places:
+The protocol collects fees in four places:
 
 - An origination fee of 0.5% (governable), which is added as debt to a trove but minted to governance.
+- A redemption fee of 0.5% (governable), which is taken whenever a user redeems mUSD for BTC. For example, at 0.5%, whenever $100 of mUSD is redeemed, the user receives $99.50 worth of BTC and the protocol receives $0.50 worth of BTC.
 - A refinancing fee, which operates like the origination fee.
 - [Simple](https://www.investopedia.com/terms/s/simple_interest.asp), [fixed](https://www.creditkarma.com/credit/i/fixed-interest-rate) interest on the principal of the loan.
 
@@ -57,18 +58,144 @@ Simple interest is non-compounding. For example, if a user owes a principal of $
 
 ## Core Ideas
 
-### Immutability
+### Part of Ecosystem
 
-To give borrowers certainty the deployed contracts are immutable. However at some point in the future if the price feeds no longer work the price feed logic will fail.
+The mUSD CDP is a part of the Mezo ecosystem. The interest and fees from mUSD flow into other parts of Mezo.
 
-- Sets of immutable contracts are deployed together for different versions or collaterals.
-- The mintlist in the mUSD Token contract is used to sunset contracts if a new version is deployed by preventing any new debt positions from being opened. However the contracts will continue to function.
-- There is a governance delay to make changes to the mint list.
-- There is a governance delay to deploy new sets of contracts.
+### Protocol Bootstrap Loan
 
-The tradeoffs between immutability and upgradability are explored [here](https://medium.com/@ben_longstaff/threshold-usd-token-design-trade-offs-2926087d31c4).
+In Liquity v1 deposits to the StabilityPool earn the LQTY token, this resulted in lots of mint and deposits to the StabilityPool. In mUSD there are no direct incentives for depositing into the StabilityPool, it is not anticipated that borrowers will deposit into the StabilityPool.
 
-The three main contracts - `BorrowerOperations.sol`, `TroveManager.sol` and `StabilityPool.sol` - hold the user-facing public functions, and contain most of the internal system logic. Together they control Trove state updates and movements of collateral and mUSD tokens around the system.
+The StabilityPool is initallly populated with a bootstrapping loan. This can only leave the StabilityPool via liquidations.
+
+When the protocol's mUSD is withdrawn from the StabilityPool to the PCV contract it is first used to repay any outstanding protocol loan balance. This is to ensure that the bootstrap loan can not be withdrawn from the protocol.
+
+It is anticipated that repayments on the protocol bootstrap loan will be made on a roughly weekly basis via calls to distributeMUSD in the PCV contract.
+
+### Protocol Controlled Value
+
+Protocol Owned Liquidty as the name suggests is owned by the protocol, it is intended to provide utility to the protocol regardless of market conditions and without requiring incentives for the liquidity to stay in place.
+
+Over time as the protocol accrues interest and fees the bootstrap loan gets repaid and the portion of the mUSD in the StabilityPool that is Protocol Owned Liquidity increases.
+
+The PCV contract has the ability to distribute the mUSD that it accrues from interest and fees. The fee split for how to use that mUSD can be set by governance.
+
+To illustrate how the mUSD is distributed, assume the feeSplitPercentage is set to 60%
+
+- Protocol Loan
+  - feeRecipient is not set.
+    - 100% of the amount pays down the loan.
+  - feeRecipient is set
+    - Loan repayment <= outstanding loan
+      - 60% is used as a repayment of the Protocol loan.
+      - 40% is sent to the feeRecipient.
+    - Loan repayment > outstanding loan
+      - Protocol loan is repaid.
+      - 40% is sent to the feeRecipient.
+      - Excess loan repayment amount is deposited into the StabilityPool.
+- Protocol Loan has been repaid
+  - feeRecipient is not set
+    - 100% of the amount is deposited into the StabilityPool.
+  - feeRecipient is set
+    - 60% is deposited into the StabilityPool.
+    - 40% is sent to the feeRecipient.
+
+Note that the call to distribute MUSD does not require the entire balance of mUSD held by the PCV contract to be distributed. This means that the distributions to the feeRecipient from the PCV contract can be smoothed out.
+
+When the protocol's StabilityPool deposit is used to offset liquidations, that results in BTC from the liquidated loans to be in the StabilityPool. The governance process is able to withdraw the BTC to exchange it into mUSD to redeposit into the StabilityPool.
+
+At launch this process will be done manually however one of the governance addresses may be updated to point to a smart contract to automate the process in the future.
+
+The feeRecipient address in the PCV contract can be changed via governance.
+
+### Immutability and Upgradability
+
+Unlike Liquity v1 the mUSD smart contracts are upgradable. This provides the flexibility to fix any small issues that arise after launch.
+
+Substantial changes to the functionality would be done by deploying a new set of contracts and adding the new contracts to the mUSD token contracts mintlist and burnlist. This ensures that for any substantial changes the user must take an action to opt in and migrate funds between versions.
+
+When the protocol has been battle tested in production the contracts will be hardened with the upgradability removed. This will give borrowers certainty.
+
+### Liquidations
+
+Whenever a trove becomes under-collateralized (sub 110% BTC value to debt), it is eligible for liquidation. We have two ways to liquidate troves: with the Stability pool (default), and with redistribution (fallback).
+
+When a user (or bot) calls `TroveManager.liquidate` on a trove with sub-110% CR, that user is rewarded with a $200 mUSD gas compensation as well as 0.5% of the trove's collateral. Then, the Stability pool burns mUSD to cover all of the trove's debt and seizes the remaining 99.5% of the trove's collateral.
+
+If the Stability Pool has insufficient funds to cover all of the trove debt, we redistribute both the debt and collateral. All of the debt and collateral is sent to the Default Pool, where a user's ownership of the default pool is equal to their proportional ownership of all deposited collateral. The newly acquired collateral and debt are included for all purposes: calculating collateralization ratio, redemptions, closing a trove, etc.
+
+### Stability Pool
+
+The Stability Pool provides a mechanism to socialize liquidations. Users deposit mUSD into the pool, and the stability pool has first priority to provide mUSD to liquidate troves and seize collateral.
+
+In effect, the Stability Pool is buying BTC at a discount from liquidated troves. If a trove has $10000 in debt backed by $11000 worth of BTC, then when that trove is liquidated, the pool loses $10000 mUSD and gains $10,945 worth of BTC. In effect, they were able to buy $10945 worth of BTC for $10000 which is a ~9% discount.
+
+Users own shares of the pool, and when they exit the pool, they withdraw both their mUSD and their share of seized BTC.
+
+For example, say that the pool currently has $20000 mUSD. A user deposits $5000 mUSD. They would own 5000 shares out of 25000 shares. Later, the pool burns $3000 mUSD and seizes $3270 worth of BTC and the user decides to exit. The pool still has 25000 shares, but now has $22000 mUSD and $3270 BTC. The user withdraws `5000 / 25000 * $22000 = $4400` mUSD and `5000 / 25000 * $3270 = $654` worth of BTC.
+
+The Stability pool is seeded by a bootstrap loan given to governance. $100m mUSD is minted against future fees, and the `PCV` contract assumes $100m of debt. That $100m mUSD is deposited directly into the Stability Pool. 50% of all [protocol fees](#fees) are burned to incrementally pay off this bootstrap loan.
+
+### Redemptions
+
+A user may call `TroveManager.redeemCollateral` to burn mUSD to obtain BTC, $1 for $1 worth (minus the redemption fee). This is the main mechanism [maintaining the peg](#maintaining-the-peg).
+
+The trove with the lowest collateral ratio (but above the 110% liquidation threshold) has an equivalent amount of debt canceled, and then their BTC is trasferred to the redeeming user. This has a net effect of _raising_ their collateral ratio.
+
+For example, say that...
+
+- Alice has $1000 debt backed by $1300 collateral (130% ratio)
+- Bob has $1000 debt backed by $2000 collatearl (200% ratio)
+
+Carol redeems $50. Alice's debt and collateral are reduced by $50. Carol receives `$50 * .995 = $49.75` worth of BTC, and the protocol receives `$50 * .005 = $0.25` as a redemption fee.
+
+Alice now has $950 debt backed by $1250 collateral (132% ratio).
+
+Someone's full debt can be cancelled in this way. For example, if Carol redeemed $1000 instead of $50, then Alice's debt would be fully paid, and she would be left with $300 worth of collateral. The remaining collateral is sent to the `CollSurplusPool`. Alice can collect it by calling `BorrowerOperations.claimCollateral`.
+
+## Supporting Ideas
+
+### Gas Compensation
+
+When a user opens up a trove, an extra flat $200 mUSD is minted for gas compensation, sent to the `GasPool`, and added to the borrower's debt. This debt is included when calculating the user's collateral ratio.
+
+When a trove is liquidated, the whole debt (including the $200 gas compensation) is paid. The initiator of the liquidation is sent the $200 gas compensation, to offset any gas they might pay to call the liquidation function, especially in times of high network traffic.
+
+In other situations (redemption, closing a trove, repaying debt), the last $200 of debt of a trove is paid by the Gas Pool.
+
+For example, say that Alice wants to mint $2000 mUSD with $3000 of BTC as collateral. Alice will receive $2000, $200 will be sent to the Gas Pool, and a origination fee of $10 (0.5%) is sent to the protocol.
+
+Alice's total debt, for liquidations or calculating collateral ratios, is $2210.
+
+If Bob liquidates Alice, The stability pool burns $2210 and the Gas Pool sends Bob $200.
+
+If Bob fully redeems Alice, only $2010 can be redeemed; the Gas Pool burns the remaining $200 to close Alice's trove.
+
+If Alice closes her own trove, she only needs to pay back $2010; the Gas Pool will burn the remaining $200 to pay off all of the debt.
+
+### Recovery Mode
+
+If the Total Collateral Ratio (TCR), the value of all of the collateral divided by the total debt, of the system ever falls below the Critical Collateral Ratio (CCR) of 150%, we enter into Recovery Mode.
+
+In Recovery Mode...
+
+- We require that newly opened troves have at least 150% (the CCR) collateral, rather than the normal 110%.
+- We do not charge an origination fee.
+- We do not allow users to close troves.
+- Debt increases must be in combination with collateral increases such that the trove's collateral ratio improves _and_ is above 150%.
+- Users cannot refinance their trove.
+
+Each of these changes ensures the system returns back to above 150% TCR quickly.
+
+### Pending Funds
+
+If the Stability Pool has insufficient funds to cover all of the trove debt, we redistribute both the debt and collateral. All of the debt and collateral is sent to the Default Pool, where a user's ownership of the default pool is equal to their proprotional ownership of all deposited collateral.
+
+As a gas optimization, we track the these funds as "pending", so each borrower has pending collateral, pending principal, and pending interest, which are moved out of the default pool and back to the active pool the next time a borrower interacts with their trove.
+
+`TroveManager.sol` maintains `L_Collateral`, `L_Principal`, and `L_Interest`, which tracks the total amount of pending collateral, principal, and interest in the default pool, per unit of collateral in the system. On a user level, we track snapshots of those values, so we can calculate the pending funds of a user when they interact with the system.
+
+For example, if `rewardSnapshots[_borrower].collateral < L_Collateral`, then the user has pending collateral.
 
 ## Key Changes from THUSD
 
@@ -106,7 +233,25 @@ The **Protocol Controlled Value (PCV)** contract is a key component of the syste
 
 - **Post-Debt Repayment**: Once the bootstrap loan is fully repaid, **100% of the fees** collected by the PCV are automatically sent to the gauge system.
 
-### System Overview
+### EIP-712 Signature Verification
+
+The mUSD system implements EIP-712 signature verification through the `BorrowerOperationsSignatures` contract, allowing users to authorize operations on their troves without directly executing transactions.
+
+- **Smart Contract Integration**: This mechanism enables other smart contracts to execute operations on behalf of users who have provided signed authorizations, facilitating integration with other DeFi protocols.
+
+- **Supported Operations**: All major trove operations are supported, including opening troves, adjusting collateral and debt, refinancing, and closing troves.
+
+- **Security Features**: Includes nonce tracking to prevent replay attacks and deadline parameters to ensure signatures expire after a specified time.
+
+- **Authorization Flow**: The signature verification contract validates the user's signature before calling the corresponding restricted function in the BorrowerOperations contract.
+
+This feature enhances user experience by enabling delegation of transaction execution while maintaining security through cryptographic verification of user intent. It also creates opportunities for third-party applications to build on top of mUSD by allowing them to manage user positions with proper authorization.
+
+### No Special Recovery Mode Liquidations
+
+Unlike THUSD, mUSD does not have special handling for liquidations during recovery mode. All liquidations follow a single process regardless of the system's collateralization ratio.
+
+## System Overview
 
 The MUSD system consists of four main contract groups:
 
@@ -127,6 +272,7 @@ graph TD
         GasPool
     end
     subgraph Support["Supporting Contracts"]
+        BorrowerOperationsSignatures
         PriceFeed
         SortedTroves
         HintHelpers
@@ -136,15 +282,15 @@ graph TD
     TokenSystem-->Core
     Core-->Pools
     Pools-->Support
-    linkStyle 0 stroke-opacity:1  
-    linkStyle 1 stroke-opacity:1  
-    linkStyle 2 stroke-opacity:1   
+    linkStyle 0 stroke-opacity:1
+    linkStyle 1 stroke-opacity:1
+    linkStyle 2 stroke-opacity:1
 ```
 
 - **Token (MUSD)**: The stablecoin at the heart of the system, designed to maintain a peg to USD.
 - **Core Protocol**: Handles the main operations like opening/closing positions, managing collateral, and maintaining system stability
 - **Asset Pools**: Manages the system's various collateral and liquidity pools
-- **Supporting Contracts**: Provides essential services like price feeds, position sorting, and protocol-controlled value management
+- **Supporting Contracts**: Provides essential services like price feeds, remote trove management, position sorting, and protocol-controlled value management
 
 ### Core Smart Contracts
 
@@ -152,6 +298,8 @@ graph TD
 
 `BorrowerOperations.sol` - contains the basic operations by which borrowers interact with their Trove: Trove creation, collateral top-up / withdrawal, stablecoin issuance and repayment. BorrowerOperations functions call in to TroveManager, telling it to update Trove state, where necessary. BorrowerOperations functions also call in to the various Pools, telling them to move collateral/Tokens between Pools or between Pool <> user, where necessary.
 
+`BorrowerOperationsSignatures.sol` - contains `*WithSignature` functions that enable a third party (like a smart contract) to perform actions like adding and removing collateral and musd from a trove, given that the third party supplies a valid signature from the trove owner.
+
 `InterestRateManager.sol` - handles operations for setting interest rates as well as interest related calculations.
 
 `PriceFeed.sol` - provides price data for collateralization calculations.
@@ -190,31 +338,53 @@ graph TD
 
 ### Borrower Operations - `BorrowerOperations.sol`
 
-`openTrove(uint _maxFeePercentage, uint _MUSDAmount, address _upperHint, address _lowerHint)`: payable function that creates a Trove for the caller with the requested debt, and the collateral received. Successful execution is conditional mainly on the resulting collateralization ratio which must exceed the minimum (110% in Normal Mode, 150% in Recovery Mode). In addition to the requested debt, extra debt is issued to pay the issuance fee, and cover the gas compensation. The borrower has to provide a `_maxFeePercentage` that they are willing to accept in case of a fee slippage, i.e. when a redemption transaction is processed first, driving up the issuance fee.
+`openTrove(uint _MUSDAmount, address _upperHint, address _lowerHint)`: payable function that creates a Trove for the caller with the requested debt, and the collateral received. Successful execution is conditional mainly on the resulting collateralization ratio which must exceed the minimum (110% in Normal Mode, 150% in Recovery Mode). In addition to the requested debt, extra debt is issued to pay the issuance fee, and cover the gas compensation.
 
 `addColl(address _upperHint, address _lowerHint))`: payable function that adds the received collateral to the caller's active Trove.
 
 `withdrawColl(uint _amount, address _upperHint, address _lowerHint)`: withdraws `_amount` of collateral from the caller’s Trove. Executes only if the user has an active Trove, the withdrawal would not pull the user’s Trove below the minimum collateralization ratio, and the resulting total collateralization ratio of the system is above 150%.
 
-`withdrawMUSD(uint _maxFeePercentage, uint _amount, address _upperHint, address _lowerHint)`: issues `_amount` of mUSD from the caller’s Trove to the caller. Executes only if the Trove's collateralization ratio would remain above the minimum, and the resulting total collateralization ratio is above 150%. The borrower has to provide a `_maxFeePercentage` that they are willing to accept in case of a fee slippage, i.e. when a redemption transaction is processed first, driving up the issuance fee.
+`withdrawMUSD(uint _amount, address _upperHint, address _lowerHint)`: issues `_amount` of mUSD from the caller’s Trove to the caller. Executes only if the Trove's collateralization ratio would remain above the minimum, and the resulting total collateralization ratio is above 150%.
 
 `repayMUSD(uint _amount, address _upperHint, address _lowerHint)`: repay `_amount` of mUSD to the caller’s Trove, subject to leaving enough debt in the Trove for gas compensation.
 
-`adjustTrove(address _borrower, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint, uint _maxFeePercentage)`: enables a borrower to simultaneously change both their collateral and debt, subject to all the restrictions that apply to individual increases/decreases of each quantity with the following particularity: if the adjustment reduces the collateralization ratio of the Trove, the function only executes if the resulting total collateralization ratio is above 150%. The borrower has to provide a `_maxFeePercentage` that they are willing to accept in case of a fee slippage, i.e. when a redemption transaction is processed first, driving up the issuance fee. The parameter is ignored if the debt is not increased with the transaction.
+`adjustTrove(address _borrower, uint _collWithdrawal, uint _debtChange, bool _isDebtIncrease, address _upperHint, address _lowerHint)`: enables a borrower to simultaneously change both their collateral and debt, subject to all the restrictions that apply to individual increases/decreases of each quantity with the following particularity: if the adjustment reduces the collateralization ratio of the Trove, the function only executes if the resulting total collateralization ratio is above 150%.
 
 `closeTrove()`: allows a borrower to repay all debt, withdraw all their collateral, and close their Trove. Requires the borrower have an mUSD balance sufficient to repay their Trove's debt, excluding gas compensation - i.e. `(debt - MUSD_GAS_COMPENSATION)` mUSD.
 
 `claimCollateral(address _user)`: when a borrower’s Trove has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio above 110%, this function allows the borrower to claim their collateral surplus that remains in the system (collateral - debt upon redemption; collateral - 110% of the debt upon liquidation).
 
-`refinance(uint _maxFeePercentage)`: allows a borrower to move their debt to a new (presumably lower) interest rate. In addition to the original debt, extra debt is issued to pay the refinancing fee. The borrower has to provide a `_maxFeePercentage` that they are willing to accept in case of a fee slippage, i.e. when a redemption transaction is processed first, driving up the refinancing fee.
+`refinance()`: allows a borrower to move their debt to a new (presumably lower) interest rate. In addition to the original debt, extra debt is issued to pay the refinancing fee.
+
+### BorrowerOperationsSignatures Functions - `BorrowerOpeationsSignatures.sol`
+
+Each function requires a signature and deadline (when the signature is valid until). For examples of how to craft these signatures and deadlines, check out any of the `WithSignature` tests in `BorrowerOperations.test.ts`.
+
+`addCollWithSignature(address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: payable function that adds the received collateral to the signer's active Trove.
+
+`closeTroveWithSignature(address _borrower, bytes memory _signature, uint256 _deadline)`: allows a signer to repay all debt, withdraw all their collateral, and close their Trove. Requires the caller have an mUSD balance sufficient to repay the signer's Trove's debt, excluding gas compensation - i.e. `(debt - MUSD_GAS_COMPENSATION)` mUSD.
+
+`adjustTroveWithSignature(uint256 _collWithdrawal, uint256 _debtChange, bool _isDebtIncrease,address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: enables a caller to simultaneously change a signer's collateral and debt, subject to all the restrictions that apply to individual increases/decreases of each quantity with the following particularity: if the adjustment reduces the collateralization ratio of the Trove, the function only executes if the resulting total collateralization ratio is above 150%.
+
+`withdrawCollWithSignature(uint256 _amount, address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: withdraws `_amount` of collateral from the signer's Trove. Executes only if the signer has an active Trove, the withdrawal would not pull the signer's Trove below the minimum collateralization ratio, and the resulting total collateralization ratio of the system is above 150%.
+
+`openTroveWithSignature(uint256 _debtAmount, address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: payable function that creates a Trove for the signer with the requested debt, and the collateral received from the caller. Successful execution is conditional mainly on the resulting collateralization ratio which must exceed the minimum (110% in Normal Mode, 150% in Recovery Mode). In addition to the requested debt, extra debt is issued to pay the issuance fee, and cover the gas compensation.
+
+`withdrawMUSDWithSignature(uint256 _amount, address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: issues `_amount` of mUSD from the signer’s Trove to the signer. Executes only if the Trove's collateralization ratio would remain above the minimum, and the resulting total collateralization ratio is above 150%.
+
+`repayMUSDWithSignature(uint256 _amount, address _upperHint, address _lowerHint, address _borrower, bytes memory _signature, uint256 _deadline)`: repay `_amount` of mUSD to the signer’s Trove from the caller, subject to leaving enough debt in the Trove for gas compensation.
+
+`refinanceWithSignature(address _borrower, bytes memory _signature, uint256 _deadline)`: allows a caller to move the signer's debt to a new (presumably lower) interest rate. In addition to the original debt, extra debt is issued to pay the refinancing fee.
+
+`claimCollateralWithSignature(address _borrower, bytes memory _signature, uint256 _deadline)`: when a signer’s Trove has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio above 110%, this function allows the caller to forward the signer's collateral surplus that remains in the system (collateral - debt upon redemption; collateral - 110% of the debt upon liquidation).
 
 ### TroveManager Functions - `TroveManager.sol`
 
-`liquidate(address _borrower)`: callable by anyone, attempts to liquidate the Trove of `_user`. Executes successfully if `_user`’s Trove meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Trove's ICR < the system MCR).
+`liquidate(address _borrower)`: callable by anyone, attempts to liquidate the Trove of `_user`. Executes successfully if `_user`’s Trove meets the conditions for liquidation (i.e. the Trove's ICR < the system MCR).
 
 `batchLiquidateTroves(address[] calldata _troveArray)`: callable by anyone, accepts a custom list of Troves addresses as an argument. Steps through the provided list and attempts to liquidate every Trove, until it reaches the end or it runs out of gas. A Trove is liquidated only if it meets the conditions for liquidation. For a batch of 10 Troves, the gas costs per liquidated Trove are roughly between 75K-83K, for a batch of 50 Troves between 54K-69K.
 
-`redeemCollateral(uint _MUSDAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint _partialRedemptionHintNICR, uint _maxIterations, uint _maxFeePercentage)`: redeems `_MUSDamount` of stablecoins for ether from the system. Decreases the caller’s mUSD balance, and sends them the corresponding amount of collateral. Executes successfully if the caller has sufficient mUSD to redeem. The number of Troves redeemed from is capped by `_maxIterations`. The borrower has to provide a `_maxFeePercentage` that they are willing to accept in case of a fee slippage, i.e. when another redemption transaction is processed first, driving up the redemption fee.
+`redeemCollateral(uint _MUSDAmount, address _firstRedemptionHint, address _upperPartialRedemptionHint, address _lowerPartialRedemptionHint, uint _partialRedemptionHintNICR, uint _maxIterations)`: redeems `_MUSDamount` of stablecoins for ether from the system. Decreases the caller’s mUSD balance, and sends them the corresponding amount of collateral. Executes successfully if the caller has sufficient mUSD to redeem. The number of Troves redeemed from is capped by `_maxIterations`.
 
 `getCurrentICR(address _user, uint _price)`: computes the user’s individual collateralization ratio (ICR) based on their total collateral and total mUSD debt. Returns 2^256 -1 if they have 0 debt.
 
@@ -234,6 +404,59 @@ graph TD
 
 `checkRecoveryMode()`: reveals whether the system is in Recovery Mode (i.e. whether the Total Collateralization Ratio (TCR) is below the Critical Collateralization Ratio (CCR)).
 
+## Opening a Trove from a Front End
+
+We keep a list of all open troves sorted by collateralization ratio on chain, implemented as a linked list. Since finding the proper insertion point for a new trove (or an adjusted trove) would be computationally expensive naively, the relevant functions (like `BorrowerOperations.openTrove`) take a `_upperHint` and `_lowerHint`, to narrow the search.
+
+We use `SortedTroves.findInsertPosition` to find these hints, which in turn needs _approximate_ hints, from `HintHelpers.getApproxHint`. This is involved, so we provide an example (in typescript):
+
+```ts
+// Amount of MUSD to borrow
+const debtAmount = to1e18(2000)
+
+// Amount of collateral (in BTC)
+const assetAmount = to1e18(10)
+
+// Compute hints using HintHelpers and SortedTroves
+
+// Compute expected total debt by adding gas compensation and fee
+const gasCompensation = await troveManager.MUSD_GAS_COMPENSATION()
+const expectedFee = await troveManager.getBorrowingFeeWithDecay(debtAmount)
+const expectedTotalDebt = debtAmount + expectedFee + gasCompensation
+
+// Nominal CR is collateral * 1e20 / totalDebt
+// Note that price is not included in this calculation
+const nicr = (assetAmount * to1e18(100)) / expectedTotalDebt
+
+// Get an approximate address hint from HintHelpers contract
+const numTroves = Number(await sortedTroves.getSize())
+
+// Use 15•sqrt(troves)
+const numTrials = BigInt(Math.ceil(Math.sqrt(numTroves))) * 15n
+
+// A source of noise, does not need to be cryptographically secure.
+const randomSeed = Math.ceil(Math.random() * 100000)
+
+const { 0: approxHint } = await hintHelpers.getApproxHint(
+  nicr,
+  numTrials,
+  randomSeed,
+)
+
+// Use the approximate hint to get exact upper and lower hints
+const { 0: upperHint, 1: lowerHint } = await sortedTroves.findInsertPosition(
+  nicr,
+  approxHint,
+  approxHint,
+)
+
+await borrowerOperations
+  .connect(carol.wallet)
+  .openTrove(maxFeePercentage, debtAmount, upperHint, lowerHint, {
+    value: assetAmount,
+  })
+```
+
 ## Definitions
 
 _**Trove:**_ a collateralized debt position, bound to a single Ethereum address. Also referred to as a “CDP” in similar protocols.
diff --git a/docs/simpleInterest.md b/docs/simpleInterest.md
index 7306d5a..a548b10 100644
--- a/docs/simpleInterest.md
+++ b/docs/simpleInterest.md
@@ -14,11 +14,11 @@ This document outlines a block-based simple interest approach to manage debt and
 
 ### 2. Total Debt Tracking
 
-For the system, we maintain for each interest rate:
+For the system, we maintain:
 
-- Total debt amount
-- Total interest owed
+- The sum of each principal multiplied by its rate (aggreated interest numerator)
 - Timestamp of the last update
+- The total accrued principal and interest in the active pool
 
 ### 3. Individual Trove Data
 
@@ -48,15 +48,23 @@ Each trove stores:
 
 ### Updating Total System Interest
 
-System interest is stored per interest rate. When a trove is modified, the interest for that rate is updated:
+System interest is stored with an aggregated rate. When a user uses the system, the interest is updated:
 
 1. Calculate new interest:
    ```
-   new_interest = total_debt * (current_timestamp - last_update_timestamp) * interest_rate_per_second
+   new_interest = interest_numerator * (current_timestamp - last_update_timestamp) / seconds_in_a_year
    ```
 2. Add new interest to total interest owed
 3. Update the last update timestamp
 
+Whenever principal is added (or removed), we update interest and then update the `interest_numerator`
+
+```
+interest_numerator = interest_numerator + added_principal * interest_rate
+```
+
+This means that `interest_numerator` represents an aggregated interest rate (in bips) for the system.
+
 ### Opening a New Trove
 
 1. Record the initial debt amount
@@ -77,16 +85,20 @@ System interest is stored per interest rate. When a trove is modified, the inter
 ### Trove Interactions (Borrowing/Repaying/Adjusting)
 
 1. Calculate new interest owed up to current timestamp
-2. Add new interest to stored interest for the trove and for the system at the trove's interest rate
-3. Process the requested operation (note that repayments will first be applied to owed interest before paying off principal)
-4. Optionally mint and distribute accumulated interest to PCV and gauge pool
+2. Update the system's total interest
+3. Add new interest to stored interest for the trove
+4. Mint and distribute accumulated interest to PCV and gauge pool
+5. Process the requested operation (note that repayments will first be applied to owed interest before paying off principal)
+6. Adjust the `interest_numerator`
 
 ### Closing a Trove
 
 1. Calculate final interest owed up to current timestamp
-2. Add final interest to stored interest
-3. Process repayment of total obligations (debt + total interest)
-4. Mint and distribute any remaining unminted interest
+2. Update the system's total interest
+3. Add final interest to stored interest
+4. Process repayment of total obligations (debt + total interest)
+5. Mint and distribute any remaining unminted interest
+6. Adjust the `interest_numerator`
 
 ## Advantages of this Approach
 
@@ -103,7 +115,7 @@ System interest is stored per interest rate. When a trove is modified, the inter
 - Simple interest results in lower total interest compared to compound interest
 - Interest doesn't earn interest, which may not reflect traditional lending practices
 - Protocol earns less revenue compared to compound interest approaches
-- Interest distribution can be batched but must be tracked carefully
+- Interest distribution is batched but must be tracked carefully
 - Fixed rates based on maximum capacity may result in lower initial yields if users don't borrow their full capacity
 - Revenue stream is dependent on user interaction as we only mint the interest when total interest value changes
 - Time-based calculations are more predictable than block-based ones
diff --git a/docs/tests.md b/docs/tests.md
index 7e4ea1c..a533dec 100644
--- a/docs/tests.md
+++ b/docs/tests.md
@@ -84,7 +84,6 @@ export interface OpenTroveParams {
   musdAmount: string | bigint
   ICR?: string
   lowerHint?: string
-  maxFeePercentage?: string
   sender: HardhatEthersSigner
   upperHint?: string
 }
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 9afeffa..7319352 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -255,7 +255,7 @@ packages:
       '@babel/traverse': 7.25.6
       '@babel/types': 7.25.6
       convert-source-map: 2.0.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       gensync: 1.0.0-beta.2
       json5: 2.2.3
       semver: 6.3.1
@@ -555,7 +555,7 @@ packages:
       '@babel/parser': 7.25.6
       '@babel/template': 7.25.0
       '@babel/types': 7.25.6
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       globals: 11.12.0
     transitivePeerDependencies:
       - supports-color
@@ -1307,7 +1307,7 @@ packages:
     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}
     dependencies:
       ajv: 6.12.6
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       espree: 9.6.1
       globals: 13.24.0
       ignore: 5.3.2
@@ -1694,7 +1694,7 @@ packages:
     deprecated: Use @eslint/config-array instead
     dependencies:
       '@humanwhocodes/object-schema': 2.0.3
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       minimatch: 3.1.2
     transitivePeerDependencies:
       - supports-color
@@ -2030,24 +2030,6 @@ packages:
     engines: {node: '>=8'}
     dev: true
 
-  /@mapbox/node-pre-gyp@1.0.11:
-    resolution: {integrity: sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==}
-    hasBin: true
-    dependencies:
-      detect-libc: 2.0.3
-      https-proxy-agent: 5.0.1
-      make-dir: 3.1.0
-      node-fetch: 2.7.0
-      nopt: 5.0.0
-      npmlog: 5.0.1
-      rimraf: 3.0.2
-      semver: 7.6.3
-      tar: 6.2.1
-    transitivePeerDependencies:
-      - encoding
-      - supports-color
-    dev: true
-
   /@mapbox/node-pre-gyp@1.0.11(supports-color@9.4.0):
     resolution: {integrity: sha512-Yhlar6v9WQgUp/He7BdgzOz8lqMQ8sU+jkCq7Wx8Myc5YFJLbEe7lgui/V7G1qB1DJykHSGwreceSaD60Y0PUQ==}
     hasBin: true
@@ -2229,38 +2211,6 @@ packages:
       yargs: 17.7.2
     dev: true
 
-  /@netlify/edge-bundler@12.2.3:
-    resolution: {integrity: sha512-o/Od4gvGT2qPSjJ1TSh8KYDJHfzxW4iemA5DiZtXIDgaIvWgvehZKDROp9wJ2FseP2F83y4ZDmt5xFfBSD9IYQ==}
-    engines: {node: ^14.16.0 || >=16.0.0}
-    dependencies:
-      '@import-maps/resolve': 1.0.1
-      '@vercel/nft': 0.27.4
-      ajv: 8.17.1
-      ajv-errors: 3.0.0(ajv@8.17.1)
-      better-ajv-errors: 1.2.0(ajv@8.17.1)
-      common-path-prefix: 3.0.0
-      env-paths: 3.0.0
-      esbuild: 0.21.2
-      execa: 6.1.0
-      find-up: 6.3.0
-      get-package-name: 2.2.0
-      get-port: 6.1.2
-      is-path-inside: 4.0.0
-      jsonc-parser: 3.3.1
-      node-fetch: 3.3.2
-      node-stream-zip: 1.15.0
-      p-retry: 5.1.2
-      p-wait-for: 4.1.0
-      path-key: 4.0.0
-      semver: 7.6.3
-      tmp-promise: 3.0.3
-      urlpattern-polyfill: 8.0.2
-      uuid: 9.0.1
-    transitivePeerDependencies:
-      - encoding
-      - supports-color
-    dev: true
-
   /@netlify/edge-bundler@12.2.3(supports-color@9.4.0):
     resolution: {integrity: sha512-o/Od4gvGT2qPSjJ1TSh8KYDJHfzxW4iemA5DiZtXIDgaIvWgvehZKDROp9wJ2FseP2F83y4ZDmt5xFfBSD9IYQ==}
     engines: {node: ^14.16.0 || >=16.0.0}
@@ -2500,50 +2450,6 @@ packages:
       urlpattern-polyfill: 8.0.2
     dev: true
 
-  /@netlify/zip-it-and-ship-it@9.38.0:
-    resolution: {integrity: sha512-xQK4O0rhAbzboKod/Dw7EwzwDKLki8ui+zTpA8iS5RtLMRtRUPI8P+aSScafwrt3HL3NHmNe8Pdd+0RYSTGQDQ==}
-    engines: {node: ^14.18.0 || >=16.0.0}
-    hasBin: true
-    dependencies:
-      '@babel/parser': 7.25.6
-      '@babel/types': 7.25.2
-      '@netlify/binary-info': 1.0.0
-      '@netlify/serverless-functions-api': 1.23.0
-      '@vercel/nft': 0.27.4
-      archiver: 7.0.1
-      common-path-prefix: 3.0.0
-      cp-file: 10.0.0
-      es-module-lexer: 1.5.4
-      esbuild: 0.19.11
-      execa: 6.1.0
-      fast-glob: 3.3.2
-      filter-obj: 5.1.0
-      find-up: 6.3.0
-      glob: 8.1.0
-      is-builtin-module: 3.2.1
-      is-path-inside: 4.0.0
-      junk: 4.0.1
-      locate-path: 7.2.0
-      merge-options: 3.0.4
-      minimatch: 9.0.5
-      normalize-path: 3.0.0
-      p-map: 5.5.0
-      path-exists: 5.0.0
-      precinct: 11.0.5(supports-color@9.4.0)
-      require-package-name: 2.0.1
-      resolve: 2.0.0-next.5
-      semver: 7.6.3
-      tmp-promise: 3.0.3
-      toml: 3.0.0
-      unixify: 1.0.0
-      urlpattern-polyfill: 8.0.2
-      yargs: 17.7.2
-      zod: 3.23.8
-    transitivePeerDependencies:
-      - encoding
-      - supports-color
-    dev: true
-
   /@netlify/zip-it-and-ship-it@9.38.0(supports-color@9.4.0):
     resolution: {integrity: sha512-xQK4O0rhAbzboKod/Dw7EwzwDKLki8ui+zTpA8iS5RtLMRtRUPI8P+aSScafwrt3HL3NHmNe8Pdd+0RYSTGQDQ==}
     engines: {node: ^14.18.0 || >=16.0.0}
@@ -2782,7 +2688,7 @@ packages:
       ethers: ^6.1.0
       hardhat: ^2.0.0
     dependencies:
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       ethers: 6.13.2
       hardhat: 2.22.10(ts-node@10.9.2)(typescript@5.6.2)
       lodash.isequal: 4.5.0
@@ -2848,7 +2754,7 @@ packages:
       '@ethersproject/address': 5.7.0
       cbor: 8.1.0
       chalk: 2.4.2
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       hardhat: 2.22.10(ts-node@10.9.2)(typescript@5.6.2)
       lodash.clonedeep: 4.5.0
       semver: 6.3.1
@@ -3142,7 +3048,7 @@ packages:
       '@openzeppelin/defender-sdk-network-client': 1.14.3(debug@4.3.7)
       '@openzeppelin/upgrades-core': 1.37.1
       chalk: 4.1.2
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       ethereumjs-util: 7.1.5
       ethers: 6.13.2
       hardhat: 2.22.10(ts-node@10.9.2)(typescript@5.6.2)
@@ -3161,7 +3067,7 @@ packages:
       cbor: 9.0.2
       chalk: 4.1.2
       compare-versions: 6.1.1
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       ethereumjs-util: 7.1.5
       minimatch: 9.0.5
       minimist: 1.2.8
@@ -3550,7 +3456,7 @@ packages:
       '@sentry/types': 5.30.0
       '@sentry/utils': 5.30.0
       cookie: 0.4.2
-      https-proxy-agent: 5.0.1
+      https-proxy-agent: 5.0.1(supports-color@9.4.0)
       lru_map: 0.3.3
       tslib: 1.14.1
     transitivePeerDependencies:
@@ -4019,7 +3925,7 @@ packages:
       '@typescript-eslint/type-utils': 6.21.0(eslint@8.57.0)(typescript@5.6.2)
       '@typescript-eslint/utils': 6.21.0(eslint@8.57.0)(typescript@5.6.2)
       '@typescript-eslint/visitor-keys': 6.21.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       eslint: 8.57.0
       graphemer: 1.4.0
       ignore: 5.3.2
@@ -4045,7 +3951,7 @@ packages:
       '@typescript-eslint/types': 6.21.0
       '@typescript-eslint/typescript-estree': 6.21.0(typescript@5.6.2)
       '@typescript-eslint/visitor-keys': 6.21.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       eslint: 8.57.0
       typescript: 5.6.2
     transitivePeerDependencies:
@@ -4072,7 +3978,7 @@ packages:
     dependencies:
       '@typescript-eslint/typescript-estree': 6.21.0(typescript@5.6.2)
       '@typescript-eslint/utils': 6.21.0(eslint@8.57.0)(typescript@5.6.2)
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       eslint: 8.57.0
       ts-api-utils: 1.3.0(typescript@5.6.2)
       typescript: 5.6.2
@@ -4122,7 +4028,7 @@ packages:
     dependencies:
       '@typescript-eslint/types': 6.21.0
       '@typescript-eslint/visitor-keys': 6.21.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       globby: 11.1.0
       is-glob: 4.0.3
       minimatch: 9.0.3
@@ -4172,28 +4078,6 @@ packages:
     resolution: {integrity: sha512-zuVdFrMJiuCDQUMCzQaD6KL28MjnqqN8XnAqiEq9PNm/hCPTSGfrXCOfwj1ow4LFb/tNymJPwsNbVePc1xFqrQ==}
     dev: true
 
-  /@vercel/nft@0.27.4:
-    resolution: {integrity: sha512-Rioz3LJkEKicKCi9BSyc1RXZ5R6GmXosFMeBSThh6msWSOiArKhb7c75MiWwZEgPL7x0/l3TAfH/l0cxKNuUFA==}
-    engines: {node: '>=16'}
-    hasBin: true
-    dependencies:
-      '@mapbox/node-pre-gyp': 1.0.11
-      '@rollup/pluginutils': 4.2.1
-      acorn: 8.12.1
-      acorn-import-attributes: 1.9.5(acorn@8.12.1)
-      async-sema: 3.1.1
-      bindings: 1.5.0
-      estree-walker: 2.0.2
-      glob: 7.2.3
-      graceful-fs: 4.2.11
-      micromatch: 4.0.8
-      node-gyp-build: 4.8.2
-      resolve-from: 5.0.0
-    transitivePeerDependencies:
-      - encoding
-      - supports-color
-    dev: true
-
   /@vercel/nft@0.27.4(supports-color@9.4.0):
     resolution: {integrity: sha512-Rioz3LJkEKicKCi9BSyc1RXZ5R6GmXosFMeBSThh6msWSOiArKhb7c75MiWwZEgPL7x0/l3TAfH/l0cxKNuUFA==}
     engines: {node: '>=16'}
@@ -4383,14 +4267,6 @@ packages:
     resolution: {integrity: sha512-G965FqalsNyrPqgEGON7nIx1e/OVENSgiEIzyC63haUMuvNnwIgIjMs52hlTCKhkBny7A2ORNlfY9Zu+jmGk1Q==}
     dev: true
 
-  /agent-base@6.0.2:
-    resolution: {integrity: sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==}
-    engines: {node: '>= 6.0.0'}
-    dependencies:
-      debug: 4.3.7(supports-color@8.1.1)
-    transitivePeerDependencies:
-      - supports-color
-
   /agent-base@6.0.2(supports-color@9.4.0):
     resolution: {integrity: sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==}
     engines: {node: '>= 6.0.0'}
@@ -4398,7 +4274,6 @@ packages:
       debug: 4.3.7(supports-color@9.4.0)
     transitivePeerDependencies:
       - supports-color
-    dev: true
 
   /agent-base@7.1.1:
     resolution: {integrity: sha512-H0TSyFNDMomMNJQBn8wFV5YC/2eJ+VXECwOadZJT554xP6cODZHPX3H9QMQECxvrgiSOP1pHjy1sMWQVYJOUOA==}
@@ -4879,6 +4754,16 @@ packages:
       - debug
     dev: true
 
+  /axios@1.7.7:
+    resolution: {integrity: sha512-S4kL7XrjgBmvdGut0sN3yJxqYzrDOnivkBiN0OFs6hLiUam3UPvswUo0kqGyhqUZGEOytHyumEdXsAkgCOUf3Q==}
+    dependencies:
+      follow-redirects: 1.15.9(debug@4.3.6)
+      form-data: 4.0.0
+      proxy-from-env: 1.1.0
+    transitivePeerDependencies:
+      - debug
+    dev: true
+
   /axios@1.7.7(debug@4.3.7):
     resolution: {integrity: sha512-S4kL7XrjgBmvdGut0sN3yJxqYzrDOnivkBiN0OFs6hLiUam3UPvswUo0kqGyhqUZGEOytHyumEdXsAkgCOUf3Q==}
     dependencies:
@@ -6209,7 +6094,6 @@ packages:
     dependencies:
       ms: 2.1.3
       supports-color: 9.4.0
-    dev: true
 
   /decache@4.6.2:
     resolution: {integrity: sha512-2LPqkLeu8XWHU8qNCS3kcF6sCcb5zIzvWaAHYSvPfwhdd7mHuah29NssMzrTYyHN4F5oFy2ko9OBYxegtU0FEw==}
@@ -7237,7 +7121,7 @@ packages:
       ajv: 6.12.6
       chalk: 4.1.2
       cross-spawn: 7.0.3
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       doctrine: 3.0.0
       escape-string-regexp: 4.0.0
       eslint-scope: 7.2.2
@@ -7332,7 +7216,7 @@ packages:
         optional: true
     dependencies:
       '@solidity-parser/parser': 0.14.5
-      axios: 1.7.7(debug@4.3.7)
+      axios: 1.7.7
       cli-table3: 0.5.1
       colors: 1.4.0
       ethereum-cryptography: 1.2.0
@@ -7485,6 +7369,7 @@ packages:
     dependencies:
       is-hex-prefixed: 1.0.0
       strip-hex-prefix: 1.0.0
+    bundledDependencies: false
 
   /event-target-shim@5.0.1:
     resolution: {integrity: sha512-i/2XbnSz/uxRCU6+NdVJgKWDTM427+MqYbkQzD321DuCQJUqOuJKIA0IM2+W2xtYHdKOmZ4dR6fExsd4SXL+WQ==}
@@ -8047,7 +7932,7 @@ packages:
       debug:
         optional: true
     dependencies:
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
 
   /for-each@0.3.3:
     resolution: {integrity: sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==}
@@ -8615,7 +8500,7 @@ packages:
       axios: 0.21.4(debug@4.3.7)
       chalk: 4.1.2
       chokidar: 3.6.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       enquirer: 2.4.1
       ethers: 5.7.2
       form-data: 4.0.0
@@ -8675,7 +8560,7 @@ packages:
       chalk: 2.4.2
       chokidar: 3.6.0
       ci-info: 2.0.0
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       enquirer: 2.4.1
       env-paths: 2.2.1
       ethereum-cryptography: 1.2.0
@@ -8878,8 +8763,8 @@ packages:
     engines: {node: '>= 6'}
     dependencies:
       '@tootallnate/once': 2.0.0
-      agent-base: 6.0.2
-      debug: 4.3.7(supports-color@8.1.1)
+      agent-base: 6.0.2(supports-color@9.4.0)
+      debug: 4.3.7(supports-color@9.4.0)
     transitivePeerDependencies:
       - supports-color
     dev: true
@@ -8932,15 +8817,6 @@ packages:
       resolve-alpn: 1.2.1
     dev: true
 
-  /https-proxy-agent@5.0.1:
-    resolution: {integrity: sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==}
-    engines: {node: '>= 6'}
-    dependencies:
-      agent-base: 6.0.2
-      debug: 4.3.7(supports-color@8.1.1)
-    transitivePeerDependencies:
-      - supports-color
-
   /https-proxy-agent@5.0.1(supports-color@9.4.0):
     resolution: {integrity: sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==}
     engines: {node: '>= 6'}
@@ -8949,7 +8825,6 @@ packages:
       debug: 4.3.7(supports-color@9.4.0)
     transitivePeerDependencies:
       - supports-color
-    dev: true
 
   /https-proxy-agent@7.0.5:
     resolution: {integrity: sha512-1e4Wqeblerz+tMKPIq2EMGiiWW1dIjZOksyHWSUm1rmuvw/how9hBHZ38lAGj5ID4Ik6EdkOw7NmWPy6LAwalw==}
@@ -9606,7 +9481,7 @@ packages:
     resolution: {integrity: sha512-n3s8EwkdFIJCG3BPKBYvskgXGoy88ARzvegkitk60NxRdwltLOTaH7CUiMRXvwYorl0Q712iEjcWB+fK/MrWVw==}
     engines: {node: '>=10'}
     dependencies:
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       istanbul-lib-coverage: 3.2.2
       source-map: 0.6.1
     transitivePeerDependencies:
@@ -10189,7 +10064,7 @@ packages:
       form-data: 4.0.0
       html-encoding-sniffer: 3.0.0
       http-proxy-agent: 5.0.0
-      https-proxy-agent: 5.0.1
+      https-proxy-agent: 5.0.1(supports-color@9.4.0)
       is-potential-custom-element-name: 1.0.1
       nwsapi: 2.2.12
       parse5: 7.1.2
@@ -11090,10 +10965,10 @@ packages:
       '@netlify/build': 29.54.0(@opentelemetry/api@1.8.0)(@types/node@20.16.5)
       '@netlify/build-info': 7.14.1
       '@netlify/config': 20.19.0
-      '@netlify/edge-bundler': 12.2.3
+      '@netlify/edge-bundler': 12.2.3(supports-color@9.4.0)
       '@netlify/edge-functions': 2.9.0
       '@netlify/local-functions-proxy': 1.1.1
-      '@netlify/zip-it-and-ship-it': 9.38.0
+      '@netlify/zip-it-and-ship-it': 9.38.0(supports-color@9.4.0)
       '@octokit/rest': 20.1.1
       '@opentelemetry/api': 1.8.0
       ansi-escapes: 7.0.0
@@ -13610,7 +13485,6 @@ packages:
   /supports-color@9.4.0:
     resolution: {integrity: sha512-VL+lNrEoIXww1coLPOmiEmK/0sGigko5COxI09KzHc2VJXJsQ37UaQ+8quuxjDeA7+KnLGTWRyOXSLLR2Wb4jw==}
     engines: {node: '>=12'}
-    dev: true
 
   /supports-hyperlinks@2.3.0:
     resolution: {integrity: sha512-RpsAZlpWcDwOPQA22aCH4J0t7L8JmAvsCxfOSEwm7cQs3LshN36QaTkwd70DnBOXDWGssw2eUoc8CaRWT0XunA==}
@@ -14193,7 +14067,7 @@ packages:
       typescript: '>=4.3.0'
     dependencies:
       '@types/prettier': 2.7.3
-      debug: 4.3.7(supports-color@8.1.1)
+      debug: 4.3.7(supports-color@9.4.0)
       fs-extra: 7.0.1
       glob: 7.1.7
       js-sha3: 0.8.0
diff --git a/solidity/.env.example b/solidity/.env.example
index a1dcb14..b06cca9 100644
--- a/solidity/.env.example
+++ b/solidity/.env.example
@@ -1,8 +1,2 @@
 # Create a fresh wallet, and export the private key.
-SEPOLIA_PRIVATE_KEY=
-
-# From alchemy or similar
-SEPOLIA_RPC_URL=
-
-# Follow https://info.etherscan.com/api-keys/
-ETHERSCAN_API_KEY=
+MATSNET_PRIVATE_KEY=
diff --git a/solidity/contracts/ActivePool.sol b/solidity/contracts/ActivePool.sol
index dd80653..b65560c 100644
--- a/solidity/contracts/ActivePool.sol
+++ b/solidity/contracts/ActivePool.sol
@@ -2,8 +2,9 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
 import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./dependencies/SendCollateral.sol";
 import "./interfaces/IActivePool.sol";
@@ -19,7 +20,12 @@ import "./interfaces/IStabilityPool.sol";
  * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
  *
  */
-contract ActivePool is Ownable, CheckContract, SendCollateral, IActivePool {
+contract ActivePool is
+    CheckContract,
+    IActivePool,
+    OwnableUpgradeable,
+    SendCollateral
+{
     address public borrowerOperationsAddress;
     address public collSurplusPoolAddress;
     address public defaultPoolAddress;
@@ -31,7 +37,14 @@ contract ActivePool is Ownable, CheckContract, SendCollateral, IActivePool {
     uint256 internal principal;
     uint256 internal interest;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // --- Fallback function ---
 
diff --git a/solidity/contracts/BorrowerOperations.sol b/solidity/contracts/BorrowerOperations.sol
index 1252da7..185d30c 100644
--- a/solidity/contracts/BorrowerOperations.sol
+++ b/solidity/contracts/BorrowerOperations.sol
@@ -2,7 +2,10 @@
 
 pragma solidity ^0.8.24;
 
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
+import "./dependencies/InterestRateMath.sol";
 import "./dependencies/LiquityBase.sol";
 import "./dependencies/SendCollateral.sol";
 import "./interfaces/IBorrowerOperations.sol";
@@ -12,20 +15,14 @@ import "./interfaces/IPCV.sol";
 import "./interfaces/ISortedTroves.sol";
 import "./interfaces/ITroveManager.sol";
 import "./token/IMUSD.sol";
-import "@openzeppelin/contracts/access/Ownable.sol";
-import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
-import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
 
 contract BorrowerOperations is
-    LiquityBase,
-    Ownable,
     CheckContract,
-    SendCollateral,
     IBorrowerOperations,
-    EIP712
+    LiquityBase,
+    OwnableUpgradeable,
+    SendCollateral
 {
-    using ECDSA for bytes32;
-
     /* --- Variable container structs  ---
 
     Used to hold, return and assign variables inside a function, in order to avoid the error:
@@ -50,6 +47,8 @@ contract BorrowerOperations is
         uint256 principalAdjustment;
         uint256 interestAdjustment;
         bool isRecoveryMode;
+        uint256 newNICR;
+        uint256 maxBorrowingCapacity;
     }
 
     struct LocalVariables_openTrove {
@@ -70,17 +69,6 @@ contract BorrowerOperations is
         IInterestRateManager interestRateManager;
     }
 
-    struct OpenTrove {
-        address borrower;
-        uint256 maxFeePercentage;
-        uint256 debtAmount;
-        uint256 assetAmount;
-        address upperHint;
-        address lowerHint;
-        uint256 nonce;
-        uint256 deadline;
-    }
-
     enum BorrowerOperation {
         openTrove,
         closeTrove,
@@ -88,37 +76,29 @@ contract BorrowerOperations is
     }
 
     string public constant name = "BorrowerOperations";
+    uint256 public constant MIN_NET_DEBT_MIN = 50e18;
 
-    string private constant SIGNING_DOMAIN = "BorrowerOperations";
-    string private constant SIGNATURE_VERSION = "1";
-
-    mapping(address => uint256) private _nonces;
-
-    bytes32 private constant OPEN_TROVE_TYPEHASH =
-        keccak256(
-            "OpenTrove(address borrower,uint256 maxFeePercentage,uint256 debtAmount,uint256 assetAmount,address upperHint,address lowerHint,uint256 nonce,uint256 deadline)"
-        );
-
-    // refinancing fee is always a percentage of the borrowing (issuance) fee
-    uint8 public refinancingFeePercentage = 20;
-
-    // --- Connected contract declarations ---
-
+    // Connected contract declarations
     ITroveManager public troveManager;
-
     address public gasPoolAddress;
     address public pcvAddress;
     address public stabilityPoolAddress;
-
+    address public borrowerOperationsSignaturesAddress;
     ICollSurplusPool public collSurplusPool;
-
     IMUSD public musd;
     IPCV public pcv;
-    IInterestRateManager public interestRateManager;
 
     // A doubly linked list of Troves, sorted by their collateral ratios
     ISortedTroves public sortedTroves;
 
+    // refinancing fee is always a percentage of the borrowing (issuance) fee
+    uint8 public refinancingFeePercentage;
+
+    // Minimum amount of net mUSD debt a trove must have
+    uint256 public minNetDebt;
+    uint256 public proposedMinNetDebt;
+    uint256 public proposedMinNetDebtTime;
+
     modifier onlyGovernance() {
         require(
             msg.sender == pcv.council() || msg.sender == pcv.treasury(),
@@ -127,10 +107,16 @@ contract BorrowerOperations is
         _;
     }
 
-    constructor()
-        Ownable(msg.sender)
-        EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION)
-    {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+        refinancingFeePercentage = 20;
+        minNetDebt = 1800e18;
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // Calls on PCV behalf
     function mintBootstrapLoanFromPCV(uint256 _musdToMint) external {
@@ -141,7 +127,7 @@ contract BorrowerOperations is
         musd.mint(pcvAddress, _musdToMint);
     }
 
-    function burnDebtFromPCV(uint256 _musdToBurn) external {
+    function burnDebtFromPCV(uint256 _musdToBurn) external virtual {
         require(
             msg.sender == pcvAddress,
             "BorrowerOperations: caller must be PCV"
@@ -151,114 +137,46 @@ contract BorrowerOperations is
 
     // --- Borrower Trove Operations ---
     function openTrove(
-        uint256 _maxFeePercentage,
         uint256 _debtAmount,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable override {
-        _openTrove(
-            msg.sender,
-            _maxFeePercentage,
-            _debtAmount,
-            _assetAmount,
-            _upperHint,
-            _lowerHint
-        );
-    }
-
-    function openTroveWithSignature(
-        uint256 _maxFeePercentage,
-        uint256 _debtAmount,
-        uint256 _assetAmount,
-        address _upperHint,
-        address _lowerHint,
-        address _borrower,
-        bytes memory _signature,
-        uint256 _deadline
-    ) external payable override {
-        // solhint-disable not-rely-on-time
-        require(block.timestamp <= _deadline, "Signature expired");
-        uint256 nonce = _nonces[_borrower];
-        OpenTrove memory openTroveData = OpenTrove({
-            borrower: _borrower,
-            maxFeePercentage: _maxFeePercentage,
-            debtAmount: _debtAmount,
-            assetAmount: _assetAmount,
-            upperHint: _upperHint,
-            lowerHint: _lowerHint,
-            nonce: nonce,
-            deadline: _deadline
-        });
-
-        bytes32 digest = _hashTypedDataV4(
-            keccak256(
-                abi.encode(
-                    OPEN_TROVE_TYPEHASH,
-                    openTroveData.borrower,
-                    openTroveData.maxFeePercentage,
-                    openTroveData.debtAmount,
-                    openTroveData.assetAmount,
-                    openTroveData.upperHint,
-                    openTroveData.lowerHint,
-                    openTroveData.nonce,
-                    openTroveData.deadline
-                )
-            )
-        );
-
-        address recoveredAddress = ECDSA.recover(digest, _signature);
-        require(recoveredAddress == _borrower, "Invalid signature");
-
-        _nonces[_borrower]++;
-
-        _openTrove(
-            _borrower,
-            _maxFeePercentage,
-            _debtAmount,
-            _assetAmount,
-            _upperHint,
-            _lowerHint
-        );
+        _openTrove(msg.sender, msg.sender, _debtAmount, _upperHint, _lowerHint);
     }
 
     // Send collateral to a trove
     function addColl(
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable override {
-        _assetAmount = msg.value;
         _adjustTrove(
+            msg.sender,
+            msg.sender,
             msg.sender,
             0,
             0,
             false,
-            _assetAmount,
             _upperHint,
-            _lowerHint,
-            0
+            _lowerHint
         );
     }
 
     // Send collateral to a trove. Called by only the Stability Pool.
     function moveCollateralGainToTrove(
         address _borrower,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable override {
         _requireCallerIsStabilityPool();
-        _assetAmount = msg.value;
         _adjustTrove(
+            _borrower,
+            _borrower,
             _borrower,
             0,
             0,
             false,
-            _assetAmount,
             _upperHint,
-            _lowerHint,
-            0
+            _lowerHint
         );
     }
 
@@ -269,33 +187,32 @@ contract BorrowerOperations is
         address _lowerHint
     ) external override {
         _adjustTrove(
+            msg.sender,
+            msg.sender,
             msg.sender,
             _amount,
             0,
             false,
-            0,
             _upperHint,
-            _lowerHint,
-            0
+            _lowerHint
         );
     }
 
     // Withdraw mUSD tokens from a trove: mint new mUSD tokens to the owner, and increase the trove's principal accordingly
     function withdrawMUSD(
-        uint256 _maxFeePercentage,
         uint256 _amount,
         address _upperHint,
         address _lowerHint
     ) external override {
         _adjustTrove(
+            msg.sender,
+            msg.sender,
             msg.sender,
             0,
             _amount,
             true,
-            0,
             _upperHint,
-            _lowerHint,
-            _maxFeePercentage
+            _lowerHint
         );
     }
 
@@ -306,170 +223,59 @@ contract BorrowerOperations is
         address _lowerHint
     ) external override {
         _adjustTrove(
+            msg.sender,
+            msg.sender,
             msg.sender,
             0,
             _amount,
             false,
-            0,
             _upperHint,
-            _lowerHint,
-            0
+            _lowerHint
         );
     }
 
     function closeTrove() external override {
-        ITroveManager troveManagerCached = troveManager;
-        IActivePool activePoolCached = activePool;
-        IMUSD musdTokenCached = musd;
-        bool canMint = musdTokenCached.mintList(address(this));
-
-        troveManagerCached.updateSystemAndTroveInterest(msg.sender);
-
-        _requireTroveisActive(troveManagerCached, msg.sender);
-        uint256 price = priceFeed.fetchPrice();
-        if (canMint) {
-            _requireNotInRecoveryMode(price);
-        }
-
-        troveManagerCached.applyPendingRewards(msg.sender);
-
-        uint256 coll = troveManagerCached.getTroveColl(msg.sender);
-        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);
-        uint256 interestOwed = troveManagerCached.getTroveInterestOwed(
-            msg.sender
-        );
-
-        _requireSufficientMUSDBalance(
-            musdTokenCached,
-            msg.sender,
-            debt - MUSD_GAS_COMPENSATION
-        );
-        if (canMint) {
-            uint256 newTCR = _getNewTCRFromTroveChange(
-                coll,
-                false,
-                debt,
-                false,
-                price
-            );
-            _requireNewTCRisAboveCCR(newTCR);
-        }
-
-        troveManagerCached.removeStake(msg.sender);
-        troveManagerCached.closeTrove(msg.sender);
-
-        // slither-disable-next-line reentrancy-events
-        emit TroveUpdated(
-            msg.sender,
-            0,
-            0,
-            0,
-            0,
-            uint8(BorrowerOperation.closeTrove)
-        );
-
-        // Decrease the active pool debt by the principal (subtracting interestOwed from the total debt)
-        activePoolCached.decreaseDebt(
-            debt - MUSD_GAS_COMPENSATION - interestOwed,
-            interestOwed
-        );
-
-        // Burn the repaid mUSD from the user's balance
-        musdTokenCached.burn(msg.sender, debt - MUSD_GAS_COMPENSATION);
-
-        // Burn the gas compensation from the gas pool
-        _repayMUSD(
-            activePoolCached,
-            musdTokenCached,
-            gasPoolAddress,
-            MUSD_GAS_COMPENSATION,
-            0
-        );
-
-        // Send the collateral back to the user
-        activePoolCached.sendCollateral(msg.sender, coll);
+        _closeTrove(msg.sender, msg.sender, msg.sender);
     }
 
-    function refinance(uint256 _maxFeePercentage) external override {
-        ITroveManager troveManagerCached = troveManager;
-        IInterestRateManager interestRateManagerCached = interestRateManager;
-        _requireTroveisActive(troveManagerCached, msg.sender);
-        troveManagerCached.updateSystemAndTroveInterest(msg.sender);
-
-        uint16 oldRate = troveManagerCached.getTroveInterestRate(msg.sender);
-        uint256 oldInterest = troveManagerCached.getTroveInterestOwed(
-            msg.sender
-        );
-        uint256 oldDebt = troveManagerCached.getTroveDebt(msg.sender);
-        uint256 amount = (refinancingFeePercentage * oldDebt) / 100;
-        uint256 fee = _triggerBorrowingFee(
-            troveManagerCached,
-            musd,
-            amount,
-            _maxFeePercentage
-        );
-        // slither-disable-next-line unused-return
-        troveManagerCached.increaseTroveDebt(msg.sender, fee);
-
-        uint256 oldPrincipal = troveManagerCached.getTrovePrincipal(msg.sender);
-
-        interestRateManagerCached.removeInterestFromRate(oldRate, oldInterest);
-        interestRateManagerCached.removePrincipalFromRate(
-            oldRate,
-            oldPrincipal
-        );
-        uint16 newRate = interestRateManagerCached.interestRate();
-        interestRateManagerCached.addInterestToRate(newRate, oldInterest);
-        interestRateManagerCached.addPrincipalToRate(newRate, oldPrincipal);
-
-        troveManagerCached.setTroveInterestRate(
-            msg.sender,
-            interestRateManagerCached.interestRate()
-        );
-
-        uint256 maxBorrowingCapacity = _calculateMaxBorrowingCapacity(
-            troveManagerCached.getTroveColl(msg.sender),
-            priceFeed.fetchPrice()
-        );
-        troveManagerCached.setTroveMaxBorrowingCapacity(
-            msg.sender,
-            maxBorrowingCapacity
-        );
-
-        // slither-disable-next-line reentrancy-events
-        emit RefinancingFeePaid(msg.sender, fee);
+    function refinance() external override {
+        _refinance(msg.sender);
     }
 
+    /*
+     * adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
+     *
+     * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.
+     *
+     * If both are positive, it will revert.
+     */
     function adjustTrove(
-        uint256 _maxFeePercentage,
         uint256 _collWithdrawal,
         uint256 _debtChange,
         bool _isDebtIncrease,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable override {
-        _assetAmount = msg.value;
         _adjustTrove(
+            msg.sender,
+            msg.sender,
             msg.sender,
             _collWithdrawal,
             _debtChange,
             _isDebtIncrease,
-            _assetAmount,
             _upperHint,
-            _lowerHint,
-            _maxFeePercentage
+            _lowerHint
         );
     }
 
     // Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     function claimCollateral() external override {
-        // send collateral from CollSurplus Pool to owner
-        collSurplusPool.claimColl(msg.sender);
+        _claimCollateral(msg.sender, msg.sender);
     }
 
     function setAddresses(
         address _activePoolAddress,
+        address _borrowerOperationsSignaturesAddress,
         address _collSurplusPoolAddress,
         address _defaultPoolAddress,
         address _gasPoolAddress,
@@ -482,9 +288,10 @@ contract BorrowerOperations is
         address _troveManagerAddress
     ) external override onlyOwner {
         // This makes impossible to open a trove with zero withdrawn mUSD
-        assert(MIN_NET_DEBT > 0);
+        assert(minNetDebt > 0);
 
         checkContract(_activePoolAddress);
+        checkContract(_borrowerOperationsSignaturesAddress);
         checkContract(_collSurplusPoolAddress);
         checkContract(_defaultPoolAddress);
         checkContract(_gasPoolAddress);
@@ -498,6 +305,7 @@ contract BorrowerOperations is
 
         // slither-disable-start missing-zero-check
         activePool = IActivePool(_activePoolAddress);
+        borrowerOperationsSignaturesAddress = _borrowerOperationsSignaturesAddress;
         collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
         defaultPool = IDefaultPool(_defaultPoolAddress);
         gasPoolAddress = _gasPoolAddress;
@@ -512,6 +320,9 @@ contract BorrowerOperations is
         // slither-disable-end missing-zero-check
 
         emit ActivePoolAddressChanged(_activePoolAddress);
+        emit BorrowerOperationsSignaturesAddressChanged(
+            _borrowerOperationsSignaturesAddress
+        );
         emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
         emit DefaultPoolAddressChanged(_defaultPoolAddress);
         emit GasPoolAddressChanged(_gasPoolAddress);
@@ -533,69 +344,237 @@ contract BorrowerOperations is
             "BorrowerOps: Refinancing fee percentage must be <= 100"
         );
         refinancingFeePercentage = _refinanceFeePercentage;
+        emit RefinancingFeePercentageChanged(_refinanceFeePercentage);
+    }
+
+    function proposeMinNetDebt(uint256 _minNetDebt) external onlyGovernance {
+        require(
+            _minNetDebt >= MIN_NET_DEBT_MIN,
+            "Minimum Net Debt must be at least $50."
+        );
+        proposedMinNetDebt = _minNetDebt;
+        // solhint-disable-next-line not-rely-on-time
+        proposedMinNetDebtTime = block.timestamp;
+        emit MinNetDebtProposed(proposedMinNetDebt, proposedMinNetDebtTime);
     }
 
-    function getCompositeDebt(
-        uint256 _debt
-    ) external pure override returns (uint) {
-        return _getCompositeDebt(_debt);
+    function approveMinNetDebt() external onlyGovernance {
+        // solhint-disable not-rely-on-time
+        require(
+            block.timestamp >= proposedMinNetDebtTime + 7 days,
+            "Must wait at least 7 days before approving a change to Minimum Net Debt"
+        );
+        require(
+            proposedMinNetDebt >= MIN_NET_DEBT_MIN,
+            "Minimum Net Debt must be at least $50."
+        );
+        minNetDebt = proposedMinNetDebt;
+        emit MinNetDebtChanged(minNetDebt);
     }
 
-    function getNonce(address user) public view returns (uint256) {
-        return _nonces[user];
+    function restrictedClaimCollateral(
+        address _borrower,
+        address _recipient
+    ) external {
+        _requireCallerIsBorrowerOperationsSignatures();
+        _claimCollateral(_borrower, _recipient);
     }
 
-    function _openTrove(
+    function restrictedOpenTrove(
         address _borrower,
-        uint256 _maxFeePercentage,
+        address _recipient,
         uint256 _debtAmount,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
-    ) internal {
-        ContractsCache memory contractsCache = ContractsCache(
-            troveManager,
-            activePool,
-            musd,
-            interestRateManager
-        );
-        // slither-disable-next-line uninitialized-local
-        LocalVariables_openTrove memory vars;
+    ) external payable {
+        _requireCallerIsBorrowerOperationsSignatures();
+        _openTrove(_borrower, _recipient, _debtAmount, _upperHint, _lowerHint);
+    }
 
-        vars.price = priceFeed.fetchPrice();
-        bool isRecoveryMode = _checkRecoveryMode(vars.price);
+    function restrictedCloseTrove(
+        address _borrower,
+        address _caller,
+        address _recipient
+    ) external {
+        _requireCallerIsBorrowerOperationsSignatures();
+        _closeTrove(_borrower, _caller, _recipient);
+    }
 
-        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
-        _requireTroveisNotActive(contractsCache.troveManager, _borrower);
+    function restrictedRefinance(address _borrower) external {
+        _requireCallerIsBorrowerOperationsSignatures();
+        _refinance(_borrower);
+    }
 
-        vars.fee;
-        vars.netDebt = _debtAmount;
+    function restrictedAdjustTrove(
+        address _borrower,
+        address _recipient,
+        address _caller,
+        uint256 _collWithdrawal,
+        uint256 _mUSDChange,
+        bool _isDebtIncrease,
+        address _upperHint,
+        address _lowerHint
+    ) external payable {
+        _requireCallerIsBorrowerOperationsSignatures();
+        _adjustTrove(
+            _borrower,
+            _recipient,
+            _caller,
+            _collWithdrawal,
+            _mUSDChange,
+            _isDebtIncrease,
+            _upperHint,
+            _lowerHint
+        );
+    }
 
-        if (!isRecoveryMode) {
-            vars.fee = _triggerBorrowingFee(
-                contractsCache.troveManager,
-                contractsCache.musd,
-                _debtAmount,
-                _maxFeePercentage
+    // Burn the specified amount of MUSD from _account and decreases the total active debt
+    function _repayMUSD(
+        IActivePool _activePool,
+        IMUSD _musd,
+        address _account,
+        uint256 _principal,
+        uint256 _interest
+    ) internal {
+        _activePool.decreaseDebt(_principal, _interest);
+        _musd.burn(_account, _principal + _interest);
+    }
+
+    function _moveTokensAndCollateralfromAdjustment(
+        IActivePool _activePool,
+        IMUSD _musd,
+        address _caller,
+        address _recipient,
+        uint256 _collChange,
+        bool _isCollIncrease,
+        uint256 _principalChange,
+        uint256 _interestChange,
+        bool _isDebtIncrease,
+        uint256 _netDebtChange
+    ) internal {
+        if (_isDebtIncrease) {
+            _withdrawMUSD(
+                _activePool,
+                _musd,
+                _recipient,
+                _principalChange,
+                _netDebtChange
+            );
+        } else {
+            _repayMUSD(
+                _activePool,
+                _musd,
+                _caller,
+                _principalChange,
+                _interestChange
             );
-            vars.netDebt += vars.fee;
         }
 
-        _requireAtLeastMinNetDebt(vars.netDebt);
+        if (_isCollIncrease) {
+            _activePoolAddColl(_activePool, _collChange);
+        } else {
+            _activePool.sendCollateral(_recipient, _collChange);
+        }
+    }
 
-        // ICR is based on the composite debt, i.e. the requested amount + borrowing fee + gas comp.
-        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
-        assert(vars.compositeDebt > 0);
+    // Send collateral to Active Pool and increase its recorded collateral balance
+    function _activePoolAddColl(
+        IActivePool _activePool,
+        uint256 _amount
+    ) internal {
+        _sendCollateral(address(_activePool), _amount);
+    }
 
-        // if BTC overwrite the asset value
-        _assetAmount = msg.value;
-        vars.ICR = LiquityMath._computeCR(
-            _assetAmount,
+    // Update trove's coll and debt based on whether they increase or decrease
+    function _updateTroveFromAdjustment(
+        ITroveManager _troveManager,
+        address _borrower,
+        uint256 _collChange,
+        bool _isCollIncrease,
+        uint256 _debtChange,
+        bool _isDebtIncrease
+    )
+        internal
+        returns (uint256 newColl, uint256 newPrincipal, uint256 newInterest)
+    {
+        newColl = (_isCollIncrease)
+            ? _troveManager.increaseTroveColl(_borrower, _collChange)
+            : _troveManager.decreaseTroveColl(_borrower, _collChange);
+
+        if (_isDebtIncrease) {
+            newPrincipal = _troveManager.increaseTroveDebt(
+                _borrower,
+                _debtChange
+            );
+        } else {
+            (newPrincipal, newInterest) = _troveManager.decreaseTroveDebt(
+                _borrower,
+                _debtChange
+            );
+        }
+    }
+
+    // --- Helper functions ---
+
+    function _triggerBorrowingFee(
+        ITroveManager _troveManager,
+        IMUSD _musd,
+        uint256 _amount
+    ) internal returns (uint) {
+        uint256 fee = _troveManager.getBorrowingFee(_amount);
+
+        // Send fee to PCV contract
+        _musd.mint(pcvAddress, fee);
+        return fee;
+    }
+
+    function _openTrove(
+        address _borrower,
+        address _recipient,
+        uint256 _debtAmount,
+        address _upperHint,
+        address _lowerHint
+    ) internal {
+        ContractsCache memory contractsCache = ContractsCache(
+            troveManager,
+            activePool,
+            musd,
+            interestRateManager
+        );
+        contractsCache.troveManager.updateSystemInterest();
+        // slither-disable-next-line uninitialized-local
+        LocalVariables_openTrove memory vars;
+
+        vars.price = priceFeed.fetchPrice();
+        bool isRecoveryMode = _checkRecoveryMode(vars.price);
+
+        _requireTroveisNotActive(contractsCache.troveManager, _borrower);
+
+        vars.fee;
+        vars.netDebt = _debtAmount;
+
+        if (!isRecoveryMode) {
+            vars.fee = _triggerBorrowingFee(
+                contractsCache.troveManager,
+                contractsCache.musd,
+                _debtAmount
+            );
+            vars.netDebt += vars.fee;
+        }
+
+        _requireAtLeastMinNetDebt(vars.netDebt);
+
+        // ICR is based on the composite debt, i.e. the requested amount + borrowing fee + gas comp.
+        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
+
+        // if BTC overwrite the asset value
+        vars.ICR = LiquityMath._computeCR(
+            msg.value,
             vars.compositeDebt,
             vars.price
         );
         vars.NICR = LiquityMath._computeNominalCR(
-            _assetAmount,
+            msg.value,
             vars.compositeDebt
         );
 
@@ -604,7 +583,7 @@ contract BorrowerOperations is
         } else {
             _requireICRisAboveMCR(vars.ICR);
             uint256 newTCR = _getNewTCRFromTroveChange(
-                _assetAmount,
+                msg.value,
                 true,
                 vars.compositeDebt,
                 true,
@@ -624,7 +603,7 @@ contract BorrowerOperations is
             ITroveManager.Status.active
         );
         // slither-disable-next-line unused-return
-        contractsCache.troveManager.increaseTroveColl(_borrower, _assetAmount);
+        contractsCache.troveManager.increaseTroveColl(_borrower, msg.value);
         // slither-disable-next-line unused-return
         contractsCache.troveManager.increaseTroveDebt(
             _borrower,
@@ -640,7 +619,7 @@ contract BorrowerOperations is
 
         // Set trove's max borrowing capacity to the amount that would put it at 110% ICR
         uint256 maxBorrowingCapacity = _calculateMaxBorrowingCapacity(
-            _assetAmount,
+            msg.value,
             vars.price
         );
         contractsCache.troveManager.setTroveMaxBorrowingCapacity(
@@ -662,14 +641,15 @@ contract BorrowerOperations is
          * Move the collateral to the Active Pool, and mint the amount to the borrower
          * If the user has insuffient tokens to do the transfer to the Active Pool an error will cause the transaction to revert.
          */
-        _activePoolAddColl(contractsCache.activePool, _assetAmount);
+        _activePoolAddColl(contractsCache.activePool, msg.value);
         _withdrawMUSD(
             contractsCache.activePool,
             contractsCache.musd,
-            _borrower,
+            _recipient,
             _debtAmount,
             vars.netDebt
         );
+
         // Move the mUSD gas compensation to the Gas Pool
         _withdrawMUSD(
             contractsCache.activePool,
@@ -686,29 +666,23 @@ contract BorrowerOperations is
             _borrower,
             vars.compositeDebt,
             0,
-            _assetAmount,
+            msg.value,
             vars.stake,
             uint8(BorrowerOperation.openTrove)
         );
         emit BorrowingFeePaid(_borrower, vars.fee);
         // slither-disable-end reentrancy-events
     }
-    /*
-     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
-     *
-     * It therefore expects either a positive msg.value, or a positive _collWithdrawal argument.
-     *
-     * If both are positive, it will revert.
-     */
+
     function _adjustTrove(
         address _borrower,
+        address _recipient,
+        address _caller,
         uint256 _collWithdrawal,
         uint256 _mUSDChange,
         bool _isDebtIncrease,
-        uint256 _assetAmount,
         address _upperHint,
-        address _lowerHint,
-        uint256 _maxFeePercentage
+        address _lowerHint
     ) internal {
         ContractsCache memory contractsCache = ContractsCache(
             troveManager,
@@ -727,37 +701,37 @@ contract BorrowerOperations is
             _borrower
         );
 
-        (vars.principalAdjustment, vars.interestAdjustment) = contractsCache
-            .interestRateManager
+        (vars.principalAdjustment, vars.interestAdjustment) = InterestRateMath
             .calculateDebtAdjustment(vars.interestOwed, _mUSDChange);
 
         vars.price = priceFeed.fetchPrice();
         vars.isRecoveryMode = _checkRecoveryMode(vars.price);
 
         if (_isDebtIncrease) {
-            _requireValidMaxFeePercentage(
-                _maxFeePercentage,
-                vars.isRecoveryMode
-            );
             _requireNonZeroDebtChange(_mUSDChange);
         }
-        _requireSingularCollChange(_collWithdrawal, _assetAmount);
-        _requireNonZeroAdjustment(_collWithdrawal, _mUSDChange, _assetAmount);
+        _requireSingularCollChange(_collWithdrawal, msg.value);
+        _requireNonZeroAdjustment(_collWithdrawal, _mUSDChange, msg.value);
         _requireTroveisActive(contractsCache.troveManager, _borrower);
 
-        // Confirm the operation is either a borrower adjusting their own trove, or a pure collateral transfer from the Stability Pool to a trove
+        /*
+         * Confirm the operation is either a borrower adjusting their own trove (either directly or through
+         * a signature), or a pure collateral transfer from the Stability Pool to a trove
+         */
         assert(
             msg.sender == _borrower ||
                 (msg.sender == stabilityPoolAddress &&
-                    _assetAmount > 0 &&
-                    _mUSDChange == 0)
+                    msg.value > 0 &&
+                    _mUSDChange == 0) ||
+                msg.sender == address(this) ||
+                msg.sender == borrowerOperationsSignaturesAddress
         );
 
         contractsCache.troveManager.applyPendingRewards(_borrower);
 
         // Get the collChange based on whether or not collateral was sent in the transaction
         (vars.collChange, vars.isCollIncrease) = _getCollChange(
-            _assetAmount,
+            msg.value,
             _collWithdrawal
         );
 
@@ -768,8 +742,7 @@ contract BorrowerOperations is
             vars.fee = _triggerBorrowingFee(
                 contractsCache.troveManager,
                 contractsCache.musd,
-                _mUSDChange,
-                _maxFeePercentage
+                _mUSDChange
             );
             vars.netDebtChange += vars.fee; // The raw debt change includes the fee
         }
@@ -798,17 +771,20 @@ contract BorrowerOperations is
             vars
         );
 
+        vars.maxBorrowingCapacity = contractsCache
+            .troveManager
+            .getTroveMaxBorrowingCapacity(_borrower);
+        if (_isDebtIncrease) {
+            _requireHasBorrowingCapacity(vars);
+        }
+
         // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough mUSD
         if (!_isDebtIncrease && _mUSDChange > 0) {
             _requireAtLeastMinNetDebt(
                 _getNetDebt(vars.debt) - vars.netDebtChange
             );
             _requireValidMUSDRepayment(vars.debt, vars.netDebtChange);
-            _requireSufficientMUSDBalance(
-                contractsCache.musd,
-                _borrower,
-                vars.netDebtChange
-            );
+            _requireSufficientMUSDBalance(_borrower, vars.netDebtChange);
         }
 
         (
@@ -827,16 +803,34 @@ contract BorrowerOperations is
             _borrower
         );
 
+        // If collateral was withdrawn, update the maxBorrowingCapacity
+        if (!vars.isCollIncrease && vars.collChange > 0) {
+            uint256 newMaxBorrowingCapacity = _calculateMaxBorrowingCapacity(
+                vars.newColl,
+                vars.price
+            );
+
+            uint256 currentMaxBorrowingCapacity = contractsCache
+                .troveManager
+                .getTroveMaxBorrowingCapacity(_borrower);
+
+            uint256 finalMaxBorrowingCapacity = LiquityMath._min(
+                currentMaxBorrowingCapacity,
+                newMaxBorrowingCapacity
+            );
+
+            contractsCache.troveManager.setTroveMaxBorrowingCapacity(
+                _borrower,
+                finalMaxBorrowingCapacity
+            );
+        }
+
         // Re-insert trove in to the sorted list
-        uint256 newNICR = _getNewNominalICRFromTroveChange(
-            vars.coll,
-            vars.debt,
-            vars.collChange,
-            vars.isCollIncrease,
-            vars.netDebtChange,
-            _isDebtIncrease
+        vars.newNICR = LiquityMath._computeNominalCR(
+            vars.newColl,
+            vars.newPrincipal
         );
-        sortedTroves.reInsert(_borrower, newNICR, _upperHint, _lowerHint);
+        sortedTroves.reInsert(_borrower, vars.newNICR, _upperHint, _lowerHint);
 
         // slither-disable-next-line reentrancy-events
         emit TroveUpdated(
@@ -848,13 +842,14 @@ contract BorrowerOperations is
             uint8(BorrowerOperation.adjustTrove)
         );
         // slither-disable-next-line reentrancy-events
-        emit BorrowingFeePaid(msg.sender, vars.fee);
+        emit BorrowingFeePaid(_borrower, vars.fee);
 
         // Use the unmodified _mUSDChange here, as we don't send the fee to the user
         _moveTokensAndCollateralfromAdjustment(
             contractsCache.activePool,
             contractsCache.musd,
-            msg.sender,
+            _caller,
+            _recipient,
             vars.collChange,
             vars.isCollIncrease,
             _isDebtIncrease ? _mUSDChange : vars.principalAdjustment,
@@ -864,119 +859,152 @@ contract BorrowerOperations is
         );
     }
 
-    // Issue the specified amount of mUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a MUSDFee)
-    function _withdrawMUSD(
-        IActivePool _activePool,
-        IMUSD _musd,
-        address _account,
-        uint256 _debtAmount,
-        uint256 _netDebtIncrease
-    ) internal {
-        _activePool.increaseDebt(_netDebtIncrease, 0);
-        _musd.mint(_account, _debtAmount);
-    }
-
-    // Burn the specified amount of MUSD from _account and decreases the total active debt
-    function _repayMUSD(
-        IActivePool _activePool,
-        IMUSD _musd,
-        address _account,
-        uint256 _principal,
-        uint256 _interest
-    ) internal {
-        _activePool.decreaseDebt(_principal, _interest);
-        _musd.burn(_account, _principal + _interest);
-    }
-
-    function _moveTokensAndCollateralfromAdjustment(
-        IActivePool _activePool,
-        IMUSD _musd,
+    function _closeTrove(
         address _borrower,
-        uint256 _collChange,
-        bool _isCollIncrease,
-        uint256 _principalChange,
-        uint256 _interestChange,
-        bool _isDebtIncrease,
-        uint256 _netDebtChange
+        address _caller,
+        address _recipient
     ) internal {
-        if (_isDebtIncrease) {
-            _withdrawMUSD(
-                _activePool,
-                _musd,
-                _borrower,
-                _principalChange,
-                _netDebtChange
-            );
-        } else {
-            _repayMUSD(
-                _activePool,
-                _musd,
-                _borrower,
-                _principalChange,
-                _interestChange
-            );
-        }
+        ITroveManager troveManagerCached = troveManager;
+        troveManagerCached.updateSystemAndTroveInterest(_borrower);
 
-        if (_isCollIncrease) {
-            _activePoolAddColl(_activePool, _collChange);
-        } else {
-            _activePool.sendCollateral(_borrower, _collChange);
+        IActivePool activePoolCached = activePool;
+        IMUSD musdTokenCached = musd;
+        bool canMint = musdTokenCached.mintList(address(this));
+
+        _requireTroveisActive(troveManagerCached, _borrower);
+        uint256 price = priceFeed.fetchPrice();
+        if (canMint) {
+            _requireNotInRecoveryMode(price);
         }
-    }
 
-    // Send collateral to Active Pool and increase its recorded collateral balance
-    function _activePoolAddColl(
-        IActivePool _activePool,
-        uint256 _amount
-    ) internal {
-        _sendCollateral(address(_activePool), _amount);
-    }
+        troveManagerCached.applyPendingRewards(_borrower);
 
-    // Update trove's coll and debt based on whether they increase or decrease
-    function _updateTroveFromAdjustment(
-        ITroveManager _troveManager,
-        address _borrower,
-        uint256 _collChange,
-        bool _isCollIncrease,
-        uint256 _debtChange,
-        bool _isDebtIncrease
-    )
-        internal
-        returns (uint256 newColl, uint256 newPrincipal, uint256 newInterest)
-    {
-        newColl = (_isCollIncrease)
-            ? _troveManager.increaseTroveColl(_borrower, _collChange)
-            : _troveManager.decreaseTroveColl(_borrower, _collChange);
+        uint256 coll = troveManagerCached.getTroveColl(_borrower);
+        uint256 debt = troveManagerCached.getTroveDebt(_borrower);
+        uint256 interestOwed = troveManagerCached.getTroveInterestOwed(
+            _borrower
+        );
 
-        if (_isDebtIncrease) {
-            newPrincipal = _troveManager.increaseTroveDebt(
-                _borrower,
-                _debtChange
-            );
-        } else {
-            (newPrincipal, newInterest) = _troveManager.decreaseTroveDebt(
-                _borrower,
-                _debtChange
+        _requireSufficientMUSDBalance(_borrower, debt - MUSD_GAS_COMPENSATION);
+        if (canMint) {
+            uint256 newTCR = _getNewTCRFromTroveChange(
+                coll,
+                false,
+                debt,
+                false,
+                price
             );
+            _requireNewTCRisAboveCCR(newTCR);
         }
+
+        troveManagerCached.removeStake(_borrower);
+        troveManagerCached.closeTrove(_borrower);
+
+        // slither-disable-next-line reentrancy-events
+        emit TroveUpdated(
+            _borrower,
+            0,
+            0,
+            0,
+            0,
+            uint8(BorrowerOperation.closeTrove)
+        );
+
+        // Decrease the active pool debt by the principal (subtracting interestOwed from the total debt)
+        activePoolCached.decreaseDebt(
+            debt - MUSD_GAS_COMPENSATION - interestOwed,
+            interestOwed
+        );
+
+        // Burn the repaid mUSD from the user's balance
+        musdTokenCached.burn(_caller, debt - MUSD_GAS_COMPENSATION);
+
+        // Burn the gas compensation from the gas pool
+        _repayMUSD(
+            activePoolCached,
+            musdTokenCached,
+            gasPoolAddress,
+            MUSD_GAS_COMPENSATION,
+            0
+        );
+
+        // Send the collateral back to the user
+        activePoolCached.sendCollateral(_recipient, coll);
     }
 
-    // --- Helper functions ---
+    function _refinance(address _borrower) internal {
+        uint256 price = priceFeed.fetchPrice();
+        ITroveManager troveManagerCached = troveManager;
+        troveManagerCached.updateSystemAndTroveInterest(_borrower);
 
-    function _triggerBorrowingFee(
-        ITroveManager _troveManager,
+        _requireNotInRecoveryMode(price);
+        _requireTroveisActive(troveManagerCached, _borrower);
+
+        IInterestRateManager interestRateManagerCached = interestRateManager;
+
+        uint16 oldRate = troveManagerCached.getTroveInterestRate(_borrower);
+        uint256 oldDebt = troveManagerCached.getTroveDebt(_borrower);
+        uint256 amount = (refinancingFeePercentage * oldDebt) / 100;
+        uint256 fee = _triggerBorrowingFee(troveManagerCached, musd, amount);
+        // slither-disable-next-line unused-return
+        troveManagerCached.increaseTroveDebt(_borrower, fee);
+        activePool.increaseDebt(fee, 0);
+        uint256 newICR = LiquityMath._computeCR(
+            troveManagerCached.getTroveColl(_borrower),
+            troveManagerCached.getTroveDebt(_borrower),
+            price
+        );
+        _requireICRisAboveMCR(newICR);
+        _requireNewTCRisAboveCCR(troveManagerCached.getTCR(price));
+
+        uint256 oldPrincipal = troveManagerCached.getTrovePrincipal(_borrower);
+
+        interestRateManagerCached.removePrincipal(oldPrincipal, oldRate);
+        uint16 newRate = interestRateManagerCached.interestRate();
+        interestRateManagerCached.addPrincipal(oldPrincipal, newRate);
+
+        troveManagerCached.setTroveInterestRate(
+            _borrower,
+            interestRateManagerCached.interestRate()
+        );
+
+        uint256 maxBorrowingCapacity = _calculateMaxBorrowingCapacity(
+            troveManagerCached.getTroveColl(_borrower),
+            price
+        );
+        troveManagerCached.setTroveMaxBorrowingCapacity(
+            _borrower,
+            maxBorrowingCapacity
+        );
+
+        // slither-disable-next-line reentrancy-events
+        emit RefinancingFeePaid(_borrower, fee);
+    }
+
+    // Issue the specified amount of mUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a MUSDFee)
+    function _withdrawMUSD(
+        IActivePool _activePool,
         IMUSD _musd,
-        uint256 _amount,
-        uint256 _maxFeePercentage
-    ) internal returns (uint) {
-        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
-        uint256 fee = _troveManager.getBorrowingFee(_amount);
+        address _account,
+        uint256 _debtAmount,
+        uint256 _netDebtIncrease
+    ) internal {
+        _activePool.increaseDebt(_netDebtIncrease, 0);
+        _musd.mint(_account, _debtAmount);
+    }
 
-        _requireUserAcceptsFee(fee, _amount, _maxFeePercentage);
+    function _claimCollateral(address _borrower, address _recipient) internal {
+        troveManager.updateSystemInterest();
 
-        // Send fee to PCV contract
-        _musd.mint(pcvAddress, fee);
-        return fee;
+        // send collateral from CollSurplus Pool to owner
+        collSurplusPool.claimColl(_borrower, _recipient);
+    }
+
+    function _requireCallerIsBorrowerOperationsSignatures() internal view {
+        require(
+            msg.sender == borrowerOperationsSignaturesAddress,
+            "BorrowerOps: Caller is not BorrowerOperationsSignatures"
+        );
     }
 
     function _requireNotInRecoveryMode(uint256 _price) internal view {
@@ -1076,16 +1104,32 @@ contract BorrowerOperations is
     }
 
     function _requireSufficientMUSDBalance(
-        IMUSD _musd,
         address _borrower,
         uint256 _debtRepayment
     ) internal view {
         require(
-            _musd.balanceOf(_borrower) >= _debtRepayment,
+            musd.balanceOf(_borrower) >= _debtRepayment,
             "BorrowerOps: Caller doesnt have enough mUSD to make repayment"
         );
     }
 
+    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal view {
+        require(
+            _netDebt >= minNetDebt,
+            "BorrowerOps: Trove's net debt must be greater than minimum"
+        );
+    }
+
+    function _requireValidMUSDRepayment(
+        uint256 _currentDebt,
+        uint256 _debtRepayment
+    ) internal pure {
+        require(
+            _debtRepayment <= _currentDebt - MUSD_GAS_COMPENSATION,
+            "BorrowerOps: Amount repaid must not be larger than the Trove's debt"
+        );
+    }
+
     /*
      * In Recovery Mode, only allow:
      *
@@ -1153,27 +1197,6 @@ contract BorrowerOperations is
         newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;
     }
 
-    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
-    function _getNewNominalICRFromTroveChange(
-        uint256 _coll,
-        uint256 _debt,
-        uint256 _collChange,
-        bool _isCollIncrease,
-        uint256 _debtChange,
-        bool _isDebtIncrease
-    ) internal pure returns (uint) {
-        (uint256 newColl, uint256 newDebt) = _getNewTroveAmounts(
-            _coll,
-            _debt,
-            _collChange,
-            _isCollIncrease,
-            _debtChange,
-            _isDebtIncrease
-        );
-
-        return LiquityMath._computeNominalCR(newColl, newDebt);
-    }
-
     function _calculateMaxBorrowingCapacity(
         uint256 _coll,
         uint256 _price
@@ -1181,31 +1204,6 @@ contract BorrowerOperations is
         return (_coll * _price) / (110 * 1e16);
     }
 
-    function _requireValidMaxFeePercentage(
-        uint256 _maxFeePercentage,
-        bool _isRecoveryMode
-    ) internal pure {
-        if (_isRecoveryMode) {
-            require(
-                _maxFeePercentage <= DECIMAL_PRECISION,
-                "Max fee percentage must be less than or equal to 100%"
-            );
-        } else {
-            require(
-                _maxFeePercentage >= BORROWING_FEE_FLOOR &&
-                    _maxFeePercentage <= DECIMAL_PRECISION,
-                "Max fee percentage must be between 0.5% and 100%"
-            );
-        }
-    }
-
-    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
-        require(
-            _netDebt >= MIN_NET_DEBT,
-            "BorrowerOps: Trove's net debt must be greater than minimum"
-        );
-    }
-
     function _requireICRisAboveMCR(uint256 _newICR) internal pure {
         require(
             _newICR >= MCR,
@@ -1234,6 +1232,16 @@ contract BorrowerOperations is
         );
     }
 
+    function _requireHasBorrowingCapacity(
+        LocalVariables_adjustTrove memory _vars
+    ) internal pure {
+        require(
+            _vars.maxBorrowingCapacity >=
+                _vars.netDebtChange + _vars.debt + _vars.interestOwed,
+            "BorrowerOps: An operation that exceeds maxBorrowingCapacity is not permitted"
+        );
+    }
+
     function _requireSingularCollChange(
         uint256 _collWithdrawal,
         uint256 _assetAmount
@@ -1271,14 +1279,4 @@ contract BorrowerOperations is
             "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode"
         );
     }
-
-    function _requireValidMUSDRepayment(
-        uint256 _currentDebt,
-        uint256 _debtRepayment
-    ) internal pure {
-        require(
-            _debtRepayment <= _currentDebt - MUSD_GAS_COMPENSATION,
-            "BorrowerOps: Amount repaid must not be larger than the Trove's debt"
-        );
-    }
 }
diff --git a/solidity/contracts/BorrowerOperationsSignatures.sol b/solidity/contracts/BorrowerOperationsSignatures.sol
new file mode 100644
index 0000000..bc1868a
--- /dev/null
+++ b/solidity/contracts/BorrowerOperationsSignatures.sol
@@ -0,0 +1,529 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.24;
+
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+import "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol";
+import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
+import "./dependencies/CheckContract.sol";
+import "./interfaces/IBorrowerOperations.sol";
+import "./interfaces/IBorrowerOperationsSignatures.sol";
+import "./interfaces/IInterestRateManager.sol";
+
+contract BorrowerOperationsSignatures is
+    IBorrowerOperationsSignatures,
+    CheckContract,
+    EIP712Upgradeable,
+    OwnableUpgradeable
+{
+    using ECDSA for bytes32;
+
+    struct AddColl {
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        uint256 deadline;
+    }
+
+    struct OpenTrove {
+        uint256 debtAmount;
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    struct WithdrawColl {
+        uint256 amount;
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    struct RepayMUSD {
+        uint256 amount;
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        uint256 deadline;
+    }
+
+    struct WithdrawMUSD {
+        uint256 amount;
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    struct AdjustTrove {
+        uint256 collWithdrawal;
+        uint256 debtChange;
+        bool isDebtIncrease;
+        address upperHint;
+        address lowerHint;
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    struct CloseTrove {
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    struct Refinance {
+        address borrower;
+        uint256 deadline;
+    }
+
+    struct ClaimCollateral {
+        address borrower;
+        address recipient;
+        uint256 deadline;
+    }
+
+    string private constant SIGNING_DOMAIN = "BorrowerOperationsSignatures";
+    string private constant SIGNATURE_VERSION = "1";
+
+    bytes32 private constant OPEN_TROVE_TYPEHASH =
+        keccak256(
+            "OpenTrove(uint256 assetAmount,uint256 debtAmount,address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant ADD_COLL_TYPEHASH =
+        keccak256(
+            "AddColl(uint256 assetAmount,address borrower,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant WITHDRAW_COLL_TYPEHASH =
+        keccak256(
+            "WithdrawColl(uint256 amount,address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant REPAY_MUSD_TYPEHASH =
+        keccak256(
+            "RepayMUSD(uint256 amount,address borrower,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant WITHDRAW_MUSD_TYPEHASH =
+        keccak256(
+            "WithdrawMUSD(uint256 amount,address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant ADJUST_TROVE_TYPEHASH =
+        keccak256(
+            "AdjustTrove(uint256 collWithdrawal,uint256 debtChange,bool isDebtIncrease,uint256 assetAmount,address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant CLOSE_TROVE_TYPEHASH =
+        keccak256(
+            "CloseTrove(address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant REFINANCE_TYPEHASH =
+        keccak256(
+            "Refinance(address borrower,uint16 interestRate,uint256 nonce,uint256 deadline)"
+        );
+
+    bytes32 private constant CLAIM_COLLATERAL_TYPEHASH =
+        keccak256(
+            "ClaimCollateral(address borrower,address recipient,uint256 nonce,uint256 deadline)"
+        );
+
+    mapping(address => uint256) private nonces;
+    IBorrowerOperations public borrowerOperations;
+    IInterestRateManager public interestRateManager;
+
+    event BorrowerOperationsAddressChanged(
+        address _newBorrowerOperationsAddress
+    );
+    event InterestRateManagerAddressChanged(
+        address _newInterestRateManagerAddress
+    );
+
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+        __EIP712_init_unchained(SIGNING_DOMAIN, SIGNATURE_VERSION);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
+
+    function setAddresses(
+        address _borrowerOperationsAddress,
+        address _interestRateManagerAddress
+    ) external onlyOwner {
+        checkContract(_borrowerOperationsAddress);
+        checkContract(_interestRateManagerAddress);
+
+        // slither-disable-start missing-zero-check
+        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
+        interestRateManager = IInterestRateManager(_interestRateManagerAddress);
+        // slither-disable-end missing-zero-check
+
+        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
+        emit InterestRateManagerAddressChanged(_interestRateManagerAddress);
+
+        renounceOwnership();
+    }
+
+    function addCollWithSignature(
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable {
+        AddColl memory addCollData = AddColl({
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            ADD_COLL_TYPEHASH,
+            abi.encode(msg.value, addCollData.borrower),
+            addCollData.borrower,
+            _signature,
+            addCollData.deadline
+        );
+
+        borrowerOperations.restrictedAdjustTrove{value: msg.value}(
+            addCollData.borrower,
+            addCollData.borrower,
+            msg.sender,
+            0,
+            0,
+            false,
+            addCollData.upperHint,
+            addCollData.lowerHint
+        );
+    }
+
+    function closeTroveWithSignature(
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        CloseTrove memory closeTroveData = CloseTrove({
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            CLOSE_TROVE_TYPEHASH,
+            abi.encode(closeTroveData.borrower, closeTroveData.recipient),
+            closeTroveData.borrower,
+            _signature,
+            closeTroveData.deadline
+        );
+
+        borrowerOperations.restrictedCloseTrove(
+            closeTroveData.borrower,
+            msg.sender,
+            closeTroveData.recipient
+        );
+    }
+
+    function adjustTroveWithSignature(
+        uint256 _collWithdrawal,
+        uint256 _debtChange,
+        bool _isDebtIncrease,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable {
+        AdjustTrove memory adjustTroveData = AdjustTrove({
+            collWithdrawal: _collWithdrawal,
+            debtChange: _debtChange,
+            isDebtIncrease: _isDebtIncrease,
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            ADJUST_TROVE_TYPEHASH,
+            abi.encode(
+                adjustTroveData.collWithdrawal,
+                adjustTroveData.debtChange,
+                adjustTroveData.isDebtIncrease,
+                msg.value,
+                adjustTroveData.borrower,
+                adjustTroveData.recipient
+            ),
+            adjustTroveData.borrower,
+            _signature,
+            adjustTroveData.deadline
+        );
+
+        borrowerOperations.restrictedAdjustTrove{value: msg.value}(
+            adjustTroveData.borrower,
+            adjustTroveData.recipient,
+            msg.sender,
+            adjustTroveData.collWithdrawal,
+            adjustTroveData.debtChange,
+            adjustTroveData.isDebtIncrease,
+            adjustTroveData.upperHint,
+            adjustTroveData.lowerHint
+        );
+    }
+
+    function withdrawCollWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        WithdrawColl memory withdrawCollData = WithdrawColl({
+            amount: _amount,
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            WITHDRAW_COLL_TYPEHASH,
+            abi.encode(
+                withdrawCollData.amount,
+                withdrawCollData.borrower,
+                withdrawCollData.recipient
+            ),
+            withdrawCollData.borrower,
+            _signature,
+            withdrawCollData.deadline
+        );
+
+        borrowerOperations.restrictedAdjustTrove(
+            withdrawCollData.borrower,
+            withdrawCollData.recipient,
+            msg.sender,
+            withdrawCollData.amount,
+            0,
+            false,
+            withdrawCollData.upperHint,
+            withdrawCollData.lowerHint
+        );
+    }
+
+    function openTroveWithSignature(
+        uint256 _debtAmount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable {
+        OpenTrove memory openTroveData = OpenTrove({
+            debtAmount: _debtAmount,
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            OPEN_TROVE_TYPEHASH,
+            abi.encode(
+                msg.value,
+                openTroveData.debtAmount,
+                openTroveData.borrower,
+                openTroveData.recipient
+            ),
+            openTroveData.borrower,
+            _signature,
+            openTroveData.deadline
+        );
+
+        borrowerOperations.restrictedOpenTrove{value: msg.value}(
+            openTroveData.borrower,
+            openTroveData.recipient,
+            openTroveData.debtAmount,
+            openTroveData.upperHint,
+            openTroveData.lowerHint
+        );
+    }
+
+    function withdrawMUSDWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        WithdrawMUSD memory withdrawMUSDData = WithdrawMUSD({
+            amount: _amount,
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            WITHDRAW_MUSD_TYPEHASH,
+            abi.encode(
+                withdrawMUSDData.amount,
+                withdrawMUSDData.borrower,
+                withdrawMUSDData.recipient
+            ),
+            withdrawMUSDData.borrower,
+            _signature,
+            withdrawMUSDData.deadline
+        );
+
+        borrowerOperations.restrictedAdjustTrove(
+            withdrawMUSDData.borrower,
+            withdrawMUSDData.recipient,
+            msg.sender,
+            0,
+            withdrawMUSDData.amount,
+            true,
+            withdrawMUSDData.upperHint,
+            withdrawMUSDData.lowerHint
+        );
+    }
+
+    function repayMUSDWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        RepayMUSD memory repayMUSDData = RepayMUSD({
+            amount: _amount,
+            upperHint: _upperHint,
+            lowerHint: _lowerHint,
+            borrower: _borrower,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            REPAY_MUSD_TYPEHASH,
+            abi.encode(repayMUSDData.amount, repayMUSDData.borrower),
+            repayMUSDData.borrower,
+            _signature,
+            repayMUSDData.deadline
+        );
+
+        borrowerOperations.restrictedAdjustTrove(
+            repayMUSDData.borrower,
+            repayMUSDData.borrower,
+            msg.sender,
+            0,
+            repayMUSDData.amount,
+            false,
+            repayMUSDData.upperHint,
+            repayMUSDData.lowerHint
+        );
+    }
+
+    function refinanceWithSignature(
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        Refinance memory refinanceData = Refinance({
+            borrower: _borrower,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            REFINANCE_TYPEHASH,
+            abi.encode(
+                refinanceData.borrower,
+                interestRateManager.interestRate()
+            ),
+            _borrower,
+            _signature,
+            _deadline
+        );
+
+        borrowerOperations.restrictedRefinance(refinanceData.borrower);
+    }
+
+    function claimCollateralWithSignature(
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external {
+        ClaimCollateral memory claimCollateralData = ClaimCollateral({
+            borrower: _borrower,
+            recipient: _recipient,
+            deadline: _deadline
+        });
+
+        _verifySignature(
+            CLAIM_COLLATERAL_TYPEHASH,
+            abi.encode(
+                claimCollateralData.borrower,
+                claimCollateralData.recipient
+            ),
+            claimCollateralData.borrower,
+            _signature,
+            claimCollateralData.deadline
+        );
+
+        borrowerOperations.restrictedClaimCollateral(
+            claimCollateralData.borrower,
+            claimCollateralData.recipient
+        );
+    }
+
+    function getNonce(address user) public view returns (uint256) {
+        return nonces[user];
+    }
+
+    function _verifySignature(
+        bytes32 _typeHash,
+        bytes memory _data,
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) internal {
+        // solhint-disable-next-line not-rely-on-time
+        require(block.timestamp <= _deadline, "Signature expired");
+
+        bytes32 digest = _hashTypedDataV4(
+            keccak256(
+                abi.encodePacked(_typeHash, _data, nonces[_borrower], _deadline)
+            )
+        );
+
+        address recoveredAddress = ECDSA.recover(digest, _signature);
+        require(
+            recoveredAddress == _borrower,
+            "BorrowerOperationsSignatures: Invalid signature"
+        );
+
+        nonces[_borrower]++;
+    }
+}
diff --git a/solidity/contracts/CollSurplusPool.sol b/solidity/contracts/CollSurplusPool.sol
index 9356777..4882e0a 100644
--- a/solidity/contracts/CollSurplusPool.sol
+++ b/solidity/contracts/CollSurplusPool.sol
@@ -2,7 +2,8 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./dependencies/SendCollateral.sol";
 import "./interfaces/ICollSurplusPool.sol";
@@ -10,10 +11,10 @@ import "./interfaces/IBorrowerOperations.sol";
 import "./interfaces/IActivePool.sol";
 
 contract CollSurplusPool is
-    Ownable,
     CheckContract,
-    SendCollateral,
-    ICollSurplusPool
+    ICollSurplusPool,
+    OwnableUpgradeable,
+    SendCollateral
 {
     string public constant NAME = "CollSurplusPool";
 
@@ -26,7 +27,14 @@ contract CollSurplusPool is
     // Collateral surplus claimable by trove owners
     mapping(address => uint) internal balances;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // --- Fallback function ---
 
@@ -76,7 +84,7 @@ contract CollSurplusPool is
         emit CollBalanceUpdated(_account, newAmount);
     }
 
-    function claimColl(address _account) external override {
+    function claimColl(address _account, address _recipient) external override {
         _requireCallerIsBorrowerOperations();
         uint256 claimableColl = balances[_account];
         require(
@@ -90,7 +98,7 @@ contract CollSurplusPool is
         collateral -= claimableColl;
         emit CollateralSent(_account, claimableColl);
 
-        _sendCollateral(_account, claimableColl);
+        _sendCollateral(_recipient, claimableColl);
     }
 
     function getCollateral(
diff --git a/solidity/contracts/DefaultPool.sol b/solidity/contracts/DefaultPool.sol
index 9701a03..421ee25 100644
--- a/solidity/contracts/DefaultPool.sol
+++ b/solidity/contracts/DefaultPool.sol
@@ -2,8 +2,9 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
 import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./dependencies/SendCollateral.sol";
 import "./interfaces/IActivePool.sol";
@@ -16,16 +17,27 @@ import "./interfaces/IDefaultPool.sol";
  * When a trove makes an operation that applies its pending collateral and debt, its pending collateral and debt is moved
  * from the Default Pool to the Active Pool.
  */
-contract DefaultPool is Ownable, CheckContract, SendCollateral, IDefaultPool {
+contract DefaultPool is
+    CheckContract,
+    IDefaultPool,
+    OwnableUpgradeable,
+    SendCollateral
+{
     address public activePoolAddress;
     address public troveManagerAddress;
 
     uint256 internal collateral; // deposited collateral tracker
     uint256 internal principal;
     uint256 internal interest;
-    uint256 internal lastInterestUpdatedTime;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // solhint-disable no-complex-fallback
     receive() external payable {
@@ -61,8 +73,6 @@ contract DefaultPool is Ownable, CheckContract, SendCollateral, IDefaultPool {
         _requireCallerIsTroveManager();
         principal += _principal;
         interest += _interest;
-        // solhint-disable-next-line not-rely-on-time
-        lastInterestUpdatedTime = block.timestamp;
         emit DefaultPoolDebtUpdated(principal, interest);
     }
 
@@ -73,8 +83,6 @@ contract DefaultPool is Ownable, CheckContract, SendCollateral, IDefaultPool {
         _requireCallerIsTroveManager();
         principal -= _principal;
         interest -= _interest;
-        // solhint-disable-next-line not-rely-on-time
-        lastInterestUpdatedTime = block.timestamp;
         emit DefaultPoolDebtUpdated(principal, interest);
     }
 
@@ -104,15 +112,6 @@ contract DefaultPool is Ownable, CheckContract, SendCollateral, IDefaultPool {
         return interest;
     }
 
-    function getLastInterestUpdatedTime()
-        external
-        view
-        override
-        returns (uint)
-    {
-        return lastInterestUpdatedTime;
-    }
-
     function _requireCallerIsTroveManager() internal view {
         require(
             msg.sender == troveManagerAddress,
diff --git a/solidity/contracts/GasPool.sol b/solidity/contracts/GasPool.sol
index be06156..c23f65d 100644
--- a/solidity/contracts/GasPool.sol
+++ b/solidity/contracts/GasPool.sol
@@ -2,7 +2,8 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./interfaces/IGasPool.sol";
 import "./token/MUSD.sol";
@@ -17,11 +18,18 @@ import "./token/MUSD.sol";
  * 50 mUSD principal on the trove is cancelled.
  * See this issue for more context: https://github.com/liquity/dev/issues/186
  */
-contract GasPool is Ownable, CheckContract, IGasPool {
+contract GasPool is CheckContract, IGasPool, OwnableUpgradeable {
     address public troveManagerAddress;
     IMUSD public musdToken;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     function setAddresses(
         address _musdTokenAddress,
diff --git a/solidity/contracts/HintHelpers.sol b/solidity/contracts/HintHelpers.sol
index 46dc1b0..3bae4a7 100644
--- a/solidity/contracts/HintHelpers.sol
+++ b/solidity/contracts/HintHelpers.sol
@@ -2,37 +2,53 @@
 
 pragma solidity ^0.8.24;
 
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
+import "./dependencies/InterestRateMath.sol";
 import "./dependencies/LiquityBase.sol";
+import "./interfaces/IBorrowerOperations.sol";
 import "./interfaces/ISortedTroves.sol";
 import "./interfaces/ITroveManager.sol";
-import "@openzeppelin/contracts/access/Ownable.sol";
 
-contract HintHelpers is LiquityBase, Ownable, CheckContract {
+contract HintHelpers is CheckContract, LiquityBase, OwnableUpgradeable {
     string public constant NAME = "HintHelpers";
 
+    IBorrowerOperations public borrowerOperations;
     ISortedTroves public sortedTroves;
     ITroveManager public troveManager;
 
     // --- Events ---
 
+    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);
     event SortedTrovesAddressChanged(address _sortedTrovesAddress);
     event TroveManagerAddressChanged(address _troveManagerAddress);
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // --- Dependency setters ---
 
     function setAddresses(
+        address _borrowerOperationsAddress,
         address _sortedTrovesAddress,
         address _troveManagerAddress
     ) external onlyOwner {
+        checkContract(_borrowerOperationsAddress);
         checkContract(_sortedTrovesAddress);
         checkContract(_troveManagerAddress);
 
+        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
         sortedTroves = ISortedTroves(_sortedTrovesAddress);
         troveManager = ITroveManager(_troveManagerAddress);
 
+        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
         emit SortedTrovesAddressChanged(_sortedTrovesAddress);
         emit TroveManagerAddressChanged(_troveManagerAddress);
 
@@ -52,7 +68,7 @@ contract HintHelpers is LiquityBase, Ownable, CheckContract {
      *     or zero in case of no partial redemption.
      *  - `truncatedAmount` is the maximum amount that can be redeemed out of the the provided `_amount`. This can be lower than
      *    `_amount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the
-     *    minimum allowed value (i.e. MIN_NET_DEBT).
+     *    minimum allowed value (i.e. minNetDebt).
      *
      * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero
      * will leave it uncapped.
@@ -90,6 +106,8 @@ contract HintHelpers is LiquityBase, Ownable, CheckContract {
             _maxIterations = type(uint256).max;
         }
 
+        uint256 minNetDebt = borrowerOperations.minNetDebt();
+
         while (
             currentTroveuser != address(0) &&
             remainingMUSD > 0 &&
@@ -97,39 +115,44 @@ contract HintHelpers is LiquityBase, Ownable, CheckContract {
         ) {
             _maxIterations--;
 
-            (uint256 pendingPrincipal, uint256 pendingInterest) = troveManager
-                .getPendingDebt(currentTroveuser);
+            // slither-disable-start unused-return
+            (
+                uint256 coll,
+                uint256 principal,
+                uint256 interest,
+                ,
+                ,
+
+            ) = troveManager.getEntireDebtAndColl(currentTroveuser);
+            // slither-disable-end unused-return
 
-            uint256 netDebt = _getNetDebt(
-                troveManager.getTroveDebt(currentTroveuser)
-            ) +
-                pendingPrincipal +
-                pendingInterest;
+            uint256 netDebt = _getNetDebt(principal + interest);
 
             if (netDebt > remainingMUSD) {
-                if (netDebt > MIN_NET_DEBT) {
-                    uint256 maxRedeemableMUSD = LiquityMath._min(
-                        remainingMUSD,
-                        netDebt - MIN_NET_DEBT
-                    );
-
-                    uint256 collateral = troveManager.getTroveColl(
-                        currentTroveuser
-                    ) + troveManager.getPendingCollateral(currentTroveuser);
-
-                    uint256 newColl = collateral -
-                        ((maxRedeemableMUSD * DECIMAL_PRECISION) / _price);
-                    uint256 newDebt = netDebt - maxRedeemableMUSD;
-
-                    uint256 compositeDebt = _getCompositeDebt(newDebt);
-                    partialRedemptionHintNICR = LiquityMath._computeNominalCR(
-                        newColl,
-                        compositeDebt
-                    );
-
-                    remainingMUSD -= maxRedeemableMUSD;
+                if (netDebt <= minNetDebt) {
+                    break;
                 }
-                break;
+
+                uint256 maxRedeemableMUSD = LiquityMath._min(
+                    remainingMUSD,
+                    netDebt - minNetDebt
+                );
+
+                coll -= ((maxRedeemableMUSD * DECIMAL_PRECISION) / _price);
+
+                // slither-disable-start unused-return
+                (uint256 principalAdjustment, ) = InterestRateMath
+                    .calculateDebtAdjustment(interest, maxRedeemableMUSD);
+                // slither-disable-end unused-return
+
+                principal -= principalAdjustment;
+
+                partialRedemptionHintNICR = LiquityMath._computeNominalCR(
+                    coll,
+                    principal
+                );
+
+                remainingMUSD -= maxRedeemableMUSD;
             } else {
                 remainingMUSD -= netDebt;
             }
diff --git a/solidity/contracts/InterestRateManager.sol b/solidity/contracts/InterestRateManager.sol
index 338bdcc..08b1553 100644
--- a/solidity/contracts/InterestRateManager.sol
+++ b/solidity/contracts/InterestRateManager.sol
@@ -2,7 +2,9 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
+import "./dependencies/InterestRateMath.sol";
 import "./token/IMUSD.sol";
 import {CheckContract} from "./dependencies/CheckContract.sol";
 import {IActivePool} from "./interfaces/IActivePool.sol";
@@ -10,23 +12,46 @@ import {IInterestRateManager} from "./interfaces/IInterestRateManager.sol";
 import {IPCV} from "./interfaces/IPCV.sol";
 import {ITroveManager} from "./interfaces/ITroveManager.sol";
 
-contract InterestRateManager is Ownable, CheckContract, IInterestRateManager {
+contract InterestRateManager is
+    CheckContract,
+    IInterestRateManager,
+    OwnableUpgradeable
+{
     // Current interest rate per year in basis points
     uint16 public interestRate;
 
-    // Maximum interest rate that can be set, defaults to 100% (10000 bps)
-    uint16 public maxInterestRate = 10000;
-
     // Proposed interest rate -- must be approved by governance after a minimum delay
     uint16 public proposedInterestRate;
     uint256 public proposalTime;
 
     // Minimum time delay between interest rate proposal and approval
     uint256 public constant MIN_DELAY = 7 days;
-    uint256 public constant SECONDS_IN_A_YEAR = 365 * 24 * 60 * 60;
 
-    // Mapping from interest rate to total principal and interest owed at that rate
-    mapping(uint16 => InterestRateInfo) public interestRateData;
+    // Maximum interest rate that can be set. Set to 100% (10000 bps)
+    uint16 public constant MAX_INTEREST_RATE = 10_000;
+
+    // In order to calculate interest on a trove, we calculate:
+    //
+    // (now - lastUpdatedTime) * principal * interestRate / (10000 * secondsInAYear)
+    //
+    // To calculate the interest on two troves (A and B)) with two different
+    // interest rates is then:
+    //
+    // (now - lastUpdatedTimeA) * principalA * interestRateA / (10000 * secondsInAYear) +
+    // (now - lastUpdatedTimeB) * principalB * interestRateB / (10000 * secondsInAYear)
+    //
+    // To simplify this and make it so that we do not need to loop over a list
+    // of troves, we track the sum of principal * interestRate as the variable
+    // `interestNumerator`.
+    //
+    // This lets us calculate interest as:
+    //
+    // (now - lastUpdatedTime) * interestNumerator / (10000 * secondsInAYear)
+    //
+    // Each time the principal change or we accrue interest, we update the
+    // `lastUpdatedTime` and the `interestNumerator` accordingly.
+    uint256 public interestNumerator;
+    uint256 public lastUpdatedTime;
 
     IActivePool public activePool;
     address public borrowerOperationsAddress;
@@ -59,7 +84,14 @@ contract InterestRateManager is Ownable, CheckContract, IInterestRateManager {
         _;
     }
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     function setAddresses(
         address _activePoolAddress,
@@ -93,7 +125,7 @@ contract InterestRateManager is Ownable, CheckContract, IInterestRateManager {
         uint16 _newProposedInterestRate
     ) external onlyGovernance {
         require(
-            _newProposedInterestRate <= maxInterestRate,
+            _newProposedInterestRate <= MAX_INTEREST_RATE,
             "Interest rate exceeds the maximum interest rate"
         );
         proposedInterestRate = _newProposedInterestRate;
@@ -112,36 +144,30 @@ contract InterestRateManager is Ownable, CheckContract, IInterestRateManager {
         _setInterestRate(proposedInterestRate);
     }
 
-    function setMaxInterestRate(
-        uint16 _newMaxInterestRate
-    ) external onlyGovernance {
-        maxInterestRate = _newMaxInterestRate;
-        emit MaxInterestRateUpdated(_newMaxInterestRate);
-    }
-
-    function addPrincipalToRate(
-        uint16 _rate,
-        uint256 _principal
+    function addPrincipal(
+        uint256 _principal,
+        uint16 _rate
     ) external onlyBorrowerOperationsOrTroveManager {
-        interestRateData[_rate].principal += _principal;
+        interestNumerator += _principal * _rate;
+        emit InterestNumeratorChanged(interestNumerator);
     }
 
-    function updateSystemInterest(uint16 _rate) external {
-        InterestRateInfo memory _interestRateData = interestRateData[_rate];
+    function updateSystemInterest() external {
+        uint256 updatedTimeSnapshot = lastUpdatedTime;
+        lastUpdatedTime = block.timestamp;
+
+        if (interestNumerator == 0) {
+            return;
+        }
+
         // solhint-disable not-rely-on-time
-        uint256 interest = calculateInterestOwed(
-            _interestRateData.principal,
-            _rate,
-            _interestRateData.lastUpdatedTime,
+        uint256 interest = InterestRateMath.calculateAggregatedInterestOwed(
+            interestNumerator,
+            updatedTimeSnapshot,
             block.timestamp
         );
         // solhint-enable not-rely-on-time
 
-        addInterestToRate(_rate, interest);
-
-        // solhint-disable-next-line not-rely-on-time
-        interestRateData[_rate].lastUpdatedTime = block.timestamp;
-
         // slither-disable-next-line calls-loop
         musdToken.mint(address(pcv), interest);
 
@@ -158,82 +184,35 @@ contract InterestRateManager is Ownable, CheckContract, IInterestRateManager {
         onlyTroveManager
         returns (uint256 principalAdjustment, uint256 interestAdjustment)
     {
-        if (_payment >= _interestOwed) {
-            principalAdjustment = _payment - _interestOwed;
-            interestAdjustment = _interestOwed;
-        } else {
-            principalAdjustment = 0;
-            interestAdjustment = _payment;
-        }
+        (principalAdjustment, interestAdjustment) = InterestRateMath
+            .calculateDebtAdjustment(_interestOwed, _payment);
 
-        removeInterestFromRate(_rate, interestAdjustment);
-        removePrincipalFromRate(_rate, principalAdjustment);
+        removePrincipal(principalAdjustment, _rate);
     }
 
-    function getInterestRateData(
+    function removePrincipal(
+        uint256 _principal,
         uint16 _rate
-    ) external view returns (InterestRateInfo memory) {
-        return interestRateData[_rate];
-    }
-
-    function addInterestToRate(
-        uint16 _rate,
-        uint256 _interest
     ) public onlyBorrowerOperationsOrTroveManager {
-        interestRateData[_rate].interest += _interest;
+        interestNumerator -= _principal * _rate;
+        emit InterestNumeratorChanged(interestNumerator);
     }
 
-    function removePrincipalFromRate(
-        uint16 _rate,
-        uint256 _principal
-    ) public onlyBorrowerOperationsOrTroveManager {
-        interestRateData[_rate].principal -= _principal;
-    }
-
-    function removeInterestFromRate(
-        uint16 _rate,
-        uint256 _interest
-    ) public onlyBorrowerOperationsOrTroveManager {
-        interestRateData[_rate].interest -= _interest;
-    }
-
-    function calculateInterestOwed(
-        uint256 _principal,
-        uint16 _interestRate,
-        uint256 startTime,
-        uint256 endTime
-    ) public pure returns (uint256) {
-        uint256 timeElapsed = endTime - startTime;
+    function getAccruedInterest() public view returns (uint256) {
+        //solhint-disable not-rely-on-time
         return
-            (_principal * _interestRate * timeElapsed) /
-            (10000 * SECONDS_IN_A_YEAR);
-    }
-
-    function calculateDebtAdjustment(
-        uint256 _interestOwed,
-        uint256 _payment
-    )
-        public
-        pure
-        returns (uint256 principalAdjustment, uint256 interestAdjustment)
-    {
-        if (_payment >= _interestOwed) {
-            principalAdjustment = _payment - _interestOwed;
-            interestAdjustment = _interestOwed;
-        } else {
-            principalAdjustment = 0;
-            interestAdjustment = _payment;
-        }
+            InterestRateMath.calculateAggregatedInterestOwed(
+                interestNumerator,
+                lastUpdatedTime,
+                block.timestamp
+            );
+        //solhint-enable not-rely-on-time
     }
 
     // slither-disable-start reentrancy-benign
     // slither-disable-start reentrancy-events
     function _setInterestRate(uint16 _newInterestRate) internal {
-        require(
-            _newInterestRate <= maxInterestRate,
-            "Interest rate exceeds the maximum interest rate"
-        );
-        troveManager.updateDefaultPoolInterest();
+        troveManager.updateSystemInterest();
         interestRate = _newInterestRate;
         emit InterestRateUpdated(_newInterestRate);
     }
diff --git a/solidity/contracts/PCV.sol b/solidity/contracts/PCV.sol
index 5971bd4..c76bde8 100644
--- a/solidity/contracts/PCV.sol
+++ b/solidity/contracts/PCV.sol
@@ -2,18 +2,19 @@
 
 pragma solidity ^0.8.24;
 
+import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
+import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+
 import "./BorrowerOperations.sol";
 import "./dependencies/CheckContract.sol";
 import "./dependencies/SendCollateral.sol";
 import "./interfaces/IPCV.sol";
 import "./token/IMUSD.sol";
-import "@openzeppelin/contracts/access/Ownable.sol";
-import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
-contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
+contract PCV is CheckContract, IPCV, Ownable2StepUpgradeable, SendCollateral {
     uint256 public constant BOOTSTRAP_LOAN = 1e26; // 100M mUSD
 
-    uint256 public immutable governanceTimeDelay;
+    uint256 public governanceTimeDelay;
 
     BorrowerOperations public borrowerOperations;
     IMUSD public musd;
@@ -58,53 +59,23 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
         _;
     }
 
-    constructor(uint256 _governanceTimeDelay) Ownable(msg.sender) {
-        governanceTimeDelay = _governanceTimeDelay;
-        require(governanceTimeDelay <= 30 weeks, "Governance delay is too big");
-    }
-
-    receive() external payable {}
+    function initialize(uint256 _governanceTimeDelay) external initializer {
+        __Ownable_init(msg.sender);
 
-    function payDebt(
-        uint256 _musdToBurn
-    ) external override onlyOwnerOrCouncilOrTreasury {
         require(
-            debtToPay > 0 || feeRecipient != address(0),
-            "PCV: debt has already paid"
+            _governanceTimeDelay <= 30 weeks,
+            "Governance delay is too big"
         );
-        require(
-            _musdToBurn <= musd.balanceOf(address(this)),
-            "PCV: not enough tokens"
-        );
-
-        // if the debt has already been paid, the feeRecipient should receive all fees
-        if (debtToPay == 0) {
-            feeSplitPercentage = 100;
-        }
-
-        uint256 feeToRecipient = (_musdToBurn * feeSplitPercentage) / 100;
-        uint256 feeToDebt = _musdToBurn - feeToRecipient;
-
-        if (feeToDebt > debtToPay) {
-            feeToRecipient += feeToDebt - debtToPay;
-            feeToDebt = debtToPay;
-        }
-
-        debtToPay -= feeToDebt;
-
-        if (feeRecipient != address(0) && feeSplitPercentage > 0) {
-            require(
-                musd.transfer(feeRecipient, feeToRecipient),
-                "PCV: sending mUSD failed"
-            );
-        }
-        borrowerOperations.burnDebtFromPCV(feeToDebt);
+        governanceTimeDelay = _governanceTimeDelay;
+    }
 
-        // slither-disable-next-line reentrancy-events
-        emit PCVDebtPaid(feeToDebt);
-        emit PCVFeePaid(feeRecipient, feeToRecipient);
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
     }
 
+    receive() external payable {}
+
     function setAddresses(
         address _borrowerOperations,
         address _musdTokenAddress
@@ -123,7 +94,7 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
         emit MUSDTokenAddressSet(_musdTokenAddress);
     }
 
-    function initialize() external override onlyOwnerOrCouncilOrTreasury {
+    function initializeDebt() external override onlyOwnerOrCouncilOrTreasury {
         require(!isInitialized, "PCV: already initialized");
 
         debtToPay = BOOTSTRAP_LOAN;
@@ -140,20 +111,60 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
             "PCV: Fee recipient cannot be the zero address."
         );
         feeRecipient = _feeRecipient;
+        emit FeeRecipientSet(_feeRecipient);
     }
 
     function setFeeSplit(
         uint8 _feeSplitPercentage
     ) external onlyOwnerOrCouncilOrTreasury {
         require(
-            debtToPay > 0,
-            "PCV: Must have debt in order to set a fee split."
+            feeRecipient != address(0),
+            "PCV must set fee recipient before setFeeSplit"
         );
         require(
-            _feeSplitPercentage <= FEE_SPLIT_MAX,
+            (debtToPay > 0 && _feeSplitPercentage <= FEE_SPLIT_MAX) ||
+                (debtToPay == 0 && _feeSplitPercentage <= 100),
             "PCV: Fee split must be at most 50 while debt remains."
         );
         feeSplitPercentage = _feeSplitPercentage;
+
+        emit FeeSplitSet(_feeSplitPercentage);
+    }
+
+    function distributeMUSD(
+        uint256 _amount
+    ) external override onlyOwnerOrCouncilOrTreasury {
+        require(
+            _amount <= musd.balanceOf(address(this)),
+            "PCV: not enough tokens"
+        );
+
+        uint256 distributedFees = (_amount * feeSplitPercentage) / 100;
+        uint256 protocolLoanRepayment = _amount - distributedFees;
+        uint256 stabilityPoolDeposit = 0;
+
+        // check for excess to deposit into the stability pool
+        if (protocolLoanRepayment > debtToPay) {
+            stabilityPoolDeposit = protocolLoanRepayment - debtToPay;
+            protocolLoanRepayment = debtToPay;
+        }
+
+        _repayDebt(protocolLoanRepayment);
+
+        if (stabilityPoolDeposit > 0) {
+            depositToStabilityPool(stabilityPoolDeposit);
+        }
+
+        // send funds to feeRecipient address, if the feeRecipient hasnt been set then the feeSplitPercentage = 0
+        if (feeRecipient != address(0) && distributedFees > 0) {
+            require(
+                musd.transfer(feeRecipient, distributedFees),
+                "PCV: sending mUSD failed"
+            );
+
+            // slither-disable-next-line reentrancy-events
+            emit PCVDistribution(feeRecipient, distributedFees);
+        }
     }
 
     function withdrawMUSD(
@@ -162,8 +173,8 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
     )
         external
         override
-        onlyAfterDebtPaid
         onlyOwnerOrCouncilOrTreasury
+        onlyAfterDebtPaid
         onlyWhitelistedRecipient(_recipient)
     {
         require(
@@ -171,6 +182,7 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
             "PCV: not enough tokens"
         );
         require(musd.transfer(_recipient, _amount), "PCV: sending mUSD failed");
+
         // slither-disable-next-line reentrancy-events
         emit MUSDWithdraw(_recipient, _amount);
     }
@@ -181,12 +193,13 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
     )
         external
         override
-        onlyAfterDebtPaid
         onlyOwnerOrCouncilOrTreasury
         onlyWhitelistedRecipient(_recipient)
     {
-        emit CollateralWithdraw(_recipient, _collateralAmount);
         _sendCollateral(_recipient, _collateralAmount);
+
+        // slither-disable-next-line reentrancy-events
+        emit CollateralWithdraw(_recipient, _collateralAmount);
     }
 
     function addRecipientsToWhitelist(
@@ -290,10 +303,44 @@ contract PCV is IPCV, Ownable, CheckContract, SendCollateral {
             musd.approve(borrowerOperations.stabilityPoolAddress(), _amount),
             "PCV: Approval failed"
         );
+
         IStabilityPool(borrowerOperations.stabilityPoolAddress()).provideToSP(
             _amount
         );
 
-        // TODO Emit event
+        // slither-disable-next-line reentrancy-events
+        emit PCVDepositSP(msg.sender, _amount);
+    }
+
+    function withdrawFromStabilityPool(
+        uint256 _amount
+    ) public onlyOwnerOrCouncilOrTreasury {
+        uint256 collateralBefore = address(this).balance;
+        uint256 musdBefore = musd.balanceOf(address(this));
+
+        IStabilityPool(borrowerOperations.stabilityPoolAddress())
+            .withdrawFromSP(_amount);
+
+        uint256 collateralChange = address(this).balance - collateralBefore;
+        uint256 musdChange = musd.balanceOf(address(this)) - musdBefore;
+
+        _repayDebt(musdChange);
+
+        // slither-disable-next-line reentrancy-events
+        emit PCVWithdrawSP(msg.sender, musdChange, collateralChange);
+    }
+
+    function _repayDebt(uint _repayment) internal {
+        if (_repayment > debtToPay) {
+            _repayment = debtToPay;
+        }
+
+        if (_repayment > 0 && debtToPay > 0) {
+            debtToPay -= _repayment;
+            borrowerOperations.burnDebtFromPCV(_repayment);
+
+            // slither-disable-next-line reentrancy-events
+            emit PCVDebtPayment(_repayment);
+        }
     }
 }
diff --git a/solidity/contracts/PriceFeed.sol b/solidity/contracts/PriceFeed.sol
index 049c913..ddea3ec 100644
--- a/solidity/contracts/PriceFeed.sol
+++ b/solidity/contracts/PriceFeed.sol
@@ -2,19 +2,28 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
 
 import "./interfaces/ChainlinkAggregatorV3Interface.sol";
 import "./interfaces/IPriceFeed.sol";
 
-contract PriceFeed is IPriceFeed, Ownable {
+contract PriceFeed is IPriceFeed, Ownable2StepUpgradeable {
     /// @dev Used to convert an oracle price answer to an 18-digit precision uint
     uint8 public constant TARGET_DIGITS = 18;
+    // If the oracle has not been updated in at least 60 seconds, it is stale.
+    uint256 private constant MAX_PRICE_DELAY = 60;
 
     // State ------------------------------------------------------------------------------------------------------------
     ChainlinkAggregatorV3Interface public oracle;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // Admin routines ---------------------------------------------------------------------------------------------------
 
@@ -36,7 +45,15 @@ contract PriceFeed is IPriceFeed, Ownable {
 
     function fetchPrice() public view virtual returns (uint256) {
         // slither-disable-next-line unused-return
-        (, int256 price, , , ) = oracle.latestRoundData();
+        (, int256 price, , uint256 updatedAt, ) = oracle.latestRoundData();
+
+        // solhint-disable not-rely-on-time
+        require(
+            block.timestamp - updatedAt <= MAX_PRICE_DELAY,
+            "PriceFeed: Oracle is stale."
+        );
+        // solhint-enable not-rely-on-time
+
         return _scalePriceByDigits(uint256(price), oracle.decimals());
     }
 
diff --git a/solidity/contracts/SortedTroves.sol b/solidity/contracts/SortedTroves.sol
index 713eafd..505d982 100644
--- a/solidity/contracts/SortedTroves.sol
+++ b/solidity/contracts/SortedTroves.sol
@@ -2,7 +2,8 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./interfaces/ISortedTroves.sol";
 import "./interfaces/ITroveManager.sol";
@@ -40,7 +41,7 @@ import "./interfaces/ITroveManager.sol";
  *
  * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access
  */
-contract SortedTroves is Ownable, CheckContract, ISortedTroves {
+contract SortedTroves is CheckContract, ISortedTroves, OwnableUpgradeable {
     // Information for a node in the list
     struct Node {
         bool exists;
@@ -63,7 +64,14 @@ contract SortedTroves is Ownable, CheckContract, ISortedTroves {
 
     event TroveManagerAddressChanged(address _troveManagerAddress);
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // --- Dependency setters ---
 
diff --git a/solidity/contracts/StabilityPool.sol b/solidity/contracts/StabilityPool.sol
index 13fc0de..389b8eb 100644
--- a/solidity/contracts/StabilityPool.sol
+++ b/solidity/contracts/StabilityPool.sol
@@ -6,7 +6,8 @@
 
 pragma solidity ^0.8.24;
 
-import "@openzeppelin/contracts/access/Ownable.sol";
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
 import "./dependencies/LiquityBase.sol";
 import "./dependencies/SendCollateral.sol";
@@ -17,11 +18,11 @@ import "./interfaces/IStabilityPool.sol";
 import "./interfaces/ITroveManager.sol";
 
 contract StabilityPool is
-    LiquityBase,
-    Ownable,
     CheckContract,
-    SendCollateral,
-    IStabilityPool
+    IStabilityPool,
+    LiquityBase,
+    OwnableUpgradeable,
+    SendCollateral
 {
     // --- Type Declarations ---
     struct Snapshots {
@@ -55,7 +56,7 @@ contract StabilityPool is
      * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
      * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
      */
-    uint256 public P = DECIMAL_PRECISION;
+    uint256 public P;
 
     // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
     uint128 public currentScale;
@@ -79,7 +80,16 @@ contract StabilityPool is
 
     // --- Functions --
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+
+        P = DECIMAL_PRECISION;
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     // solhint-disable no-complex-fallback
     receive() external payable {
@@ -231,7 +241,7 @@ contract StabilityPool is
 
         borrowerOperations.moveCollateralGainToTrove{
             value: depositorCollateralGain
-        }(msg.sender, 0, _upperHint, _lowerHint);
+        }(msg.sender, _upperHint, _lowerHint);
     }
 
     /*
@@ -240,26 +250,32 @@ contract StabilityPool is
      * Only called by liquidation functions in the TroveManager.
      */
     function offset(
-        uint256 _debtToOffset,
+        uint256 _principalToOffset,
+        uint256 _interestToOffset,
         uint256 _collToAdd
     ) external override {
         _requireCallerIsTroveManager();
         uint256 totalMUSD = totalMUSDDeposits; // cached to save an SLOAD
-        if (totalMUSD == 0 || _debtToOffset == 0) {
+        uint256 debtToOffset = _principalToOffset + _interestToOffset;
+        if (totalMUSD == 0 || debtToOffset == 0) {
             return;
         }
 
         (
             uint256 collateralGainPerUnitStaked,
             uint256 mUSDLossPerUnitStaked
-        ) = _computeRewardsPerUnitStaked(_collToAdd, _debtToOffset, totalMUSD);
+        ) = _computeRewardsPerUnitStaked(_collToAdd, debtToOffset, totalMUSD);
 
         _updateRewardSumAndProduct(
             collateralGainPerUnitStaked,
             mUSDLossPerUnitStaked
         ); // updates S and P
 
-        _moveOffsetCollAndDebt(_collToAdd, _debtToOffset);
+        _moveOffsetCollAndDebt(
+            _collToAdd,
+            _principalToOffset,
+            _interestToOffset
+        );
     }
 
     // --- Getters for public variables. Required by IPool interface ---
@@ -451,16 +467,18 @@ contract StabilityPool is
 
     function _moveOffsetCollAndDebt(
         uint256 _collToAdd,
-        uint256 _debtToOffset
+        uint256 _principalToOffset,
+        uint256 _interestToOffset
     ) internal {
         IActivePool activePoolCached = activePool;
 
+        uint256 debtToOffset = _principalToOffset + _interestToOffset;
         // Cancel the liquidated debt with the mUSD in the stability pool
-        activePoolCached.decreaseDebt(_debtToOffset, 0);
-        _decreaseMUSD(_debtToOffset);
+        activePoolCached.decreaseDebt(_principalToOffset, _interestToOffset);
+        _decreaseMUSD(debtToOffset);
 
         // Burn the debt that was successfully offset
-        musd.burn(address(this), _debtToOffset);
+        musd.burn(address(this), debtToOffset);
 
         activePoolCached.sendCollateral(address(this), _collToAdd);
     }
@@ -507,25 +525,35 @@ contract StabilityPool is
         epochToScaleToSum[currentEpochCached][currentScaleCached] = newS;
         emit SUpdated(newS, currentEpochCached, currentScaleCached);
 
-        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
+        uint256 PBeforeScaleChanges = (currentP * newProductFactor) /
+            DECIMAL_PRECISION;
+
         if (newProductFactor == 0) {
+            // If the Stability Pool was emptied, increment the epoch, and reset
+            // the scale and product P
             currentEpoch = currentEpochCached + 1;
             emit EpochUpdated(currentEpoch);
             currentScale = 0;
             emit ScaleUpdated(currentScale);
             newP = DECIMAL_PRECISION;
-
-            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
-        } else if (
-            (currentP * newProductFactor) / DECIMAL_PRECISION < SCALE_FACTOR
-        ) {
+        } else if (PBeforeScaleChanges == 1) {
+            // If multiplying P by the product factor results in exactly one, we
+            // need to increment the scale twice.
+            newP =
+                (currentP * newProductFactor * SCALE_FACTOR * SCALE_FACTOR) /
+                DECIMAL_PRECISION;
+            currentScale = currentScaleCached + 2;
+            emit ScaleUpdated(currentScale);
+        } else if (PBeforeScaleChanges < SCALE_FACTOR) {
+            // If multiplying P by a non-zero product factor would reduce P below
+            // the scale boundary, increment the scale
             newP =
                 (currentP * newProductFactor * SCALE_FACTOR) /
                 DECIMAL_PRECISION;
             currentScale = currentScaleCached + 1;
             emit ScaleUpdated(currentScale);
         } else {
-            newP = (currentP * newProductFactor) / DECIMAL_PRECISION;
+            newP = PBeforeScaleChanges;
         }
 
         assert(newP > 0);
diff --git a/solidity/contracts/TroveManager.sol b/solidity/contracts/TroveManager.sol
index 5071973..8866d94 100644
--- a/solidity/contracts/TroveManager.sol
+++ b/solidity/contracts/TroveManager.sol
@@ -6,8 +6,12 @@
 
 pragma solidity ^0.8.24;
 
+import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
+
 import "./dependencies/CheckContract.sol";
+import "./dependencies/InterestRateMath.sol";
 import "./dependencies/LiquityBase.sol";
+import "./interfaces/IBorrowerOperations.sol";
 import "./interfaces/ICollSurplusPool.sol";
 import "./interfaces/IGasPool.sol";
 import "./interfaces/IInterestRateManager.sol";
@@ -16,13 +20,16 @@ import "./interfaces/ISortedTroves.sol";
 import "./interfaces/IStabilityPool.sol";
 import "./interfaces/ITroveManager.sol";
 import "./token/IMUSD.sol";
-import "@openzeppelin/contracts/access/Ownable.sol";
 
-contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
+contract TroveManager is
+    CheckContract,
+    ITroveManager,
+    LiquityBase,
+    OwnableUpgradeable
+{
     enum TroveManagerOperation {
         applyPendingRewards,
-        liquidateInNormalMode,
-        liquidateInRecoveryMode,
+        liquidate,
         redeemCollateral
     }
 
@@ -49,15 +56,17 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     struct LocalVariables_OuterLiquidationFunction {
         uint256 price;
         uint256 mUSDInStabPool;
-        bool recoveryModeAtStart;
         uint256 liquidatedColl;
     }
 
     struct LocalVariables_redeemCollateralFromTrove {
         uint256 newDebt;
         uint256 newColl;
+        uint256 newPrincipal;
+        uint256 interestPayment;
         uint256 upperBoundNICR;
         uint256 newNICR;
+        uint256 mUSDLot;
     }
 
     struct LocalVariables_InnerSingleLiquidateFunction {
@@ -73,7 +82,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         uint256 totalInterestInSequence;
         uint256 totalCollGasCompensation;
         uint256 totalMUSDGasCompensation;
-        uint256 totalDebtToOffset;
+        uint256 totalPrincipalToOffset;
+        uint256 totalInterestToOffset;
         uint256 totalCollToSendToSP;
         uint256 totalPrincipalToRedistribute;
         uint256 totalInterestToRedistribute;
@@ -86,18 +96,23 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         uint256 i;
         uint256 ICR;
         address user;
-        bool backToNormalMode;
         uint256 entireSystemDebt;
         uint256 entireSystemColl;
     }
 
+    struct LocalVariables_redeemCollateral {
+        uint256 minNetDebt;
+        uint16 interestRate;
+    }
+
     struct LiquidationValues {
         uint256 entireTrovePrincipal;
         uint256 entireTroveInterest;
         uint256 entireTroveColl;
         uint256 collGasCompensation;
         uint256 mUSDGasCompensation;
-        uint256 debtToOffset;
+        uint256 principalToOffset;
+        uint256 interestToOffset;
         uint256 collToSendToSP;
         uint256 principalToRedistribute;
         uint256 interestToRedistribute;
@@ -116,25 +131,26 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     }
 
     struct SingleRedemptionValues {
-        uint256 mUSDLot;
+        uint256 principal;
+        uint256 interest;
         uint256 collateralLot;
         bool cancelledPartial;
     }
 
     struct RedemptionTotals {
         uint256 remainingMUSD;
-        uint256 totalMUSDToRedeem;
+        uint256 totalPrincipalToRedeem;
+        uint256 totalInterestToRedeem;
         uint256 totalCollateralDrawn;
         uint256 collateralFee;
         uint256 collateralToSendToRedeemer;
-        uint256 decayedBaseRate;
         uint256 price;
         uint256 totalDebtAtStart;
     }
 
     // --- Connected contract declarations ---
 
-    address public borrowerOperationsAddress;
+    IBorrowerOperations public borrowerOperations;
 
     IStabilityPool public override stabilityPool;
 
@@ -149,29 +165,10 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     // A doubly linked list of Troves, sorted by their sorted by their collateral ratios
     ISortedTroves public sortedTroves;
 
-    IInterestRateManager public interestRateManager;
-
     // --- Data structures ---
 
-    /*
-     * Half-life of 12h. 12h = 720 min
-     * (1/2) = d^720 => d = (1/2)^(1/720)
-     */
-    uint256 public constant MINUTE_DECAY_FACTOR = 999037758833783000;
     uint256 public constant REDEMPTION_FEE_FLOOR =
         (DECIMAL_PRECISION * 5) / 1000; // 0.5%
-    uint256 public constant MAX_BORROWING_FEE = (DECIMAL_PRECISION * 5) / 100; // 5%
-
-    /*
-     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction, in order to calc the new base rate from a redemption.
-     * Corresponds to (1 / ALPHA) in the white paper.
-     */
-    uint256 public constant BETA = 2;
-
-    uint256 public baseRate;
-
-    // The timestamp of the latest fee operation (redemption or new mUSD issuance)
-    uint256 public lastFeeOperationTime;
 
     mapping(address => Trove) public Troves;
 
@@ -212,7 +209,14 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     // Map addresses with active troves to their RewardSnapshot
     mapping(address => RewardSnapshot) public rewardSnapshots;
 
-    constructor() Ownable(msg.sender) {}
+    function initialize() external initializer {
+        __Ownable_init(msg.sender);
+    }
+
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
 
     function setAddresses(
         address _activePoolAddress,
@@ -240,7 +244,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         checkContract(_interestRateManagerAddress);
 
         // slither-disable-next-line missing-zero-check
-        borrowerOperationsAddress = _borrowerOperationsAddress;
+        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
         activePool = IActivePool(_activePoolAddress);
         defaultPool = IDefaultPool(_defaultPoolAddress);
         stabilityPool = IStabilityPool(_stabilityPoolAddress);
@@ -302,9 +306,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         address _upperPartialRedemptionHint,
         address _lowerPartialRedemptionHint,
         uint256 _partialRedemptionHintNICR,
-        uint256 _maxIterations,
-        uint256 _maxFeePercentage
+        uint256 _maxIterations
     ) external override {
+        updateSystemInterest();
         ContractsCache memory contractsCache = ContractsCache(
             activePool,
             defaultPool,
@@ -314,10 +318,11 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             collSurplusPool,
             gasPoolAddress
         );
-        // slither-disable-next-line uninitialized-local
+        // slither-disable-start uninitialized-local
         RedemptionTotals memory totals;
+        LocalVariables_redeemCollateral memory vars;
+        // slither-disable-end uninitialized-local
 
-        _requireValidMaxFeePercentage(_maxFeePercentage);
         totals.price = priceFeed.fetchPrice();
         _requireTCRoverMCR(totals.price);
         _requireAmountGreaterThanZero(_amount);
@@ -358,7 +363,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             _maxIterations = type(uint256).max;
         }
 
-        updateDefaultPoolInterest();
+        vars.minNetDebt = borrowerOperations.minNetDebt();
+        vars.interestRate = interestRateManager.interestRate();
 
         while (
             currentBorrower != address(0) &&
@@ -366,6 +372,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             _maxIterations > 0
         ) {
             _maxIterations--;
+            _updateTroveInterest(currentBorrower);
+
             // Save the address of the Trove preceding the current one, before potentially modifying the list
             // slither-disable-next-line calls-loop
             address nextUserToCheck = contractsCache.sortedTroves.getPrev(
@@ -386,15 +394,20 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
                     totals.price,
                     _upperPartialRedemptionHint,
                     _lowerPartialRedemptionHint,
-                    _partialRedemptionHintNICR
+                    _partialRedemptionHintNICR,
+                    vars
                 );
 
             if (singleRedemption.cancelledPartial) break; // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum), therefore we could not redeem from the last Trove
 
-            totals.totalMUSDToRedeem += singleRedemption.mUSDLot;
+            totals.totalPrincipalToRedeem += singleRedemption.principal;
+            totals.totalInterestToRedeem += singleRedemption.interest;
             totals.totalCollateralDrawn += singleRedemption.collateralLot;
 
-            totals.remainingMUSD -= singleRedemption.mUSDLot;
+            totals.remainingMUSD -=
+                singleRedemption.principal +
+                singleRedemption.interest;
+
             currentBorrower = nextUserToCheck;
         }
         require(
@@ -402,44 +415,37 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             "TroveManager: Unable to redeem any amount"
         );
 
-        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.
-        // Use the saved total mUSD supply value, from before it was reduced by the redemption.
-        _updateBaseRateFromRedemption(
-            totals.totalCollateralDrawn,
-            totals.price,
-            totals.totalDebtAtStart
-        );
-
         // Calculate the collateral fee
         totals.collateralFee = _getRedemptionFee(totals.totalCollateralDrawn);
 
-        _requireUserAcceptsFee(
-            totals.collateralFee,
-            totals.totalCollateralDrawn,
-            _maxFeePercentage
-        );
-
-        // Send the collateral fee to the PCV contract
-        contractsCache.activePool.sendCollateral(
-            address(contractsCache.pcv),
-            totals.collateralFee
-        );
-
         totals.collateralToSendToRedeemer =
             totals.totalCollateralDrawn -
             totals.collateralFee;
 
         emit Redemption(
             _amount,
-            totals.totalMUSDToRedeem,
+            totals.totalPrincipalToRedeem + totals.totalInterestToRedeem,
             totals.totalCollateralDrawn,
             totals.collateralFee
         );
 
         // Burn the total mUSD that is cancelled with debt, and send the redeemed collateral to msg.sender
-        contractsCache.musdToken.burn(msg.sender, totals.totalMUSDToRedeem);
+        contractsCache.musdToken.burn(
+            msg.sender,
+            totals.totalPrincipalToRedeem + totals.totalInterestToRedeem
+        );
+
+        // Send the collateral fee to the PCV contract
+        contractsCache.activePool.sendCollateral(
+            address(contractsCache.pcv),
+            totals.collateralFee
+        );
+
         // Update Active Pool mUSD, and send collateral to account
-        contractsCache.activePool.decreaseDebt(totals.totalMUSDToRedeem, 0);
+        contractsCache.activePool.decreaseDebt(
+            totals.totalPrincipalToRedeem,
+            totals.totalInterestToRedeem
+        );
         contractsCache.activePool.sendCollateral(
             msg.sender,
             totals.collateralToSendToRedeemer
@@ -471,7 +477,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     function applyPendingRewards(address _borrower) external override {
         _requireCallerIsBorrowerOperations();
 
-        updateDefaultPoolInterest();
         return _applyPendingRewards(activePool, defaultPool, _borrower);
     }
 
@@ -485,19 +490,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         return _removeStake(_borrower);
     }
 
-    // Updates the baseRate state variable based on time elapsed since the last redemption or borrowing operation.
-    function decayBaseRateFromBorrowing() external override {
-        _requireCallerIsBorrowerOperations();
-
-        uint256 decayedBaseRate = _calcDecayedBaseRate();
-        assert(decayedBaseRate <= DECIMAL_PRECISION); // The baseRate can decay to 0
-
-        baseRate = decayedBaseRate;
-        emit BaseRateUpdated(decayedBaseRate);
-
-        _updateLastFeeOpTime();
-    }
-
     // --- Trove property setters, called by BorrowerOperations ---
 
     function setTroveStatus(
@@ -541,10 +533,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         uint256 _debtIncrease
     ) external override returns (uint) {
         _requireCallerIsBorrowerOperations();
-        updateSystemAndTroveInterest(_borrower);
-        interestRateManager.addPrincipalToRate(
-            Troves[_borrower].interestRate,
-            _debtIncrease
+        interestRateManager.addPrincipal(
+            _debtIncrease,
+            Troves[_borrower].interestRate
         );
         uint256 newDebt = Troves[_borrower].principal + _debtIncrease;
         Troves[_borrower].principal = newDebt;
@@ -586,37 +577,14 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     function getNominalICR(
         address _borrower
     ) external view override returns (uint) {
-        (
-            uint256 currentCollateral,
-            uint256 currentDebt
-        ) = _getCurrentTroveAmounts(_borrower);
-
-        uint256 NICR = LiquityMath._computeNominalCR(
-            currentCollateral,
-            currentDebt
-        );
-        return NICR;
-    }
-
-    function getRedemptionFeeWithDecay(
-        uint256 _collateralDrawn
-    ) external view override returns (uint) {
-        return
-            _calcRedemptionFee(getRedemptionRateWithDecay(), _collateralDrawn);
-    }
+        (uint256 pendingPrincipal, ) = getPendingDebt(_borrower);
 
-    // --- Borrowing fee functions ---
+        uint256 collateral = Troves[_borrower].coll +
+            getPendingCollateral(_borrower);
 
-    function getBorrowingFee(
-        uint256 _debt
-    ) external view override returns (uint) {
-        return _calcBorrowingFee(getBorrowingRate(), _debt);
-    }
+        uint256 principal = Troves[_borrower].principal + pendingPrincipal;
 
-    function getBorrowingFeeWithDecay(
-        uint256 _debt
-    ) external view override returns (uint) {
-        return _calcBorrowingFee(getBorrowingRateWithDecay(), _debt);
+        return LiquityMath._computeNominalCR(collateral, principal);
     }
 
     function getTroveStatus(
@@ -681,51 +649,20 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         return _checkRecoveryMode(_price);
     }
 
-    function updateDefaultPoolInterest() public {
-        if (totalStakes > 0) {
-            // solhint-disable not-rely-on-time
-            uint256 interest = interestRateManager.calculateInterestOwed(
-                defaultPool.getPrincipal(),
-                interestRateManager.interestRate(),
-                defaultPool.getLastInterestUpdatedTime(),
-                block.timestamp
-            );
-            // solhint-enable not-rely-on-time
-
-            // slither-disable-start divide-before-multiply
-            uint256 interestNumerator = interest *
-                DECIMAL_PRECISION +
-                lastInterestError_Redistribution;
-
-            uint256 pendingInterestPerUnitStaked = interestNumerator /
-                totalStakes;
-
-            lastInterestError_Redistribution =
-                interestNumerator -
-                (pendingInterestPerUnitStaked * totalStakes);
-            // slither-disable-end divide-before-multiply
-
-            L_Interest += pendingInterestPerUnitStaked;
-
-            defaultPool.increaseDebt(0, interest);
-            emit LTermsUpdated(L_Collateral, L_Principal, L_Interest);
-        }
+    function getBorrowingFee(
+        uint256 _debt
+    ) external pure override returns (uint) {
+        return (_debt * BORROWING_FEE_FLOOR) / DECIMAL_PRECISION;
     }
 
     function updateSystemAndTroveInterest(address _borrower) public {
-        Trove storage trove = Troves[_borrower];
-        // slither-disable-start calls-loop
-        interestRateManager.updateSystemInterest(trove.interestRate);
-        // solhint-disable not-rely-on-time
-        trove.interestOwed += interestRateManager.calculateInterestOwed(
-            trove.principal,
-            trove.interestRate,
-            trove.lastInterestUpdateTime,
-            block.timestamp
-        );
-        trove.lastInterestUpdateTime = block.timestamp;
-        // slither-disable-end calls-loop
-        // solhint-enable not-rely-on-time
+        updateSystemInterest();
+        _updateTroveInterest(_borrower);
+    }
+
+    function updateSystemInterest() public {
+        // slither-disable-next-line calls-loop
+        interestRateManager.updateSystemInterest();
     }
 
     /*
@@ -739,9 +676,12 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             "TroveManager: Calldata address array must not be empty"
         );
 
+        updateSystemInterest();
+
         for (uint i = 0; i < _troveArray.length; i++) {
             address borrower = _troveArray[i];
-            updateSystemAndTroveInterest(borrower);
+
+            _updateTroveInterest(borrower);
         }
 
         IActivePool activePoolCached = activePool;
@@ -755,29 +695,14 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
         vars.price = priceFeed.fetchPrice();
         vars.mUSDInStabPool = stabilityPoolCached.getTotalMUSDDeposits();
-        vars.recoveryModeAtStart = _checkRecoveryMode(vars.price);
-
-        updateDefaultPoolInterest();
-
-        // Perform the appropriate liquidation sequence - tally values and obtain their totals.
-        if (vars.recoveryModeAtStart) {
-            totals = _getTotalFromBatchLiquidateRecoveryMode(
-                activePoolCached,
-                defaultPoolCached,
-                vars.price,
-                vars.mUSDInStabPool,
-                _troveArray
-            );
-        } else {
-            //  if !vars.recoveryModeAtStart
-            totals = _getTotalsFromBatchLiquidateNormalMode(
-                activePoolCached,
-                defaultPoolCached,
-                vars.price,
-                vars.mUSDInStabPool,
-                _troveArray
-            );
-        }
+
+        totals = _getTotalsFromBatchLiquidate(
+            activePoolCached,
+            defaultPoolCached,
+            vars.price,
+            vars.mUSDInStabPool,
+            _troveArray
+        );
 
         require(
             totals.totalPrincipalInSequence > 0,
@@ -786,7 +711,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
         // Move liquidated collateral and debt to the appropriate pools
         stabilityPoolCached.offset(
-            totals.totalDebtToOffset,
+            totals.totalPrincipalToOffset,
+            totals.totalInterestToOffset,
             totals.totalCollToSendToSP
         );
         _redistributeDebtAndColl(
@@ -830,10 +756,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         );
     }
 
-    function getRedemptionRateWithDecay() public view override returns (uint) {
-        return _calcRedemptionRate(_calcDecayedBaseRate());
-    }
-
     function getCurrentICR(
         address _borrower,
         uint256 _price
@@ -880,9 +802,19 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             uint256 pendingInterest
         )
     {
-        coll = Troves[_borrower].coll;
-        principal = Troves[_borrower].principal;
-        interest = Troves[_borrower].interestOwed;
+        Trove storage trove = Troves[_borrower];
+        coll = trove.coll;
+        principal = trove.principal;
+        interest = trove.interestOwed;
+
+        // solhint-disable not-rely-on-time
+        interest += InterestRateMath.calculateInterestOwed(
+            principal,
+            trove.interestRate,
+            trove.lastInterestUpdateTime,
+            block.timestamp
+        );
+        // solhint-enable not-rely-on-time
 
         pendingCollateral = getPendingCollateral(_borrower);
         (pendingPrincipal, pendingInterest) = getPendingDebt(_borrower);
@@ -892,14 +824,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         interest += pendingInterest;
     }
 
-    function getBorrowingRate() public view override returns (uint) {
-        return _calcBorrowingRate(baseRate);
-    }
-
-    function getBorrowingRateWithDecay() public view override returns (uint) {
-        return _calcBorrowingRate(_calcDecayedBaseRate());
-    }
-
     function getPendingCollateral(
         address _borrower
     ) public view override returns (uint) {
@@ -945,10 +869,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         pendingInterest = (stake * interestPerUnitStaked) / DECIMAL_PRECISION;
     }
 
-    function getRedemptionRate() public view override returns (uint) {
-        return _calcRedemptionRate(baseRate);
-    }
-
     /**
      * Updates the debt on the given trove by first paying down interest owed, then the principal.
      * Note that this does not actually calculate interest owed, it just pays down the debt by the given amount.
@@ -957,8 +877,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     function _updateTroveDebt(address _borrower, uint256 _payment) internal {
         Trove storage trove = Troves[_borrower];
 
-        updateSystemAndTroveInterest(_borrower);
-
         // slither-disable-start calls-loop
         (
             uint256 principalAdjustment,
@@ -973,35 +891,18 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         trove.interestOwed -= interestAdjustment;
     }
 
-    /*
-     * This function has two impacts on the baseRate state variable:
-     * 1) decays the baseRate based on time passed since last redemption or borrowing operation.
-     * then,
-     * 2) increases the baseRate based on the amount redeemed, as a proportion of total debt
-     */
-    function _updateBaseRateFromRedemption(
-        uint256 _collateralDrawn,
-        uint256 _price,
-        uint256 _totalDebt
-    ) internal returns (uint) {
-        uint256 decayedBaseRate = _calcDecayedBaseRate();
-
-        /* Convert the drawn collateral back to mUSD at face value rate (1 mUSD:1 USD), in order to get
-         * the fraction of total supply that was redeemed at face value. */
-        uint256 redeemedMUSDFraction = (_collateralDrawn * _price) / _totalDebt;
-
-        uint256 newBaseRate = decayedBaseRate + (redeemedMUSDFraction / BETA);
-        newBaseRate = LiquityMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%
-        //assert(newBaseRate <= DECIMAL_PRECISION); // This is already enforced in the line above
-        assert(newBaseRate > 0); // Base rate is always non-zero after redemption
-
-        // Update the baseRate state variable
-        baseRate = newBaseRate;
-        emit BaseRateUpdated(newBaseRate);
-
-        _updateLastFeeOpTime();
+    function _updateTroveInterest(address _borrower) internal {
+        Trove storage trove = Troves[_borrower];
 
-        return newBaseRate;
+        // solhint-disable not-rely-on-time
+        trove.interestOwed += InterestRateMath.calculateInterestOwed(
+            trove.principal,
+            trove.interestRate,
+            trove.lastInterestUpdateTime,
+            block.timestamp
+        );
+        trove.lastInterestUpdateTime = block.timestamp;
+        // solhint-enable not-rely-on-time
     }
 
     // Add the borrowers's coll and debt rewards earned from redistributions, to their Trove
@@ -1012,15 +913,12 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     ) internal {
         Trove storage trove = Troves[_borrower];
         if (hasPendingRewards(_borrower)) {
-            _requireTroveIsActive(_borrower);
-
             // Compute pending rewards
             uint256 pendingCollateral = getPendingCollateral(_borrower);
             (
                 uint256 pendingPrincipal,
                 uint256 pendingInterest
             ) = getPendingDebt(_borrower);
-            updateSystemAndTroveInterest(_borrower);
 
             // Apply pending rewards to trove's state
             trove.coll += pendingCollateral;
@@ -1029,13 +927,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
             // slither-disable-start calls-loop
             // Apply pending rewards to system interest rate data
-            interestRateManager.addPrincipalToRate(
-                trove.interestRate,
-                pendingPrincipal
-            );
-            interestRateManager.addInterestToRate(
-                trove.interestRate,
-                pendingInterest
+            interestRateManager.addPrincipal(
+                pendingPrincipal,
+                trove.interestRate
             );
             // slither-disable-end calls-loop
 
@@ -1113,8 +1007,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             return;
         }
 
-        updateDefaultPoolInterest();
-
         /*
          * Add distributed collateral, principal, and interest
          * rewards-per-unit-staked to the running totals. Division uses a
@@ -1173,8 +1065,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         _activePool.sendCollateral(address(_defaultPool), _coll);
     }
 
-    // Liquidate one trove, in Normal Mode.
-    function _liquidateNormalMode(
+    // Liquidate one trove
+    function _liquidate(
         IActivePool _activePool,
         IDefaultPool _defaultPool,
         address _borrower,
@@ -1182,6 +1074,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
     ) internal returns (LiquidationValues memory singleLiquidation) {
         // slither-disable-next-line uninitialized-local
         LocalVariables_InnerSingleLiquidateFunction memory vars;
+        if (TroveOwners.length <= 1) {
+            return singleLiquidation;
+        } // don't liquidate if last trove
 
         (
             singleLiquidation.entireTroveColl,
@@ -1209,7 +1104,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             singleLiquidation.collGasCompensation;
 
         (
-            singleLiquidation.debtToOffset,
+            singleLiquidation.principalToOffset,
+            singleLiquidation.interestToOffset,
             singleLiquidation.collToSendToSP,
             singleLiquidation.principalToRedistribute,
             singleLiquidation.interestToRedistribute,
@@ -1226,7 +1122,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             _borrower,
             singleLiquidation.entireTrovePrincipal,
             singleLiquidation.entireTroveColl,
-            uint8(TroveManagerOperation.liquidateInNormalMode)
+            uint8(TroveManagerOperation.liquidate)
         );
         emit TroveUpdated(
             _borrower,
@@ -1234,7 +1130,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             0,
             0,
             0,
-            uint8(TroveManagerOperation.liquidateInNormalMode)
+            uint8(TroveManagerOperation.liquidate)
         );
         return singleLiquidation;
     }
@@ -1247,7 +1143,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         Troves[_borrower].stake = 0;
     }
 
-    function _getTotalsFromBatchLiquidateNormalMode(
+    function _getTotalsFromBatchLiquidate(
         IActivePool _activePool,
         IDefaultPool _defaultPool,
         uint256 _price,
@@ -1261,277 +1157,29 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
         vars.remainingMUSDInStabPool = _MUSDInStabPool;
 
-        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {
+        uint troveArrayLength = _troveArray.length;
+        for (vars.i = 0; vars.i < troveArrayLength; vars.i++) {
             vars.user = _troveArray[vars.i];
             vars.ICR = getCurrentICR(vars.user, _price);
 
             if (vars.ICR < MCR) {
-                singleLiquidation = _liquidateNormalMode(
-                    _activePool,
-                    _defaultPool,
-                    vars.user,
-                    vars.remainingMUSDInStabPool
-                );
-                vars.remainingMUSDInStabPool -= singleLiquidation.debtToOffset;
-
-                // Add liquidation values to their respective running totals
-                totals = _addLiquidationValuesToTotals(
-                    totals,
-                    singleLiquidation
-                );
-            }
-        }
-    }
-
-    /*
-     * This function is used when the batch liquidation sequence starts during Recovery Mode. However, it
-     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation sequence
-     */
-    function _getTotalFromBatchLiquidateRecoveryMode(
-        IActivePool _activePool,
-        IDefaultPool _defaultPool,
-        uint256 _price,
-        uint256 _MUSDInStabPool,
-        address[] memory _troveArray
-    ) internal returns (LiquidationTotals memory totals) {
-        // slither-disable-next-line uninitialized-local
-        LocalVariables_LiquidationSequence memory vars;
-        // slither-disable-next-line uninitialized-local
-        LiquidationValues memory singleLiquidation;
-
-        vars.remainingMUSDInStabPool = _MUSDInStabPool;
-        vars.backToNormalMode = false;
-        vars.entireSystemDebt = getEntireSystemDebt();
-        vars.entireSystemColl = getEntireSystemColl();
-
-        for (vars.i = 0; vars.i < _troveArray.length; vars.i++) {
-            vars.user = _troveArray[vars.i];
-            // Skip non-active troves
-            if (Troves[vars.user].status != Status.active) {
-                continue;
-            }
-            vars.ICR = getCurrentICR(vars.user, _price);
-
-            if (!vars.backToNormalMode) {
-                // Skip this trove if ICR is greater than MCR and Stability Pool is empty
-                if (vars.ICR >= MCR && vars.remainingMUSDInStabPool == 0) {
-                    continue;
-                }
-
-                uint256 TCR = LiquityMath._computeCR(
-                    vars.entireSystemColl,
-                    vars.entireSystemDebt,
-                    _price
-                );
-
-                singleLiquidation = _liquidateRecoveryMode(
-                    _activePool,
-                    _defaultPool,
-                    vars.user,
-                    vars.ICR,
-                    vars.remainingMUSDInStabPool,
-                    TCR,
-                    _price
-                );
-
-                // Update aggregate trackers
-                vars.remainingMUSDInStabPool -= singleLiquidation.debtToOffset;
-                vars.entireSystemDebt -= singleLiquidation.debtToOffset;
-                vars.entireSystemColl -=
-                    singleLiquidation.collToSendToSP +
-                    singleLiquidation.collGasCompensation +
-                    singleLiquidation.collSurplus;
-
-                // Add liquidation values to their respective running totals
-                totals = _addLiquidationValuesToTotals(
-                    totals,
-                    singleLiquidation
-                );
-
-                vars.backToNormalMode = !_checkPotentialRecoveryMode(
-                    vars.entireSystemColl,
-                    vars.entireSystemDebt,
-                    _price
-                );
-            } else if (vars.backToNormalMode && vars.ICR < MCR) {
-                singleLiquidation = _liquidateNormalMode(
+                singleLiquidation = _liquidate(
                     _activePool,
                     _defaultPool,
                     vars.user,
                     vars.remainingMUSDInStabPool
                 );
-                vars.remainingMUSDInStabPool -= singleLiquidation.debtToOffset;
+                vars.remainingMUSDInStabPool -=
+                    singleLiquidation.principalToOffset +
+                    singleLiquidation.interestToOffset;
 
                 // Add liquidation values to their respective running totals
                 totals = _addLiquidationValuesToTotals(
                     totals,
                     singleLiquidation
                 );
-            } else continue; // In Normal Mode skip troves with ICR >= MCR
-        }
-    }
-
-    // Liquidate one trove, in Recovery Mode.
-    function _liquidateRecoveryMode(
-        IActivePool _activePool,
-        IDefaultPool _defaultPool,
-        address _borrower,
-        uint256 _ICR,
-        uint256 _MUSDInStabPool,
-        uint256 _TCR,
-        uint256 _price
-    ) internal returns (LiquidationValues memory singleLiquidation) {
-        // slither-disable-next-line uninitialized-local
-        LocalVariables_InnerSingleLiquidateFunction memory vars;
-        if (TroveOwners.length <= 1) {
-            return singleLiquidation;
-        } // don't liquidate if last trove
-        (
-            singleLiquidation.entireTroveColl,
-            singleLiquidation.entireTrovePrincipal,
-            singleLiquidation.entireTroveInterest,
-            vars.pendingColl,
-            vars.pendingPrincipal,
-            vars.pendingInterest
-        ) = getEntireDebtAndColl(_borrower);
-
-        singleLiquidation.collGasCompensation = _getCollGasCompensation(
-            singleLiquidation.entireTroveColl
-        );
-        singleLiquidation.mUSDGasCompensation = MUSD_GAS_COMPENSATION;
-        vars.collToLiquidate =
-            singleLiquidation.entireTroveColl -
-            singleLiquidation.collGasCompensation;
-
-        // If ICR <= 100%, purely redistribute the Trove across all active Troves
-        if (_ICR <= _100pct) {
-            _removeStake(_borrower);
-            _movePendingTroveRewardsToActivePool(
-                _activePool,
-                _defaultPool,
-                vars.pendingColl,
-                vars.pendingPrincipal,
-                vars.pendingInterest
-            );
-
-            singleLiquidation.debtToOffset = 0;
-            singleLiquidation.collToSendToSP = 0;
-            singleLiquidation.principalToRedistribute = singleLiquidation
-                .entireTrovePrincipal;
-            singleLiquidation.collToRedistribute = vars.collToLiquidate;
-
-            _closeTrove(_borrower, Status.closedByLiquidation);
-            emit TroveLiquidated(
-                _borrower,
-                singleLiquidation.entireTrovePrincipal,
-                singleLiquidation.entireTroveColl,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-            emit TroveUpdated(
-                _borrower,
-                0,
-                0,
-                0,
-                0,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-
-            // If 100% < ICR < MCR, offset as much as possible, and redistribute the remainder
-        } else if ((_ICR > _100pct) && (_ICR < MCR)) {
-            _removeStake(_borrower);
-            _movePendingTroveRewardsToActivePool(
-                _activePool,
-                _defaultPool,
-                vars.pendingColl,
-                vars.pendingPrincipal,
-                vars.pendingInterest
-            );
-
-            (
-                singleLiquidation.debtToOffset,
-                singleLiquidation.collToSendToSP,
-                singleLiquidation.principalToRedistribute,
-                singleLiquidation.interestToRedistribute,
-                singleLiquidation.collToRedistribute
-            ) = _getOffsetAndRedistributionVals(
-                singleLiquidation.entireTrovePrincipal,
-                singleLiquidation.entireTroveInterest,
-                vars.collToLiquidate,
-                _MUSDInStabPool
-            );
-
-            _closeTrove(_borrower, Status.closedByLiquidation);
-            emit TroveLiquidated(
-                _borrower,
-                singleLiquidation.entireTrovePrincipal,
-                singleLiquidation.entireTroveColl,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-            emit TroveUpdated(
-                _borrower,
-                0,
-                0,
-                0,
-                0,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-            /*
-             * If 110% <= ICR < current TCR (accounting for the preceding liquidations in the current sequence)
-             * and there is mUSD in the Stability Pool, only offset, with no redistribution,
-             * but at a capped rate of 1.1 and only if the whole debt can be liquidated.
-             * The remainder due to the capped rate will be claimable as collateral surplus.
-             */
-        } else if (
-            (_ICR >= MCR) &&
-            (_ICR < _TCR) &&
-            (singleLiquidation.entireTrovePrincipal <= _MUSDInStabPool)
-        ) {
-            _removeStake(_borrower);
-            _movePendingTroveRewardsToActivePool(
-                _activePool,
-                _defaultPool,
-                vars.pendingColl,
-                vars.pendingPrincipal,
-                vars.pendingInterest
-            );
-            assert(_MUSDInStabPool != 0);
-
-            singleLiquidation = _getCappedOffsetVals(
-                singleLiquidation.entireTrovePrincipal,
-                singleLiquidation.entireTroveColl,
-                _price
-            );
-
-            _closeTrove(_borrower, Status.closedByLiquidation);
-            if (singleLiquidation.collSurplus > 0) {
-                collSurplusPool.accountSurplus(
-                    _borrower,
-                    singleLiquidation.collSurplus
-                );
             }
-
-            emit TroveLiquidated(
-                _borrower,
-                singleLiquidation.entireTrovePrincipal,
-                singleLiquidation.collToSendToSP,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-            emit TroveUpdated(
-                _borrower,
-                0,
-                0,
-                0,
-                0,
-                uint8(TroveManagerOperation.liquidateInRecoveryMode)
-            );
-        } else {
-            // if (_ICR >= MCR && ( _ICR >= _TCR || singleLiquidation.entireTroveDebt > _MUSDInStabPool))
-            // slither-disable-next-line uninitialized-local
-            LiquidationValues memory zeroVals;
-            return zeroVals;
         }
-
-        return singleLiquidation;
     }
 
     /*
@@ -1548,9 +1196,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         uint256 _collateral
     ) internal {
         // slither-disable-next-line calls-loop
-        interestRateManager.removePrincipalFromRate(
-            Troves[_borrower].interestRate,
-            _amount
+        interestRateManager.removePrincipal(
+            _amount,
+            Troves[_borrower].interestRate
         );
         Troves[_borrower].principal -= _amount;
         // slither-disable-next-line calls-loop
@@ -1577,24 +1225,45 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         uint256 _price,
         address _upperPartialRedemptionHint,
         address _lowerPartialRedemptionHint,
-        uint256 _partialRedemptionHintNICR
+        uint256 _partialRedemptionHintNICR,
+        LocalVariables_redeemCollateral memory redeemCollateralVars
     ) internal returns (SingleRedemptionValues memory singleRedemption) {
         // slither-disable-next-line uninitialized-local
         LocalVariables_redeemCollateralFromTrove memory vars;
         // Determine the remaining amount (lot) to be redeemed, capped by the entire debt of the Trove minus the liquidation reserve
-        singleRedemption.mUSDLot = LiquityMath._min(
+        vars.mUSDLot = LiquityMath._min(
             _maxMUSDamount,
             _getTotalDebt(_borrower) - MUSD_GAS_COMPENSATION
         );
 
         // Get the collateralLot of equivalent value in USD
         singleRedemption.collateralLot =
-            (singleRedemption.mUSDLot * DECIMAL_PRECISION) /
+            (vars.mUSDLot * DECIMAL_PRECISION) /
             _price;
 
         // Decrease the debt and collateral of the current Trove according to the mUSD lot and corresponding collateral to send
-        vars.newDebt = _getTotalDebt(_borrower) - singleRedemption.mUSDLot;
+        vars.newDebt = _getTotalDebt(_borrower) - vars.mUSDLot;
         vars.newColl = Troves[_borrower].coll - singleRedemption.collateralLot;
+        vars.newPrincipal = Troves[_borrower].principal;
+
+        // solhint-disable not-rely-on-time
+        vars.interestPayment =
+            Troves[_borrower].interestOwed +
+            InterestRateMath.calculateInterestOwed(
+                Troves[_borrower].principal,
+                Troves[_borrower].interestRate,
+                Troves[_borrower].lastInterestUpdateTime,
+                block.timestamp
+            );
+        // solhint-enable not-rely-on-time
+
+        if (vars.mUSDLot > vars.interestPayment) {
+            vars.newPrincipal -= vars.mUSDLot - vars.interestPayment;
+            singleRedemption.interest = vars.interestPayment;
+            singleRedemption.principal = vars.mUSDLot - vars.interestPayment;
+        } else {
+            singleRedemption.interest = vars.mUSDLot;
+        }
 
         if (vars.newDebt == MUSD_GAS_COMPENSATION) {
             // No debt left in the Trove (except for the liquidation reserve), therefore the trove gets closed
@@ -1616,23 +1285,22 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             );
         } else {
             // calculate 10 minutes worth of interest to account for delay between the hint call and now
-            // slither-disable-start calls-loop
             // solhint-disable not-rely-on-time
+
             vars.upperBoundNICR = LiquityMath._computeNominalCR(
                 vars.newColl,
-                vars.newDebt -
-                    interestRateManager.calculateInterestOwed(
+                vars.newPrincipal -
+                    InterestRateMath.calculateInterestOwed(
                         Troves[_borrower].principal,
-                        interestRateManager.interestRate(),
+                        redeemCollateralVars.interestRate,
                         block.timestamp - 600,
                         block.timestamp
                     )
             );
             // solhint-enable not-rely-on-time
-            // slither-disable-end calls-loop
             vars.newNICR = LiquityMath._computeNominalCR(
                 vars.newColl,
-                vars.newDebt
+                vars.newPrincipal
             );
 
             /*
@@ -1641,14 +1309,16 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
              *
              * If the resultant net debt of the partial is less than the minimum, net debt we bail.
              */
+            // slither-disable-start calls-loop
             if (
                 _partialRedemptionHintNICR < vars.newNICR ||
                 _partialRedemptionHintNICR > vars.upperBoundNICR ||
-                _getNetDebt(vars.newDebt) < MIN_NET_DEBT
+                _getNetDebt(vars.newDebt) < redeemCollateralVars.minNetDebt
             ) {
                 singleRedemption.cancelledPartial = true;
                 return singleRedemption;
             }
+            // slither-disable-end calls-loop
 
             // slither-disable-next-line calls-loop
             _contractsCache.sortedTroves.reInsert(
@@ -1658,7 +1328,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
                 _lowerPartialRedemptionHint
             );
 
-            _updateTroveDebt(_borrower, singleRedemption.mUSDLot);
+            _updateTroveDebt(_borrower, vars.mUSDLot);
             Troves[_borrower].coll = vars.newColl;
             _updateStakeAndTotalStakes(_borrower);
 
@@ -1701,7 +1371,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         address _borrower
     ) internal returns (uint128 index) {
         /* Max array size is 2**128 - 1, i.e. ~3e30 troves. No risk of overflow, since troves have minimum mUSD
-        debt of liquidation reserve plus MIN_NET_DEBT. 3e30 mUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
+        debt of liquidation reserve plus minNetDebt. 3e30 mUSD dwarfs the value of all wealth in the world ( which is < 1e15 USD). */
 
         // Push the Troveowner to the array
         TroveOwners.push(_borrower);
@@ -1713,18 +1383,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         return index;
     }
 
-    function _updateLastFeeOpTime() internal {
-        // solhint-disable-next-line not-rely-on-time
-        uint256 timePassed = block.timestamp - lastFeeOperationTime;
-
-        if (timePassed >= 1 minutes) {
-            // solhint-disable-next-line not-rely-on-time
-            lastFeeOperationTime = block.timestamp;
-            // solhint-disable-next-line not-rely-on-time
-            emit LastFeeOpTimeUpdated(block.timestamp);
-        }
-    }
-
     // Move a Trove's pending debt and collateral rewards from distributions, from the Default Pool to the Active Pool
     function _movePendingTroveRewardsToActivePool(
         IActivePool _activePool,
@@ -1748,18 +1406,14 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
         uint256 TroveOwnersArrayLength = TroveOwners.length;
         // slither-disable-next-line calls-loop
-        if (musdToken.mintList(borrowerOperationsAddress)) {
+        if (musdToken.mintList(address(borrowerOperations))) {
             _requireMoreThanOneTroveInSystem(TroveOwnersArrayLength);
         }
 
         // slither-disable-start calls-loop
-        interestRateManager.removePrincipalFromRate(
-            Troves[_borrower].interestRate,
-            Troves[_borrower].principal
-        );
-        interestRateManager.removeInterestFromRate(
-            Troves[_borrower].interestRate,
-            Troves[_borrower].interestOwed
+        interestRateManager.removePrincipal(
+            Troves[_borrower].principal,
+            Troves[_borrower].interestRate
         );
         // slither-disable-end calls-loop
 
@@ -1874,7 +1528,7 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         return
             Troves[_borrower].principal +
             Troves[_borrower].interestOwed +
-            interestRateManager.calculateInterestOwed(
+            InterestRateMath.calculateInterestOwed(
                 Troves[_borrower].principal,
                 Troves[_borrower].interestRate,
                 Troves[_borrower].lastInterestUpdateTime,
@@ -1902,30 +1556,9 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         return stake;
     }
 
-    function _getRedemptionFee(
-        uint256 _collateralDrawn
-    ) internal view returns (uint) {
-        return _calcRedemptionFee(getRedemptionRate(), _collateralDrawn);
-    }
-
-    function _calcDecayedBaseRate() internal view returns (uint) {
-        uint256 minutesPassed = _minutesPassedSinceLastFeeOp();
-        uint256 decayFactor = LiquityMath._decPow(
-            MINUTE_DECAY_FACTOR,
-            minutesPassed
-        );
-
-        return (baseRate * decayFactor) / DECIMAL_PRECISION;
-    }
-
-    function _minutesPassedSinceLastFeeOp() internal view returns (uint) {
-        // solhint-disable-next-line not-rely-on-time
-        return (block.timestamp - lastFeeOperationTime) / 1 minutes;
-    }
-
     function _requireCallerIsBorrowerOperations() internal view {
         require(
-            msg.sender == borrowerOperationsAddress,
+            msg.sender == address(borrowerOperations),
             "TroveManager: Caller is not the BorrowerOperations contract"
         );
     }
@@ -1937,6 +1570,18 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         );
     }
 
+    function _getRedemptionFee(
+        uint256 _collateralDrawn
+    ) internal pure returns (uint) {
+        uint256 redemptionFee = (REDEMPTION_FEE_FLOOR * _collateralDrawn) /
+            DECIMAL_PRECISION;
+        require(
+            redemptionFee < _collateralDrawn,
+            "TroveManager: Fee would eat up all returned collateral"
+        );
+        return redemptionFee;
+    }
+
     /* In a full liquidation, returns the values for a trove's coll and debt to be offset, and coll and debt to be
      * redistributed to active troves.
      */
@@ -1949,7 +1594,8 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         internal
         pure
         returns (
-            uint256 debtToOffset,
+            uint256 principalToOffset,
+            uint256 interestToOffset,
             uint256 collToSendToSP,
             uint256 principalToRedistribute,
             uint256 interestToRedistribute,
@@ -1967,21 +1613,19 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
              *  - Send a fraction of the trove's collateral to the Stability Pool, equal to the fraction of its offset debt
              *
              */
-            uint256 interestToOffset = LiquityMath._min(
-                _interest,
-                _MUSDInStabPool
-            );
-            uint256 principalToOffset = LiquityMath._min(
+            interestToOffset = LiquityMath._min(_interest, _MUSDInStabPool);
+            principalToOffset = LiquityMath._min(
                 _principal,
                 _MUSDInStabPool - interestToOffset
             );
-            debtToOffset = principalToOffset + interestToOffset;
+            uint256 debtToOffset = principalToOffset + interestToOffset;
             collToSendToSP = (_coll * debtToOffset) / (_principal + _interest);
             interestToRedistribute = _interest - interestToOffset;
             principalToRedistribute = _principal - principalToOffset;
             collToRedistribute = _coll - collToSendToSP;
         } else {
-            debtToOffset = 0;
+            principalToOffset = 0;
+            interestToOffset = 0;
             collToSendToSP = 0;
             principalToRedistribute = _principal;
             interestToRedistribute = _interest;
@@ -1993,57 +1637,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
         require(_amount > 0, "TroveManager: Amount must be greater than zero");
     }
 
-    function _requireValidMaxFeePercentage(
-        uint256 _maxFeePercentage
-    ) internal pure {
-        require(
-            _maxFeePercentage >= REDEMPTION_FEE_FLOOR &&
-                _maxFeePercentage <= DECIMAL_PRECISION,
-            "Max fee percentage must be between 0.5% and 100%"
-        );
-    }
-
-    // Check whether or not the system *would be* in Recovery Mode, given an collateral:USD price, and the entire system coll and debt.
-    function _checkPotentialRecoveryMode(
-        uint256 _entireSystemColl,
-        uint256 _entireSystemDebt,
-        uint256 _price
-    ) internal pure returns (bool) {
-        uint256 TCR = LiquityMath._computeCR(
-            _entireSystemColl,
-            _entireSystemDebt,
-            _price
-        );
-
-        return TCR < CCR;
-    }
-
-    /*
-     *  Get its offset coll/debt and collateral gas comp, and close the trove.
-     */
-    function _getCappedOffsetVals(
-        uint256 _entireTroveDebt,
-        uint256 _entireTroveColl,
-        uint256 _price
-    ) internal pure returns (LiquidationValues memory singleLiquidation) {
-        singleLiquidation.entireTrovePrincipal = _entireTroveDebt;
-        singleLiquidation.entireTroveColl = _entireTroveColl;
-        uint256 cappedCollPortion = (_entireTroveDebt * MCR) / _price;
-
-        singleLiquidation.collGasCompensation = _getCollGasCompensation(
-            cappedCollPortion
-        );
-        singleLiquidation.mUSDGasCompensation = MUSD_GAS_COMPENSATION;
-
-        singleLiquidation.debtToOffset = _entireTroveDebt;
-        singleLiquidation.collToSendToSP =
-            cappedCollPortion -
-            singleLiquidation.collGasCompensation;
-        singleLiquidation.collSurplus = _entireTroveColl - cappedCollPortion;
-        singleLiquidation.principalToRedistribute = 0;
-        singleLiquidation.collToRedistribute = 0;
-    }
-
     function _addLiquidationValuesToTotals(
         LiquidationTotals memory oldTotals,
         LiquidationValues memory singleLiquidation
@@ -2069,9 +1662,13 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
             oldTotals.totalCollInSequence +
             singleLiquidation.entireTroveColl;
 
-        newTotals.totalDebtToOffset =
-            oldTotals.totalDebtToOffset +
-            singleLiquidation.debtToOffset;
+        newTotals.totalPrincipalToOffset =
+            oldTotals.totalPrincipalToOffset +
+            singleLiquidation.principalToOffset;
+
+        newTotals.totalInterestToOffset =
+            oldTotals.totalInterestToOffset +
+            singleLiquidation.interestToOffset;
 
         newTotals.totalCollToSendToSP =
             oldTotals.totalCollToSendToSP +
@@ -2095,46 +1692,6 @@ contract TroveManager is LiquityBase, Ownable, CheckContract, ITroveManager {
 
         return newTotals;
     }
-
-    function _calcBorrowingFee(
-        uint256 _borrowingRate,
-        uint256 _debt
-    ) internal pure returns (uint) {
-        return (_borrowingRate * _debt) / DECIMAL_PRECISION;
-    }
-
-    function _calcBorrowingRate(
-        uint256 _baseRate
-    ) internal pure returns (uint) {
-        return
-            LiquityMath._min(
-                BORROWING_FEE_FLOOR + _baseRate,
-                MAX_BORROWING_FEE
-            );
-    }
-
-    function _calcRedemptionFee(
-        uint256 _redemptionRate,
-        uint256 _collateralDrawn
-    ) internal pure returns (uint) {
-        uint256 redemptionFee = (_redemptionRate * _collateralDrawn) /
-            DECIMAL_PRECISION;
-        require(
-            redemptionFee < _collateralDrawn,
-            "TroveManager: Fee would eat up all returned collateral"
-        );
-        return redemptionFee;
-    }
-
-    function _calcRedemptionRate(
-        uint256 _baseRate
-    ) internal pure returns (uint) {
-        return
-            LiquityMath._min(
-                REDEMPTION_FEE_FLOOR + _baseRate,
-                DECIMAL_PRECISION // cap at a maximum of 100%
-            );
-    }
 }
 // slither-disable-end reentrancy-benign
 // slither-disable-end reentrancy-events
diff --git a/solidity/contracts/dependencies/InterestRateMath.sol b/solidity/contracts/dependencies/InterestRateMath.sol
new file mode 100644
index 0000000..96e5152
--- /dev/null
+++ b/solidity/contracts/dependencies/InterestRateMath.sol
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.24;
+
+library InterestRateMath {
+    // https://sibenotes.com/maths/how-many-seconds-are-in-a-year/
+    // 365.2425 days per year * 24 hours per day *
+    // 60 minutes per hour * 60 seconds per minute
+    uint256 public constant SECONDS_IN_A_YEAR = 31_556_952;
+    uint256 private constant BPS = 10_000;
+
+    function calculateInterestOwed(
+        uint256 _principal,
+        uint16 _interestRate,
+        uint256 _startTime,
+        uint256 _endTime
+    ) internal pure returns (uint256) {
+        uint256 timeElapsed = _endTime - _startTime;
+        return
+            (_principal * _interestRate * timeElapsed) /
+            (BPS * SECONDS_IN_A_YEAR);
+    }
+
+    function calculateAggregatedInterestOwed(
+        uint256 _interestNumerator,
+        uint256 _startTime,
+        uint256 _endTime
+    ) internal pure returns (uint256) {
+        uint256 timeElapsed = _endTime - _startTime;
+        return (timeElapsed * _interestNumerator) / (BPS * SECONDS_IN_A_YEAR);
+    }
+
+    function calculateDebtAdjustment(
+        uint256 _interestOwed,
+        uint256 _payment
+    )
+        internal
+        pure
+        returns (uint256 principalAdjustment, uint256 interestAdjustment)
+    {
+        if (_payment >= _interestOwed) {
+            principalAdjustment = _payment - _interestOwed;
+            interestAdjustment = _interestOwed;
+        } else {
+            principalAdjustment = 0;
+            interestAdjustment = _payment;
+        }
+    }
+}
diff --git a/solidity/contracts/dependencies/LiquityBase.sol b/solidity/contracts/dependencies/LiquityBase.sol
index bad578d..a8a15f5 100644
--- a/solidity/contracts/dependencies/LiquityBase.sol
+++ b/solidity/contracts/dependencies/LiquityBase.sol
@@ -3,9 +3,11 @@
 pragma solidity ^0.8.24;
 
 import "./BaseMath.sol";
+import "./InterestRateMath.sol";
 import "./LiquityMath.sol";
 import "../interfaces/IActivePool.sol";
 import "../interfaces/IDefaultPool.sol";
+import "../interfaces/IInterestRateManager.sol";
 import "../interfaces/IPriceFeed.sol";
 import "../interfaces/ILiquityBase.sol";
 
@@ -25,10 +27,6 @@ abstract contract LiquityBase is BaseMath, ILiquityBase {
     // Amount of mUSD to be locked in gas pool on opening troves
     uint256 public constant MUSD_GAS_COMPENSATION = 200e18;
 
-    // Minimum amount of net mUSD debt a trove must have
-    uint256 public constant MIN_NET_DEBT = 1800e18;
-    // uint256 constant public MIN_NET_DEBT = 0;
-
     uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%
 
     uint256 public constant BORROWING_FEE_FLOOR = ((DECIMAL_PRECISION * 5) /
@@ -40,14 +38,21 @@ abstract contract LiquityBase is BaseMath, ILiquityBase {
     // slither-disable-next-line all
     IDefaultPool public defaultPool;
 
+    // slither-disable-next-line all
+    IInterestRateManager public interestRateManager;
+
     // slither-disable-next-line all
     IPriceFeed public override priceFeed;
 
+    // slither-disable-next-line unused-state
+    uint256[50] private __gap;
+
     // --- Gas compensation functions ---
 
     function getEntireSystemColl()
         public
         view
+        virtual
         returns (uint256 entireSystemColl)
     {
         uint256 activeColl = activePool.getCollateralBalance();
@@ -59,15 +64,19 @@ abstract contract LiquityBase is BaseMath, ILiquityBase {
     function getEntireSystemDebt()
         public
         view
+        virtual
         returns (uint256 entireSystemDebt)
     {
         uint256 activeDebt = activePool.getDebt();
         uint256 closedDebt = defaultPool.getDebt();
+        uint256 accruedInterest = interestRateManager.getAccruedInterest();
 
-        return activeDebt + closedDebt;
+        return activeDebt + closedDebt + accruedInterest;
     }
 
-    function _getTCR(uint256 _price) internal view returns (uint256 TCR) {
+    function _getTCR(
+        uint256 _price
+    ) internal view virtual returns (uint256 TCR) {
         uint256 entireSystemColl = getEntireSystemColl();
         uint256 entireSystemDebt = getEntireSystemDebt();
 
@@ -79,24 +88,22 @@ abstract contract LiquityBase is BaseMath, ILiquityBase {
         return TCR;
     }
 
-    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {
+    function _checkRecoveryMode(
+        uint256 _price
+    ) internal view virtual returns (bool) {
         uint256 TCR = _getTCR(_price);
         return TCR < CCR;
     }
 
-    function _requireUserAcceptsFee(
-        uint256 _fee,
-        uint256 _amount,
-        uint256 _maxFeePercentage
-    ) internal pure {
-        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;
-        require(
-            feePercentage <= _maxFeePercentage,
-            "Fee exceeded provided maximum"
-        );
+    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
+    function _getCollGasCompensation(
+        uint256 _entireColl
+    ) internal pure virtual returns (uint) {
+        return _entireColl / PERCENT_DIVISOR;
     }
 
-    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation
+    // Returns the composite debt (drawn debt + gas compensation) of a trove,
+    // for the purpose of ICR calculation
     function _getCompositeDebt(uint256 _debt) internal pure returns (uint) {
         return _debt + MUSD_GAS_COMPENSATION;
     }
@@ -104,11 +111,4 @@ abstract contract LiquityBase is BaseMath, ILiquityBase {
     function _getNetDebt(uint256 _debt) internal pure returns (uint) {
         return _debt - MUSD_GAS_COMPENSATION;
     }
-
-    // Return the amount of collateral to be drawn from a trove's collateral and sent as gas compensation.
-    function _getCollGasCompensation(
-        uint256 _entireColl
-    ) internal pure returns (uint) {
-        return _entireColl / PERCENT_DIVISOR;
-    }
 }
diff --git a/solidity/contracts/dependencies/LiquityMath.sol b/solidity/contracts/dependencies/LiquityMath.sol
index 8a81d98..d98f1d3 100644
--- a/solidity/contracts/dependencies/LiquityMath.sol
+++ b/solidity/contracts/dependencies/LiquityMath.sol
@@ -3,8 +3,6 @@
 pragma solidity ^0.8.24;
 
 library LiquityMath {
-    uint256 internal constant DECIMAL_PRECISION = 1e18;
-
     /* Precision for Nominal ICR (independent of price). Rationale for the value:
      *
      * - Making it “too high” could lead to overflows.
@@ -20,71 +18,6 @@ library LiquityMath {
         return (_a < _b) ? _a : _b;
     }
 
-    /*
-     * Multiply two decimal numbers and use normal rounding rules:
-     * -round product up if 19'th mantissa digit >= 5
-     * -round product down if 19'th mantissa digit < 5
-     *
-     * Used only inside the exponentiation, _decPow().
-     */
-    function decMul(
-        uint256 x,
-        uint256 y
-    ) internal pure returns (uint256 decProd) {
-        uint256 prod_xy = x * y;
-
-        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;
-    }
-
-    /*
-     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.
-     *
-     * Uses the efficient "exponentiation by squaring" algorithm. O(log(n)) complexity.
-     *
-     * Called by one function that represent time in units of minutes:
-     * 1) TroveManager._calcDecayedBaseRate
-     *
-     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals
-     * "minutes in 1000 years": 60 * 24 * 365 * 1000
-     *
-     * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be
-     * negligibly different from just passing the cap, since:
-     *
-     * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years
-     * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible
-     */
-    function _decPow(
-        uint256 _base,
-        uint256 _minutes
-    ) internal pure returns (uint) {
-        if (_minutes > 5.256e8) {
-            _minutes = 5.256e8;
-        } // cap to avoid overflow
-
-        if (_minutes == 0) {
-            return DECIMAL_PRECISION;
-        }
-
-        uint256 y = DECIMAL_PRECISION;
-        uint256 x = _base;
-        uint256 n = _minutes;
-
-        // Exponentiation-by-squaring
-        while (n > 1) {
-            if (n % 2 == 0) {
-                x = decMul(x, x);
-                n = n / 2;
-            } else {
-                // if (n % 2 != 0)
-                y = decMul(x, y);
-                x = decMul(x, x);
-                n = (n - 1) / 2;
-            }
-        }
-
-        return decMul(x, y);
-    }
-
     function _getAbsoluteDifference(
         uint256 _a,
         uint256 _b
diff --git a/solidity/contracts/interfaces/IBorrowerOperations.sol b/solidity/contracts/interfaces/IBorrowerOperations.sol
index 84158b9..1d0c3af 100644
--- a/solidity/contracts/interfaces/IBorrowerOperations.sol
+++ b/solidity/contracts/interfaces/IBorrowerOperations.sol
@@ -7,12 +7,18 @@ interface IBorrowerOperations {
     // --- Events ---
 
     event ActivePoolAddressChanged(address _activePoolAddress);
+    event BorrowerOperationsSignaturesAddressChanged(
+        address _borrowerOperationsSignaturesAddress
+    );
     event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
     event DefaultPoolAddressChanged(address _defaultPoolAddress);
     event GasPoolAddressChanged(address _gasPoolAddress);
     event MUSDTokenAddressChanged(address _musdTokenAddress);
+    event MinNetDebtChanged(uint256 _minNetDebt);
+    event MinNetDebtProposed(uint256 _minNetDebt, uint256 _proposalTime);
     event PCVAddressChanged(address _pcvAddress);
     event PriceFeedAddressChanged(address _newPriceFeedAddress);
+    event RefinancingFeePercentageChanged(uint8 _refinanceFeePercentage);
     event SortedTrovesAddressChanged(address _sortedTrovesAddress);
     event StabilityPoolAddressChanged(address _stabilityPoolAddress);
     event TroveManagerAddressChanged(address _newTroveManagerAddress);
@@ -33,6 +39,7 @@ interface IBorrowerOperations {
 
     function setAddresses(
         address _activePoolAddress,
+        address _borrowerOperationsSignaturesAddress,
         address _collSurplusPoolAddress,
         address _defaultPoolAddress,
         address _gasPoolAddress,
@@ -50,33 +57,27 @@ interface IBorrowerOperations {
     ) external;
 
     function openTrove(
-        uint256 _maxFeePercentage,
         uint256 _debtAmount,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable;
 
-    function openTroveWithSignature(
-        uint256 _maxFeePercentage,
-        uint256 _debtAmount,
-        uint256 _assetAmount,
-        address _upperHint,
-        address _lowerHint,
+    function restrictedOpenTrove(
         address _borrower,
-        bytes memory _signature,
-        uint256 _deadline
-    ) external payable;
-
-    function addColl(
-        uint256 _assetAmount,
+        address _recipient,
+        uint256 _debtAmount,
         address _upperHint,
         address _lowerHint
     ) external payable;
 
+    function proposeMinNetDebt(uint256 _minNetDebt) external;
+
+    function approveMinNetDebt() external;
+
+    function addColl(address _upperHint, address _lowerHint) external payable;
+
     function moveCollateralGainToTrove(
         address _borrower,
-        uint256 _assetAmount,
         address _upperHint,
         address _lowerHint
     ) external payable;
@@ -88,7 +89,6 @@ interface IBorrowerOperations {
     ) external;
 
     function withdrawMUSD(
-        uint256 _maxFeePercentage,
         uint256 _amount,
         address _upperHint,
         address _lowerHint
@@ -102,19 +102,41 @@ interface IBorrowerOperations {
 
     function closeTrove() external;
 
-    function refinance(uint256 _maxFeePercentage) external;
+    function restrictedCloseTrove(
+        address _borrower,
+        address _caller,
+        address _recipient
+    ) external;
+
+    function refinance() external;
+
+    function restrictedRefinance(address _borrower) external;
 
     function adjustTrove(
-        uint256 _maxFeePercentage,
         uint256 _collWithdrawal,
         uint256 _debtChange,
         bool _isDebtIncrease,
-        uint256 _assetAmount,
+        address _upperHint,
+        address _lowerHint
+    ) external payable;
+
+    function restrictedAdjustTrove(
+        address _borrower,
+        address _recipient,
+        address _caller,
+        uint256 _collWithdrawal,
+        uint256 _mUSDChange,
+        bool _isDebtIncrease,
         address _upperHint,
         address _lowerHint
     ) external payable;
 
     function claimCollateral() external;
 
-    function getCompositeDebt(uint256 _debt) external pure returns (uint);
+    function restrictedClaimCollateral(
+        address _borrower,
+        address _recipient
+    ) external;
+
+    function minNetDebt() external view returns (uint256);
 }
diff --git a/solidity/contracts/interfaces/IBorrowerOperationsSignatures.sol b/solidity/contracts/interfaces/IBorrowerOperationsSignatures.sol
new file mode 100644
index 0000000..01eaac4
--- /dev/null
+++ b/solidity/contracts/interfaces/IBorrowerOperationsSignatures.sol
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.24;
+
+interface IBorrowerOperationsSignatures {
+    function setAddresses(
+        address _borrowerOperationsAddress,
+        address _interestRateManagerAddress
+    ) external;
+
+    function addCollWithSignature(
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable;
+
+    function closeTroveWithSignature(
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function claimCollateralWithSignature(
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function adjustTroveWithSignature(
+        uint256 _collWithdrawal,
+        uint256 _debtChange,
+        bool _isDebtIncrease,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable;
+
+    function withdrawCollWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function openTroveWithSignature(
+        uint256 _debtAmount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external payable;
+
+    function withdrawMUSDWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        address _recipient,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function repayMUSDWithSignature(
+        uint256 _amount,
+        address _upperHint,
+        address _lowerHint,
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function refinanceWithSignature(
+        address _borrower,
+        bytes memory _signature,
+        uint256 _deadline
+    ) external;
+
+    function getNonce(address user) external view returns (uint256);
+}
diff --git a/solidity/contracts/interfaces/ICollSurplusPool.sol b/solidity/contracts/interfaces/ICollSurplusPool.sol
index f5c9917..cc72a07 100644
--- a/solidity/contracts/interfaces/ICollSurplusPool.sol
+++ b/solidity/contracts/interfaces/ICollSurplusPool.sol
@@ -24,7 +24,7 @@ interface ICollSurplusPool {
 
     function accountSurplus(address _account, uint256 _amount) external;
 
-    function claimColl(address _account) external;
+    function claimColl(address _account, address _recipient) external;
 
     function getCollateralBalance() external view returns (uint);
 
diff --git a/solidity/contracts/interfaces/IDefaultPool.sol b/solidity/contracts/interfaces/IDefaultPool.sol
index 2499617..fa33cfa 100644
--- a/solidity/contracts/interfaces/IDefaultPool.sol
+++ b/solidity/contracts/interfaces/IDefaultPool.sol
@@ -12,6 +12,4 @@ interface IDefaultPool is IPool {
 
     // --- Functions ---
     function sendCollateralToActivePool(uint256 _amount) external;
-
-    function getLastInterestUpdatedTime() external view returns (uint);
 }
diff --git a/solidity/contracts/interfaces/IInterestRateManager.sol b/solidity/contracts/interfaces/IInterestRateManager.sol
index 8b53cb0..39d0d47 100644
--- a/solidity/contracts/interfaces/IInterestRateManager.sol
+++ b/solidity/contracts/interfaces/IInterestRateManager.sol
@@ -17,7 +17,7 @@ interface IInterestRateManager {
 
     event InterestRateProposed(uint16 proposedRate, uint256 proposalTime);
     event InterestRateUpdated(uint16 newInterestRate);
-    event MaxInterestRateUpdated(uint16 newMaxInterestRate);
+    event InterestNumeratorChanged(uint256 _newNumerator);
 
     function setAddresses(
         address _activePoolAddress,
@@ -31,17 +31,11 @@ interface IInterestRateManager {
 
     function approveInterestRate() external;
 
-    function setMaxInterestRate(uint16 _newMaxInterestRate) external;
+    function addPrincipal(uint256 _principal, uint16 _rate) external;
 
-    function addPrincipalToRate(uint16 _rate, uint256 _principal) external;
+    function removePrincipal(uint256 _principal, uint16 _rate) external;
 
-    function addInterestToRate(uint16 _rate, uint256 _interest) external;
-
-    function removePrincipalFromRate(uint16 _rate, uint256 _principal) external;
-
-    function removeInterestFromRate(uint16 _rate, uint256 _interest) external;
-
-    function updateSystemInterest(uint16 _rate) external;
+    function updateSystemInterest() external;
 
     function updateTroveDebt(
         uint256 _interestOwed,
@@ -51,24 +45,7 @@ interface IInterestRateManager {
         external
         returns (uint256 principalAdjustment, uint256 interestAdjustment);
 
-    function interestRate() external view returns (uint16);
-
-    function getInterestRateData(
-        uint16 _rate
-    ) external view returns (InterestRateInfo memory);
-
-    function calculateDebtAdjustment(
-        uint256 _interestOwed,
-        uint256 _payment
-    )
-        external
-        pure
-        returns (uint256 principalAdjustment, uint256 interestAdjustment);
+    function getAccruedInterest() external view returns (uint256);
 
-    function calculateInterestOwed(
-        uint256 _principal,
-        uint16 _interestRate,
-        uint256 startTime,
-        uint256 endTime
-    ) external pure returns (uint256);
+    function interestRate() external view returns (uint16);
 }
diff --git a/solidity/contracts/interfaces/IPCV.sol b/solidity/contracts/interfaces/IPCV.sol
index 1ff27d1..11d3398 100644
--- a/solidity/contracts/interfaces/IPCV.sol
+++ b/solidity/contracts/interfaces/IPCV.sol
@@ -7,29 +7,37 @@ import "../token/IMUSD.sol";
 
 interface IPCV {
     // --- Events --
-    event MUSDTokenAddressSet(address _musdTokenAddress);
     event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);
-
+    event MUSDTokenAddressSet(address _musdTokenAddress);
     event RolesSet(address _council, address _treasury);
-    event MUSDWithdraw(address _recipient, uint256 _amount);
+
     event CollateralWithdraw(address _recipient, uint256 _collateralAmount);
-    event PCVDebtPaid(uint256 _paidDebt);
+    event FeeRecipientSet(address _feeRecipient);
+    event FeeSplitSet(uint8 _feeSplitPercentage);
+    event MUSDWithdraw(address _recipient, uint256 _amount);
+    event PCVDebtPayment(uint256 _paidDebt);
+    event PCVDepositSP(address indexed user, uint256 musdAmount);
+    event PCVDistribution(address _recipient, uint256 _amount);
+    event PCVWithdrawSP(
+        address indexed user,
+        uint256 musdAmount,
+        uint256 collateralAmount
+    );
     event RecipientAdded(address _recipient);
     event RecipientRemoved(address _recipient);
-    event PCVFeePaid(address _recipient, uint256 _amount);
 
     // --- Functions ---
 
     function debtToPay() external returns (uint256);
 
-    function payDebt(uint256 _musdToBurn) external;
+    function distributeMUSD(uint256 _musdToBurn) external;
 
     function setAddresses(
         address _borrowerOperations,
         address _musdTokenAddress
     ) external;
 
-    function initialize() external;
+    function initializeDebt() external;
 
     function setFeeRecipient(address _feeRecipient) external;
 
diff --git a/solidity/contracts/interfaces/IStabilityPool.sol b/solidity/contracts/interfaces/IStabilityPool.sol
index fff4581..1580f4f 100644
--- a/solidity/contracts/interfaces/IStabilityPool.sol
+++ b/solidity/contracts/interfaces/IStabilityPool.sol
@@ -115,7 +115,11 @@ interface IStabilityPool {
      * and transfers the Trove's collateral from ActivePool to StabilityPool.
      * Only called by liquidation functions in the TroveManager.
      */
-    function offset(uint256 _debt, uint256 _coll) external;
+    function offset(
+        uint256 _principal,
+        uint256 _interest,
+        uint256 _coll
+    ) external;
 
     /*
      * Returns the total amount of collateral held by the pool, accounted in an internal variable instead of `balance`,
diff --git a/solidity/contracts/interfaces/ITroveManager.sol b/solidity/contracts/interfaces/ITroveManager.sol
index 1388338..e3028e0 100644
--- a/solidity/contracts/interfaces/ITroveManager.sol
+++ b/solidity/contracts/interfaces/ITroveManager.sol
@@ -66,7 +66,6 @@ interface ITroveManager {
         uint8 operation
     );
     event BaseRateUpdated(uint256 _baseRate);
-    event LastFeeOpTimeUpdated(uint256 _lastFeeOpTime);
     event TotalStakesUpdated(uint256 _newTotalStakes);
     event SystemSnapshotsUpdated(
         uint256 _totalStakesSnapshot,
@@ -110,8 +109,7 @@ interface ITroveManager {
         address _upperPartialRedemptionHint,
         address _lowerPartialRedemptionHint,
         uint256 _partialRedemptionHintNICR,
-        uint256 _maxIterations,
-        uint256 _maxFeePercentage
+        uint256 _maxIterations
     ) external;
 
     function updateStakeAndTotalStakes(
@@ -130,8 +128,6 @@ interface ITroveManager {
 
     function removeStake(address _borrower) external;
 
-    function decayBaseRateFromBorrowing() external;
-
     function setTroveStatus(address _borrower, Status _status) external;
 
     function setTroveMaxBorrowingCapacity(
@@ -139,7 +135,7 @@ interface ITroveManager {
         uint256 _maxBorrowingCapacity
     ) external;
 
-    function updateDefaultPoolInterest() external;
+    function updateSystemInterest() external;
 
     function updateSystemAndTroveInterest(address _borrower) external;
 
@@ -217,24 +213,6 @@ interface ITroveManager {
             uint256 pendingInterest
         );
 
-    function getRedemptionRate() external view returns (uint);
-
-    function getRedemptionRateWithDecay() external view returns (uint);
-
-    function getRedemptionFeeWithDecay(
-        uint256 _collateralDrawn
-    ) external view returns (uint);
-
-    function getBorrowingRate() external view returns (uint);
-
-    function getBorrowingRateWithDecay() external view returns (uint);
-
-    function getBorrowingFee(uint256 _debt) external view returns (uint);
-
-    function getBorrowingFeeWithDecay(
-        uint256 _debt
-    ) external view returns (uint);
-
     function getTroveStatus(address _borrower) external view returns (Status);
 
     function getTroveStake(address _borrower) external view returns (uint);
@@ -253,5 +231,11 @@ interface ITroveManager {
 
     function getTCR(uint256 _price) external view returns (uint);
 
+    function getTroveMaxBorrowingCapacity(
+        address _borrower
+    ) external view returns (uint256);
+
     function checkRecoveryMode(uint256 _price) external view returns (bool);
+
+    function getBorrowingFee(uint256 _debt) external pure returns (uint);
 }
diff --git a/solidity/contracts/tests/MUSDTester.sol b/solidity/contracts/tests/MUSDTester.sol
index 2735b6c..03d5d56 100644
--- a/solidity/contracts/tests/MUSDTester.sol
+++ b/solidity/contracts/tests/MUSDTester.sol
@@ -42,4 +42,24 @@ contract MUSDTester is MUSD {
     ) external {
         _approve(owner, spender, amount);
     }
+
+    function getPendingRevokedBurnAddressesLength()
+        external
+        view
+        returns (uint)
+    {
+        return pendingRevokedBurnAddresses.length;
+    }
+
+    function getPendingAddedMintAddressesLength() external view returns (uint) {
+        return pendingAddedMintAddresses.length;
+    }
+
+    function getPendingRevokedMintAddressesLength()
+        external
+        view
+        returns (uint)
+    {
+        return pendingRevokedMintAddresses.length;
+    }
 }
diff --git a/solidity/contracts/tests/MockAggregator.sol b/solidity/contracts/tests/MockAggregator.sol
index 82e1d10..3e92ae4 100644
--- a/solidity/contracts/tests/MockAggregator.sol
+++ b/solidity/contracts/tests/MockAggregator.sol
@@ -8,6 +8,7 @@ import "@openzeppelin/contracts/access/Ownable.sol";
 contract MockAggregator is ChainlinkAggregatorV3Interface, Ownable {
     uint256 private _price;
     uint8 private precision;
+    uint256 private blockTime;
 
     constructor(uint8 _decimals) Ownable(msg.sender) {
         precision = _decimals;
@@ -33,20 +34,24 @@ contract MockAggregator is ChainlinkAggregatorV3Interface, Ownable {
         return true;
     }
 
+    function setBlockTime(uint256 _blockTime) external onlyOwner {
+        // slither-disable-next-line events-maths
+        blockTime = _blockTime;
+    }
+
     function latestRoundData()
         external
         view
-        returns (
-            uint80 roundId,
-            int256 answer,
-            uint256 startedAt,
-            uint256 updatedAt,
-            uint80 answeredInRound
-        )
+        returns (uint80, int256, uint256, uint256, uint80)
     {
         require(precision <= 77, "Decimals too large"); // Prevent overflow
-
-        return (0, int256(_price), 0, 0, 0);
+        uint256 updatedAt = blockTime;
+        if (updatedAt == 0) {
+            // solhint-disable-next-line not-rely-on-time
+            updatedAt = block.timestamp;
+        }
+        int256 answer = int256(_price);
+        return (0, answer, updatedAt, updatedAt, 0);
     }
 
     function decimals() public view returns (uint8) {
diff --git a/solidity/contracts/tests/PriceFeedUpgradeTester.sol b/solidity/contracts/tests/PriceFeedUpgradeTester.sol
new file mode 100644
index 0000000..c59ad5d
--- /dev/null
+++ b/solidity/contracts/tests/PriceFeedUpgradeTester.sol
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.24;
+
+import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
+import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
+
+import "../interfaces/ChainlinkAggregatorV3Interface.sol";
+import "../interfaces/IPriceFeed.sol";
+
+contract PriceFeedUpgradeTester is
+    IPriceFeed,
+    Initializable,
+    Ownable2StepUpgradeable
+{
+    // slither-disable-next-line constable-states
+    ChainlinkAggregatorV3Interface public oracle;
+
+    // slither-disable-next-line unused-state
+    uint256[50] private __gap;
+
+    function initialize(address _owner) external virtual initializer {
+        __Ownable_init(_owner);
+    }
+
+    function setOracle(address _oracle) external onlyOwner {}
+
+    function fetchPrice() public view virtual returns (uint256) {
+        return 45000e18;
+    }
+}
diff --git a/solidity/contracts/tests/TroveManagerTester.sol b/solidity/contracts/tests/TroveManagerTester.sol
index e647d6b..e08e973 100644
--- a/solidity/contracts/tests/TroveManagerTester.sol
+++ b/solidity/contracts/tests/TroveManagerTester.sol
@@ -8,17 +8,8 @@ import "../TroveManager.sol";
 for testing the parent's internal functions. */
 
 contract TroveManagerTester is TroveManager {
-    function setLastFeeOpTimeToNow() external {
-        // solhint-disable-next-line not-rely-on-time
-        lastFeeOperationTime = block.timestamp;
-    }
-
-    function setBaseRate(uint256 _baseRate) external {
-        baseRate = _baseRate;
-    }
-
-    function callUpdateDefaultPoolInterest() external {
-        updateDefaultPoolInterest();
+    function getCompositeDebt(uint256 _debt) external pure returns (uint) {
+        return _getCompositeDebt(_debt);
     }
 
     function computeICR(
@@ -29,11 +20,18 @@ contract TroveManagerTester is TroveManager {
         return LiquityMath._computeCR(_coll, _debt, _price);
     }
 
-    function getMUSDGasCompensation() external pure returns (uint) {
-        return MUSD_GAS_COMPENSATION;
-    }
-
-    function getCompositeDebt(uint256 _debt) external pure returns (uint) {
-        return _getCompositeDebt(_debt);
+    function calculateInterestOwed(
+        uint256 _principal,
+        uint16 _interestRate,
+        uint256 startTime,
+        uint256 endTime
+    ) external pure returns (uint256) {
+        return
+            InterestRateMath.calculateInterestOwed(
+                _principal,
+                _interestRate,
+                startTime,
+                endTime
+            );
     }
 }
diff --git a/solidity/contracts/token/IMUSD.sol b/solidity/contracts/token/IMUSD.sol
index 02c316c..29849c2 100644
--- a/solidity/contracts/token/IMUSD.sol
+++ b/solidity/contracts/token/IMUSD.sol
@@ -29,11 +29,11 @@ interface IMUSD is IERC20Metadata, IERC20Permit {
         address _interestRateManagerAddress
     ) external;
 
-    function startAddMintList(address _account) external;
+    function startAddMintList(address[] calldata _accounts) external;
 
-    function startRevokeBurnList(address _account) external;
+    function startRevokeBurnList(address[] calldata _accounts) external;
 
-    function startRevokeMintList(address _account) external;
+    function startRevokeMintList(address[] calldata _accounts) external;
 
     function finalizeAddContracts() external;
 
diff --git a/solidity/contracts/token/MUSD.sol b/solidity/contracts/token/MUSD.sol
index a2a3536..6355e94 100644
--- a/solidity/contracts/token/MUSD.sol
+++ b/solidity/contracts/token/MUSD.sol
@@ -20,9 +20,9 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
     address public pendingBorrowerOperations;
     address public pendingInterestRateManager;
 
-    address public pendingRevokedMintAddress;
-    address public pendingRevokedBurnAddress;
-    address public pendingAddedMintAddress;
+    address[] public pendingRevokedMintAddresses;
+    address[] public pendingRevokedBurnAddresses;
+    address[] public pendingAddedMintAddresses;
 
     uint256 public revokeMintListInitiated;
     uint256 public revokeBurnListInitiated;
@@ -62,12 +62,17 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
 
     // --- Governance ---
 
-    function startRevokeMintList(address _account) external onlyOwner {
-        require(mintList[_account], "Incorrect address to revoke");
+    function startRevokeMintList(
+        address[] calldata _accounts
+    ) external onlyOwner {
+        uint accountsLength = _accounts.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            require(mintList[_accounts[i]], "Incorrect address to revoke");
+        }
 
         // solhint-disable-next-line not-rely-on-time
         revokeMintListInitiated = block.timestamp;
-        pendingRevokedMintAddress = _account;
+        pendingRevokedMintAddresses = _accounts;
     }
 
     function cancelRevokeMintList() external onlyOwner {
@@ -77,7 +82,7 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         );
 
         revokeMintListInitiated = 0;
-        pendingRevokedMintAddress = address(0);
+        pendingRevokedMintAddresses = new address[](0);
     }
 
     function finalizeRevokeMintList()
@@ -85,17 +90,23 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         onlyOwner
         onlyAfterGovernanceDelay(revokeMintListInitiated)
     {
-        mintList[pendingRevokedMintAddress] = false;
+        uint accountsLength = pendingRevokedMintAddresses.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            mintList[pendingRevokedMintAddresses[i]] = false;
+        }
         revokeMintListInitiated = 0;
-        pendingRevokedMintAddress = address(0);
+        pendingRevokedMintAddresses = new address[](0);
     }
 
-    function startAddMintList(address _account) external onlyOwner {
-        require(!mintList[_account], "Incorrect address to add");
+    function startAddMintList(address[] calldata _accounts) external onlyOwner {
+        uint accountsLength = _accounts.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            require(!mintList[_accounts[i]], "Incorrect address to add");
+        }
 
         // solhint-disable-next-line not-rely-on-time
         addMintListInitiated = block.timestamp;
-        pendingAddedMintAddress = _account;
+        pendingAddedMintAddresses = _accounts;
     }
 
     function cancelAddMintList() external onlyOwner {
@@ -105,7 +116,7 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         );
 
         addMintListInitiated = 0;
-        pendingAddedMintAddress = address(0);
+        pendingAddedMintAddresses = new address[](0);
     }
 
     function finalizeAddMintList()
@@ -113,9 +124,12 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         onlyOwner
         onlyAfterGovernanceDelay(addMintListInitiated)
     {
-        mintList[pendingAddedMintAddress] = true;
+        uint accountsLength = pendingAddedMintAddresses.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            mintList[pendingAddedMintAddresses[i]] = true;
+        }
         addMintListInitiated = 0;
-        pendingAddedMintAddress = address(0);
+        pendingAddedMintAddresses = new address[](0);
     }
 
     function startAddContracts(
@@ -172,12 +186,18 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         pendingInterestRateManager = address(0);
     }
 
-    function startRevokeBurnList(address _account) external onlyOwner {
-        require(burnList[_account], "Incorrect address to revoke");
+    function startRevokeBurnList(
+        address[] calldata _accounts
+    ) external onlyOwner {
+        uint accountsLength = _accounts.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            address account = _accounts[i];
+
+            require(burnList[account], "Incorrect address to revoke");
+        }
 
-        // solhint-disable-next-line not-rely-on-time
         revokeBurnListInitiated = block.timestamp;
-        pendingRevokedBurnAddress = _account;
+        pendingRevokedBurnAddresses = _accounts;
     }
 
     function cancelRevokeBurnList() external onlyOwner {
@@ -187,7 +207,7 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         );
 
         revokeBurnListInitiated = 0;
-        pendingRevokedBurnAddress = address(0);
+        pendingRevokedBurnAddresses = new address[](0);
     }
 
     function finalizeRevokeBurnList()
@@ -195,9 +215,14 @@ contract MUSD is ERC20Permit, Ownable, CheckContract, IMUSD {
         onlyOwner
         onlyAfterGovernanceDelay(revokeBurnListInitiated)
     {
-        burnList[pendingRevokedBurnAddress] = false;
+        uint accountsLength = pendingRevokedBurnAddresses.length;
+        for (uint i = 0; i < accountsLength; i++) {
+            address account = pendingRevokedBurnAddresses[i];
+
+            burnList[account] = false;
+        }
         revokeBurnListInitiated = 0;
-        pendingRevokedBurnAddress = address(0);
+        pendingRevokedBurnAddresses = new address[](0);
     }
 
     // --- Functions for intra-Liquity calls ---
diff --git a/solidity/deploy/02_deploy_interest_rate_manager.ts b/solidity/deploy/02_deploy_interest_rate_manager.ts
index 2579765..827ff76 100644
--- a/solidity/deploy/02_deploy_interest_rate_manager.ts
+++ b/solidity/deploy/02_deploy_interest_rate_manager.ts
@@ -3,9 +3,9 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
 
-  await getOrDeploy("InterestRateManager")
+  await getOrDeployProxy("InterestRateManager")
 }
 
 export default func
diff --git a/solidity/deploy/03_deploy_borrower_operations.ts b/solidity/deploy/03_deploy_borrower_operations.ts
index 8e6db8c..f923c81 100644
--- a/solidity/deploy/03_deploy_borrower_operations.ts
+++ b/solidity/deploy/03_deploy_borrower_operations.ts
@@ -3,8 +3,18 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("BorrowerOperations")
+  const { getOrDeployProxy, isHardhatNetwork } =
+    await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("BorrowerOperations")
+
+  // The MUSD tests want another BorrowerOperations contract for testing
+  // upgrades. So, we deploy one named "NewBorrowerOperationsTroves" to use in
+  // those tests, but only in hardhat.
+  if (isHardhatNetwork) {
+    await getOrDeployProxy("NewBorrowerOperations", {
+      contractName: "BorrowerOperations",
+    })
+  }
 }
 
 export default func
diff --git a/solidity/deploy/04_deploy_trove_manager.ts b/solidity/deploy/04_deploy_trove_manager.ts
index 93f7d98..ad14d9c 100644
--- a/solidity/deploy/04_deploy_trove_manager.ts
+++ b/solidity/deploy/04_deploy_trove_manager.ts
@@ -3,10 +3,12 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy, isHardhatNetwork } =
+  const { getOrDeployProxy, isHardhatNetwork } =
     await setupDeploymentBoilerplate(hre)
 
-  await getOrDeploy(isHardhatNetwork ? "TroveManagerTester" : "TroveManager")
+  await getOrDeployProxy(
+    isHardhatNetwork ? "TroveManagerTester" : "TroveManager",
+  )
 }
 
 export default func
diff --git a/solidity/deploy/05_deploy_stability_pool.ts b/solidity/deploy/05_deploy_stability_pool.ts
index 218814b..13bd422 100644
--- a/solidity/deploy/05_deploy_stability_pool.ts
+++ b/solidity/deploy/05_deploy_stability_pool.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("StabilityPool")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("StabilityPool")
 }
 
 export default func
diff --git a/solidity/deploy/08_deploy_coll_surplus_pool.ts b/solidity/deploy/08_deploy_coll_surplus_pool.ts
index c7e2ef5..ed4b002 100644
--- a/solidity/deploy/08_deploy_coll_surplus_pool.ts
+++ b/solidity/deploy/08_deploy_coll_surplus_pool.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("CollSurplusPool")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("CollSurplusPool")
 }
 
 export default func
diff --git a/solidity/deploy/09_deploy_active_pool.ts b/solidity/deploy/09_deploy_active_pool.ts
index 80fb063..e12b08a 100644
--- a/solidity/deploy/09_deploy_active_pool.ts
+++ b/solidity/deploy/09_deploy_active_pool.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("ActivePool")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("ActivePool")
 }
 
 export default func
diff --git a/solidity/deploy/10_deploy_default_pool.ts b/solidity/deploy/10_deploy_default_pool.ts
index e60e185..b5063b4 100644
--- a/solidity/deploy/10_deploy_default_pool.ts
+++ b/solidity/deploy/10_deploy_default_pool.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("DefaultPool")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("DefaultPool")
 }
 
 export default func
diff --git a/solidity/deploy/11_deploy_pcv.ts b/solidity/deploy/11_deploy_pcv.ts
index e2c7c42..8c86ac7 100644
--- a/solidity/deploy/11_deploy_pcv.ts
+++ b/solidity/deploy/11_deploy_pcv.ts
@@ -3,8 +3,10 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("PCV", { args: [7200] })
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("PCV", {
+    initializerArgs: [7200],
+  })
 }
 
 export default func
diff --git a/solidity/deploy/12_deploy_sorted_troves.ts b/solidity/deploy/12_deploy_sorted_troves.ts
index 4d9de13..ff0c0f3 100644
--- a/solidity/deploy/12_deploy_sorted_troves.ts
+++ b/solidity/deploy/12_deploy_sorted_troves.ts
@@ -3,8 +3,9 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("SortedTroves")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+
+  await getOrDeployProxy("SortedTroves")
 }
 
 export default func
diff --git a/solidity/deploy/13_deploy_gas_pool.ts b/solidity/deploy/13_deploy_gas_pool.ts
index baf450c..31d2e4f 100644
--- a/solidity/deploy/13_deploy_gas_pool.ts
+++ b/solidity/deploy/13_deploy_gas_pool.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("GasPool")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("GasPool")
 }
 
 export default func
diff --git a/solidity/deploy/14_deploy_price_feed.ts b/solidity/deploy/14_deploy_price_feed.ts
index 9b5f79d..4d41485 100644
--- a/solidity/deploy/14_deploy_price_feed.ts
+++ b/solidity/deploy/14_deploy_price_feed.ts
@@ -3,14 +3,14 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { deploy, getOrDeploy, isHardhatNetwork } =
+  const { deployProxy, getOrDeployProxy, isHardhatNetwork } =
     await setupDeploymentBoilerplate(hre)
 
-  await getOrDeploy("PriceFeed")
+  await getOrDeployProxy("PriceFeed")
 
   if (isHardhatNetwork) {
-    await deploy("UnconnectedPriceFeed", {
-      contract: "PriceFeed",
+    await deployProxy("UnconnectedPriceFeed", {
+      contractName: "PriceFeed",
     })
   }
 }
diff --git a/solidity/deploy/15_deploy_hint_helpers.ts b/solidity/deploy/15_deploy_hint_helpers.ts
index 42edc9f..7935e4b 100644
--- a/solidity/deploy/15_deploy_hint_helpers.ts
+++ b/solidity/deploy/15_deploy_hint_helpers.ts
@@ -3,8 +3,8 @@ import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { getOrDeploy } = await setupDeploymentBoilerplate(hre)
-  await getOrDeploy("HintHelpers")
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("HintHelpers")
 }
 
 export default func
diff --git a/solidity/deploy/17_deploy_borrower_operations_signatures.ts b/solidity/deploy/17_deploy_borrower_operations_signatures.ts
new file mode 100644
index 0000000..432d0b4
--- /dev/null
+++ b/solidity/deploy/17_deploy_borrower_operations_signatures.ts
@@ -0,0 +1,12 @@
+import { DeployFunction } from "hardhat-deploy/dist/types"
+import { HardhatRuntimeEnvironment } from "hardhat/types"
+import { setupDeploymentBoilerplate } from "../helpers/deploy-helpers"
+
+const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
+  const { getOrDeployProxy } = await setupDeploymentBoilerplate(hre)
+  await getOrDeployProxy("BorrowerOperationsSignatures")
+}
+
+export default func
+
+func.tags = ["BorrowerOperationsSignatures"]
diff --git a/solidity/deploy/87_set_borrower_operations_signatures_addresses.ts b/solidity/deploy/87_set_borrower_operations_signatures_addresses.ts
new file mode 100644
index 0000000..87063f4
--- /dev/null
+++ b/solidity/deploy/87_set_borrower_operations_signatures_addresses.ts
@@ -0,0 +1,29 @@
+import { DeployFunction } from "hardhat-deploy/dist/types"
+import { HardhatRuntimeEnvironment } from "hardhat/types"
+import {
+  fetchAllDeployedContracts,
+  setupDeploymentBoilerplate,
+} from "../helpers/deploy-helpers"
+
+const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
+  const { execute, isHardhatNetwork } = await setupDeploymentBoilerplate(hre)
+
+  const { borrowerOperations, interestRateManager } =
+    await fetchAllDeployedContracts(isHardhatNetwork)
+
+  await execute(
+    "BorrowerOperationsSignatures",
+    "setAddresses",
+    await borrowerOperations.getAddress(),
+    await interestRateManager.getAddress(),
+  )
+}
+
+export default func
+
+func.tags = ["SetAddresses", "SetBorrowerOperationsSignatures"]
+func.dependencies = [
+  "BorrowerOperations",
+  "BorrowerOperationsSignatures",
+  "InterestRateManager",
+]
diff --git a/solidity/deploy/88_set_price_feed_oracle.ts b/solidity/deploy/88_set_price_feed_oracle.ts
index f338a0b..873baee 100644
--- a/solidity/deploy/88_set_price_feed_oracle.ts
+++ b/solidity/deploy/88_set_price_feed_oracle.ts
@@ -1,15 +1,26 @@
 import { DeployFunction } from "hardhat-deploy/dist/types"
 import { HardhatRuntimeEnvironment } from "hardhat/types"
 import {
+  EXTERNAL_ADDRESSES,
   fetchAllDeployedContracts,
   setupDeploymentBoilerplate,
 } from "../helpers/deploy-helpers"
 
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
-  const { execute, isHardhatNetwork } = await setupDeploymentBoilerplate(hre)
-  const { mockAggregator } = await fetchAllDeployedContracts(isHardhatNetwork)
+  const { execute, isHardhatNetwork, network } =
+    await setupDeploymentBoilerplate(hre)
 
-  await execute("PriceFeed", "setOracle", await mockAggregator.getAddress())
+  let aggregatorAddress
+  if (isHardhatNetwork) {
+    const { mockAggregator } = await fetchAllDeployedContracts(isHardhatNetwork)
+    aggregatorAddress = await mockAggregator.getAddress()
+  } else if (network.name in EXTERNAL_ADDRESSES) {
+    aggregatorAddress = EXTERNAL_ADDRESSES[network.name].PriceOracleCaller
+  } else {
+    throw Error(`${network.name} does not have a PriceOracleCaller set`)
+  }
+
+  await execute("PriceFeed", "setOracle", aggregatorAddress)
 }
 
 export default func
diff --git a/solidity/deploy/91_set_hint_helpers_addresses.ts b/solidity/deploy/91_set_hint_helpers_addresses.ts
index cc53e42..a0400fe 100644
--- a/solidity/deploy/91_set_hint_helpers_addresses.ts
+++ b/solidity/deploy/91_set_hint_helpers_addresses.ts
@@ -8,12 +8,13 @@ import {
 const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
   const { execute, isHardhatNetwork } = await setupDeploymentBoilerplate(hre)
 
-  const { sortedTroves, troveManager } =
+  const { borrowerOperations, sortedTroves, troveManager } =
     await fetchAllDeployedContracts(isHardhatNetwork)
 
   await execute(
     "HintHelpers",
     "setAddresses",
+    await borrowerOperations.getAddress(),
     await sortedTroves.getAddress(),
     await troveManager.getAddress(),
   )
@@ -22,4 +23,9 @@ const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
 export default func
 
 func.tags = ["SetAddresses", "SetHintHelpersAddresses"]
-func.dependencies = ["HintHelpers", "SortedTroves", "TroveManager"]
+func.dependencies = [
+  "BorrowerOperations",
+  "HintHelpers",
+  "SortedTroves",
+  "TroveManager",
+]
diff --git a/solidity/deploy/95_set_borrower_operations_addresses.ts b/solidity/deploy/95_set_borrower_operations_addresses.ts
index 45a7e89..b6b4464 100644
--- a/solidity/deploy/95_set_borrower_operations_addresses.ts
+++ b/solidity/deploy/95_set_borrower_operations_addresses.ts
@@ -10,6 +10,7 @@ const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
 
   const {
     activePool,
+    borrowerOperationsSignatures,
     collSurplusPool,
     defaultPool,
     gasPool,
@@ -26,6 +27,7 @@ const func: DeployFunction = async (hre: HardhatRuntimeEnvironment) => {
     "BorrowerOperations",
     "setAddresses",
     await activePool.getAddress(),
+    await borrowerOperationsSignatures.getAddress(),
     await collSurplusPool.getAddress(),
     await defaultPool.getAddress(),
     await gasPool.getAddress(),
diff --git a/solidity/hardhat.config.ts b/solidity/hardhat.config.ts
index 7ee458a..917674a 100644
--- a/solidity/hardhat.config.ts
+++ b/solidity/hardhat.config.ts
@@ -13,26 +13,15 @@ dotenv.config({
   example: process.env.CI ? ".env.ci.example" : ".env.example",
 })
 
-const MAINNET_RPC_URL = process.env.MAINNET_RPC_URL
-  ? process.env.MAINNET_RPC_URL
-  : ""
-
-const MAINNET_PRIVATE_KEY = process.env.MAINNET_PRIVATE_KEY
-  ? [process.env.MAINNET_PRIVATE_KEY]
-  : []
-
-const SEPOLIA_RPC_URL = process.env.SEPOLIA_RPC_URL
-  ? process.env.SEPOLIA_RPC_URL
-  : ""
-
-const SEPOLIA_PRIVATE_KEY = process.env.SEPOLIA_PRIVATE_KEY
-  ? [process.env.SEPOLIA_PRIVATE_KEY]
+const MATSNET_PRIVATE_KEY = process.env.MATSNET_PRIVATE_KEY
+  ? [process.env.MATSNET_PRIVATE_KEY]
   : []
 
 const config: HardhatUserConfig = {
   solidity: {
     version: "0.8.24",
     settings: {
+      evmVersion: "london",
       optimizer: {
         enabled: true,
         runs: 100,
@@ -43,22 +32,11 @@ const config: HardhatUserConfig = {
     outDir: "typechain",
   },
   networks: {
-    mainnet: {
-      url: MAINNET_RPC_URL,
-      accounts: MAINNET_PRIVATE_KEY,
-      chainId: 1,
-      tags: ["etherscan"],
-    },
-    sepolia: {
-      url: SEPOLIA_RPC_URL,
-      accounts: SEPOLIA_PRIVATE_KEY,
-      chainId: 11155111,
-      tags: ["allowStubs", "etherscan"],
-    },
     matsnet: {
       url: "https://rpc.test.mezo.org",
       chainId: 31611,
-      accounts: SEPOLIA_PRIVATE_KEY,
+      accounts: MATSNET_PRIVATE_KEY,
+      tags: ["allowStubs", "etherscan"],
     },
     hardhat: {
       initialBaseFeePerGas: 0,
diff --git a/solidity/helpers/deploy-helpers.ts b/solidity/helpers/deploy-helpers.ts
index e7bc818..3928cbb 100644
--- a/solidity/helpers/deploy-helpers.ts
+++ b/solidity/helpers/deploy-helpers.ts
@@ -1,10 +1,12 @@
 import { HardhatRuntimeEnvironment } from "hardhat/types"
 import { Deployment, DeployOptions } from "hardhat-deploy/types"
+import { UpgradesDeployOptions } from "@keep-network/hardhat-helpers/src/upgrades"
 import { deployments, ethers, helpers } from "hardhat"
 import type { BaseContract } from "ethers"
 import {
   ActivePool,
   BorrowerOperations,
+  BorrowerOperationsSignatures,
   CollSurplusPool,
   DefaultPool,
   GasPool,
@@ -28,6 +30,18 @@ function waitConfirmationsNumber(networkName: string): number {
   }
 }
 
+type ExternalAddresses = {
+  [networkName: string]: {
+    PriceOracleCaller: string
+  }
+}
+
+export const EXTERNAL_ADDRESSES: ExternalAddresses = {
+  matsnet: {
+    PriceOracleCaller: "0x7b7c000000000000000000000000000000000015",
+  },
+}
+
 export default async function waitForTransaction(
   hre: HardhatRuntimeEnvironment,
   txHash: string,
@@ -79,6 +93,9 @@ export async function fetchAllDeployedContracts(isHardhatNetwork: boolean) {
   const borrowerOperations: BorrowerOperations =
     await getDeployedContract("BorrowerOperations")
 
+  const borrowerOperationsSignatures: BorrowerOperationsSignatures =
+    await getDeployedContract("BorrowerOperationsSignatures")
+
   const collSurplusPool: CollSurplusPool =
     await getDeployedContract("CollSurplusPool")
 
@@ -113,6 +130,7 @@ export async function fetchAllDeployedContracts(isHardhatNetwork: boolean) {
   return {
     activePool,
     borrowerOperations,
+    borrowerOperationsSignatures,
     collSurplusPool,
     defaultPool,
     gasPool,
@@ -156,24 +174,62 @@ export async function setupDeploymentBoilerplate(
     return deployments.deploy(name, { ...defaultDeployOptions, ...options })
   }
 
+  const defaultProxyDeployOptions: UpgradesDeployOptions = {
+    factoryOpts: { signer: deployer },
+    initializerArgs: [],
+    proxyOpts: {
+      kind: "transparent",
+      initialOwner: deployer.address,
+      unsafeAllow: ["external-library-linking"],
+    },
+  }
+
+  const deployProxy = (name: string, options: UpgradesDeployOptions = {}) => {
+    log(`Deploying ${name} contract...`)
+    return helpers.upgrades.deployProxy(name, {
+      ...defaultProxyDeployOptions,
+      ...options,
+    })
+  }
+
   const getOrDeploy = async (
     contractName: string,
     options: PartialDeployOptions = {},
+  ): Promise<Deployment> => {
+    const deployment = await getValidDeployment(contractName)
+    if (deployment) {
+      log(`Using ${contractName} at ${deployment.address}`)
+      return deployment
+    }
+
+    const contract = await deploy(contractName, {
+      contract: contractName,
+      args: [],
+      ...options,
+    })
+
+    if (network.name !== "hardhat") {
+      await helpers.etherscan.verify(contract)
+    }
+    return contract
+  }
+
+  const getOrDeployProxy = async (
+    contractName: string,
+    options: UpgradesDeployOptions = {},
   ) => {
     const deployment = await getValidDeployment(contractName)
     if (deployment) {
       log(`Using ${contractName} at ${deployment.address}`)
-    } else {
-      const contract = await deploy(contractName, {
-        contract: contractName,
-        args: [],
-        ...options,
-      })
-
-      if (network.name !== "hardhat") {
-        await helpers.etherscan.verify(contract)
-      }
+      return deployment
+    }
+
+    const [_, contract] = await deployProxy(contractName, options)
+
+    if (network.name !== "hardhat") {
+      await helpers.etherscan.verify(contract)
     }
+    return contract
   }
 
   const execute = (
@@ -196,10 +252,12 @@ export async function setupDeploymentBoilerplate(
 
   return {
     deploy,
+    deployProxy,
     deployer,
     deployments,
     execute,
     getOrDeploy,
+    getOrDeployProxy,
     getValidDeployment,
     isHardhatNetwork: network.name === "hardhat",
     log,
diff --git a/solidity/test/MUSD.test.ts b/solidity/test/MUSD.test.ts
index 2886001..41825fc 100644
--- a/solidity/test/MUSD.test.ts
+++ b/solidity/test/MUSD.test.ts
@@ -5,6 +5,7 @@ import {
   TestingAddresses,
   User,
   fastForwardTime,
+  getDeployedContract,
   getLatestBlockTimestamp,
   setupTests,
 } from "./helpers"
@@ -34,10 +35,8 @@ describe("MUSD", () => {
     ;({ alice, bob, carol, dennis, deployer, contracts, addresses } =
       await setupTests())
 
-    // new contracts to add.
-    newBorrowerOperations = await (
-      await ethers.getContractFactory("BorrowerOperations")
-    ).deploy()
+    newBorrowerOperations = await getDeployedContract("NewBorrowerOperations")
+
     newInterestRateManager = await (
       await ethers.getContractFactory("InterestRateManager")
     ).deploy()
@@ -547,18 +546,44 @@ describe("MUSD", () => {
     it("puts account to pending list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeMintList(addresses.borrowerOperations)
+        .startRevokeMintList([addresses.borrowerOperations])
+
+      const timeNow = await getLatestBlockTimestamp()
+      expect(await contracts.musd.pendingRevokedMintAddresses(0)).to.be.equal(
+        addresses.borrowerOperations,
+      )
+      expect(await contracts.musd.revokeMintListInitiated()).to.be.equal(
+        timeNow,
+      )
+      expect(
+        await contracts.musd.mintList(addresses.borrowerOperations),
+      ).to.equal(true)
+    })
+
+    it("puts multiple accounts to pending list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startRevokeMintList([
+          addresses.borrowerOperations,
+          addresses.interestRateManager,
+        ])
 
       const timeNow = await getLatestBlockTimestamp()
-      expect(await contracts.musd.pendingRevokedMintAddress()).to.be.equal(
+      expect(await contracts.musd.pendingRevokedMintAddresses(0)).to.be.equal(
         addresses.borrowerOperations,
       )
+      expect(await contracts.musd.pendingRevokedMintAddresses(1)).to.be.equal(
+        addresses.interestRateManager,
+      )
       expect(await contracts.musd.revokeMintListInitiated()).to.be.equal(
         timeNow,
       )
       expect(
         await contracts.musd.mintList(addresses.borrowerOperations),
       ).to.equal(true)
+      expect(
+        await contracts.musd.mintList(addresses.interestRateManager),
+      ).to.equal(true)
     })
 
     context("Expected Reverts", () => {
@@ -566,7 +591,7 @@ describe("MUSD", () => {
         await expect(
           contracts.musd
             .connect(alice.wallet)
-            .startRevokeMintList(addresses.borrowerOperations),
+            .startRevokeMintList([addresses.borrowerOperations]),
         ).to.be.revertedWithCustomError(
           contracts.musd,
           "OwnableUnauthorizedAccount",
@@ -577,7 +602,7 @@ describe("MUSD", () => {
         await expect(
           contracts.musd
             .connect(deployer.wallet)
-            .startRevokeMintList(alice.wallet),
+            .startRevokeMintList([alice.wallet]),
         ).to.be.revertedWith("Incorrect address to revoke")
       })
     })
@@ -587,12 +612,12 @@ describe("MUSD", () => {
     it("cancels revoking from mint list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeMintList(addresses.borrowerOperations)
+        .startRevokeMintList([addresses.borrowerOperations])
       await contracts.musd.connect(deployer.wallet).cancelRevokeMintList()
 
-      expect(await contracts.musd.pendingRevokedMintAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingRevokedMintAddressesLength(),
+      ).to.be.equal(0)
       expect(await contracts.musd.revokeMintListInitiated()).to.be.equal(0)
       expect(
         await contracts.musd.mintList(addresses.borrowerOperations),
@@ -621,18 +646,41 @@ describe("MUSD", () => {
     it("removes account from minting list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeMintList(addresses.borrowerOperations)
+        .startRevokeMintList([addresses.borrowerOperations])
       await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
 
       await contracts.musd.connect(deployer.wallet).finalizeRevokeMintList()
 
-      expect(await contracts.musd.pendingRevokedMintAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingRevokedMintAddressesLength(),
+      ).to.be.equal(0)
+      expect(await contracts.musd.revokeMintListInitiated()).to.be.equal(0)
+      expect(
+        await contracts.musd.mintList(addresses.borrowerOperations),
+      ).to.equal(false)
+    })
+
+    it("removes multiple accounts from minting list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startRevokeMintList([
+          addresses.borrowerOperations,
+          addresses.interestRateManager,
+        ])
+      await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
+
+      await contracts.musd.connect(deployer.wallet).finalizeRevokeMintList()
+
+      expect(
+        await contracts.musd.getPendingRevokedMintAddressesLength(),
+      ).to.be.equal(0)
       expect(await contracts.musd.revokeMintListInitiated()).to.be.equal(0)
       expect(
         await contracts.musd.mintList(addresses.borrowerOperations),
       ).to.equal(false)
+      expect(
+        await contracts.musd.mintList(addresses.interestRateManager),
+      ).to.equal(false)
     })
 
     context("Expected Reverts", () => {
@@ -654,7 +702,7 @@ describe("MUSD", () => {
       it("reverts when passed not enough time", async () => {
         await contracts.musd
           .connect(deployer.wallet)
-          .startRevokeMintList(addresses.borrowerOperations)
+          .startRevokeMintList([addresses.borrowerOperations])
         await expect(
           contracts.musd.connect(deployer.wallet).finalizeRevokeMintList(),
         ).to.be.revertedWith("Governance delay has not elapsed")
@@ -666,20 +714,37 @@ describe("MUSD", () => {
     it("puts account to pending list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startAddMintList(alice.wallet)
+        .startAddMintList([alice.wallet])
+
+      const timeNow = await getLatestBlockTimestamp()
+      expect(await contracts.musd.pendingAddedMintAddresses(0)).to.be.equal(
+        alice.wallet,
+      )
+      expect(await contracts.musd.addMintListInitiated()).to.be.equal(timeNow)
+      expect(await contracts.musd.mintList(alice.wallet)).to.equal(false)
+    })
+
+    it("puts multiple accounts to the pending list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startAddMintList([alice.wallet, bob.wallet])
 
       const timeNow = await getLatestBlockTimestamp()
-      expect(await contracts.musd.pendingAddedMintAddress()).to.be.equal(
+      expect(await contracts.musd.pendingAddedMintAddresses(0)).to.be.equal(
         alice.wallet,
       )
+      expect(await contracts.musd.pendingAddedMintAddresses(1)).to.be.equal(
+        bob.wallet,
+      )
       expect(await contracts.musd.addMintListInitiated()).to.be.equal(timeNow)
       expect(await contracts.musd.mintList(alice.wallet)).to.equal(false)
+      expect(await contracts.musd.mintList(bob.wallet)).to.equal(false)
     })
 
     context("Expected Reverts", () => {
       it("reverts when caller is not owner", async () => {
         await expect(
-          contracts.musd.connect(alice.wallet).startAddMintList(alice.wallet),
+          contracts.musd.connect(alice.wallet).startAddMintList([alice.wallet]),
         ).to.be.revertedWithCustomError(
           contracts.musd,
           "OwnableUnauthorizedAccount",
@@ -690,7 +755,7 @@ describe("MUSD", () => {
         await expect(
           contracts.musd
             .connect(deployer.wallet)
-            .startAddMintList(addresses.borrowerOperations),
+            .startAddMintList([addresses.borrowerOperations]),
         ).to.be.revertedWith("Incorrect address to add")
       })
     })
@@ -700,12 +765,12 @@ describe("MUSD", () => {
     it("cancels adding to mint list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startAddMintList(alice.wallet)
+        .startAddMintList([alice.wallet])
       await contracts.musd.connect(deployer.wallet).cancelAddMintList()
 
-      expect(await contracts.musd.pendingAddedMintAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingAddedMintAddressesLength(),
+      ).to.equal(0)
       expect(await contracts.musd.addMintListInitiated()).to.be.equal(0)
       expect(await contracts.musd.mintList(alice.wallet)).to.equal(false)
     })
@@ -723,16 +788,32 @@ describe("MUSD", () => {
     it("adds account to minting list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startAddMintList(alice.wallet)
+        .startAddMintList([alice.wallet])
       await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
 
       await contracts.musd.connect(deployer.wallet).finalizeAddMintList()
 
-      expect(await contracts.musd.pendingAddedMintAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingAddedMintAddressesLength(),
+      ).to.equal(0)
+      expect(await contracts.musd.addMintListInitiated()).to.be.equal(0)
+      expect(await contracts.musd.mintList(alice.wallet)).to.equal(true)
+    })
+
+    it("adds multiple accounts to the minting list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startAddMintList([alice.wallet, bob.wallet])
+      await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
+
+      await contracts.musd.connect(deployer.wallet).finalizeAddMintList()
+
+      expect(
+        await contracts.musd.getPendingAddedMintAddressesLength(),
+      ).to.equal(0)
       expect(await contracts.musd.addMintListInitiated()).to.be.equal(0)
       expect(await contracts.musd.mintList(alice.wallet)).to.equal(true)
+      expect(await contracts.musd.mintList(bob.wallet)).to.equal(true)
     })
 
     context("Expected Reverts", () => {
@@ -754,7 +835,7 @@ describe("MUSD", () => {
       it("reverts when passed not enough time", async () => {
         await contracts.musd
           .connect(deployer.wallet)
-          .startAddMintList(alice.wallet)
+          .startAddMintList([alice.wallet])
         await expect(
           contracts.musd.connect(deployer.wallet).finalizeAddMintList(),
         ).to.be.revertedWith("Governance delay has not elapsed")
@@ -766,10 +847,10 @@ describe("MUSD", () => {
     it("puts account to pending list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeBurnList(addresses.borrowerOperations)
+        .startRevokeBurnList([addresses.borrowerOperations])
 
       const timeNow = await getLatestBlockTimestamp()
-      expect(await contracts.musd.pendingRevokedBurnAddress()).to.be.equal(
+      expect(await contracts.musd.pendingRevokedBurnAddresses(0)).to.be.equal(
         addresses.borrowerOperations,
       )
       expect(await contracts.musd.revokeBurnListInitiated()).to.be.equal(
@@ -781,12 +862,39 @@ describe("MUSD", () => {
       ).to.equal(true)
     })
 
+    it("puts multiple accounts to the pending list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startRevokeBurnList([
+          addresses.borrowerOperations,
+          addresses.stabilityPool,
+        ])
+
+      const timeNow = await getLatestBlockTimestamp()
+      expect(await contracts.musd.pendingRevokedBurnAddresses(0)).to.be.equal(
+        addresses.borrowerOperations,
+      )
+      expect(await contracts.musd.pendingRevokedBurnAddresses(1)).to.be.equal(
+        addresses.stabilityPool,
+      )
+      expect(await contracts.musd.revokeBurnListInitiated()).to.be.equal(
+        timeNow,
+      )
+
+      expect(
+        await contracts.musd.burnList(addresses.borrowerOperations),
+      ).to.equal(true)
+      expect(await contracts.musd.burnList(addresses.stabilityPool)).to.equal(
+        true,
+      )
+    })
+
     context("Expected Reverts", () => {
       it("reverts when caller is not owner", async () => {
         await expect(
           contracts.musd
             .connect(alice.wallet)
-            .startRevokeBurnList(addresses.borrowerOperations),
+            .startRevokeBurnList([addresses.borrowerOperations]),
         ).to.be.revertedWithCustomError(
           contracts.musd,
           "OwnableUnauthorizedAccount",
@@ -797,7 +905,7 @@ describe("MUSD", () => {
         await expect(
           contracts.musd
             .connect(deployer.wallet)
-            .startRevokeBurnList(alice.wallet),
+            .startRevokeBurnList([alice.wallet]),
         ).to.be.revertedWith("Incorrect address to revoke")
       })
     })
@@ -807,12 +915,12 @@ describe("MUSD", () => {
     it("cancels revoking from burn list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeBurnList(addresses.borrowerOperations)
+        .startRevokeBurnList([addresses.borrowerOperations])
       await contracts.musd.connect(deployer.wallet).cancelRevokeBurnList()
 
-      expect(await contracts.musd.pendingRevokedBurnAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingRevokedBurnAddressesLength(),
+      ).to.equal(0)
       expect(await contracts.musd.revokeBurnListInitiated()).to.be.equal(0)
 
       expect(
@@ -839,17 +947,17 @@ describe("MUSD", () => {
   })
 
   describe("finalizeRevokeBurnList()", () => {
-    it("removes account from minting list", async () => {
+    it("removes account from the burn list", async () => {
       await contracts.musd
         .connect(deployer.wallet)
-        .startRevokeBurnList(addresses.borrowerOperations)
+        .startRevokeBurnList([addresses.borrowerOperations])
       await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
 
       await contracts.musd.connect(deployer.wallet).finalizeRevokeBurnList()
 
-      expect(await contracts.musd.pendingRevokedBurnAddress()).to.be.equal(
-        ZERO_ADDRESS,
-      )
+      expect(
+        await contracts.musd.getPendingRevokedBurnAddressesLength(),
+      ).to.equal(0)
       expect(await contracts.musd.revokeBurnListInitiated()).to.be.equal(0)
 
       expect(
@@ -857,6 +965,30 @@ describe("MUSD", () => {
       ).to.equal(false)
     })
 
+    it("removes multiple accounts from the burn list", async () => {
+      await contracts.musd
+        .connect(deployer.wallet)
+        .startRevokeBurnList([
+          addresses.borrowerOperations,
+          addresses.stabilityPool,
+        ])
+      await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
+
+      await contracts.musd.connect(deployer.wallet).finalizeRevokeBurnList()
+
+      expect(
+        await contracts.musd.getPendingRevokedBurnAddressesLength(),
+      ).to.equal(0)
+      expect(await contracts.musd.revokeBurnListInitiated()).to.be.equal(0)
+
+      expect(
+        await contracts.musd.burnList(addresses.borrowerOperations),
+      ).to.equal(false)
+      expect(await contracts.musd.burnList(addresses.stabilityPool)).to.equal(
+        false,
+      )
+    })
+
     context("Expected Reverts", () => {
       it("reverts when caller is not owner", async () => {
         await expect(
@@ -876,7 +1008,7 @@ describe("MUSD", () => {
       it("reverts when passed not enough time", async () => {
         await contracts.musd
           .connect(deployer.wallet)
-          .startRevokeBurnList(addresses.borrowerOperations)
+          .startRevokeBurnList([addresses.borrowerOperations])
         await expect(
           contracts.musd.connect(deployer.wallet).finalizeRevokeBurnList(),
         ).to.be.revertedWith("Governance delay has not elapsed")
diff --git a/solidity/test/helpers/abi.ts b/solidity/test/helpers/abi.ts
index 3dc5cfa..f95c476 100644
--- a/solidity/test/helpers/abi.ts
+++ b/solidity/test/helpers/abi.ts
@@ -13,3 +13,17 @@ export const BORROWING_FEE_PAID = [
 export const REFINANCING_FEE_PAID = [
   "event RefinancingFeePaid(address indexed _borrower, uint256 _fee)",
 ]
+
+export const PCV_ABI = [
+  "event PCVDepositSP(address indexed user, uint256 musdAmount)",
+  "event PCVWithdrawSP(address indexed user, uint256 musdAmount, uint256 collateralAmount)",
+  "event MUSDTokenAddressSet(address _musdTokenAddress)",
+  "event BorrowerOperationsAddressSet(address _borrowerOperationsAddress)",
+  "event RolesSet(address _council, address _treasury)",
+  "event MUSDWithdraw(address _recipient, uint256 _amount)",
+  "event CollateralWithdraw(address _recipient, uint256 _collateralAmount)",
+  "event PCVDebtPaid(uint256 _paidDebt)",
+  "event RecipientAdded(address _recipient)",
+  "event RecipientRemoved(address _recipient)",
+  "event PCVFeePaid(address _recipient, uint256 _amount)",
+]
diff --git a/solidity/test/helpers/context.ts b/solidity/test/helpers/context.ts
index 45d89d9..cd2f09c 100644
--- a/solidity/test/helpers/context.ts
+++ b/solidity/test/helpers/context.ts
@@ -13,6 +13,7 @@ import {
 import {
   ActivePool,
   BorrowerOperations,
+  BorrowerOperationsSignatures,
   CollSurplusPool,
   DefaultPool,
   GasPool,
@@ -34,6 +35,8 @@ export async function deployment() {
   const activePool: ActivePool = await getDeployedContract("ActivePool")
   const borrowerOperations: BorrowerOperations =
     await getDeployedContract("BorrowerOperations")
+  const borrowerOperationsSignatures: BorrowerOperationsSignatures =
+    await getDeployedContract("BorrowerOperationsSignatures")
   const collSurplusPool: CollSurplusPool =
     await getDeployedContract("CollSurplusPool")
   const defaultPool: DefaultPool = await getDeployedContract("DefaultPool")
@@ -57,6 +60,7 @@ export async function deployment() {
   const contracts: Contracts = {
     activePool,
     borrowerOperations,
+    borrowerOperationsSignatures,
     collSurplusPool,
     defaultPool,
     gasPool,
@@ -80,9 +84,7 @@ export const beforeAndAfter = () => ({ before: 0n, after: 0n })
 function initializeContractState(): ContractsState {
   return {
     troveManager: {
-      baseRate: beforeAndAfter(),
       collateralSnapshot: beforeAndAfter(),
-      lastFeeOperationTime: beforeAndAfter(),
       liquidation: {
         collateral: beforeAndAfter(),
         principal: beforeAndAfter(),
@@ -93,9 +95,6 @@ function initializeContractState(): ContractsState {
       troves: beforeAndAfter(),
       TCR: beforeAndAfter(),
     },
-    interestRateManager: {
-      interestRateData: {},
-    },
     activePool: {
       btc: beforeAndAfter(),
       collateral: beforeAndAfter(),
@@ -215,10 +214,13 @@ export async function getAddresses(contracts: Contracts, users: Users) {
     // contracts
     activePool: await contracts.activePool.getAddress(),
     borrowerOperations: await contracts.borrowerOperations.getAddress(),
+    borrowerOperationsSignatures:
+      await contracts.borrowerOperationsSignatures.getAddress(),
     collSurplusPool: await contracts.collSurplusPool.getAddress(),
     defaultPool: await contracts.defaultPool.getAddress(),
     gasPool: await contracts.gasPool.getAddress(),
     hintHelpers: await contracts.hintHelpers.getAddress(),
+    interestRateManager: await contracts.interestRateManager.getAddress(),
     mockAggregator: await contracts.mockAggregator.getAddress(),
     mockERC20: await contracts.mockERC20.getAddress(),
     musd: await contracts.musd.getAddress(),
diff --git a/solidity/test/helpers/functions.ts b/solidity/test/helpers/functions.ts
index 8fce68f..d303808 100644
--- a/solidity/test/helpers/functions.ts
+++ b/solidity/test/helpers/functions.ts
@@ -2,7 +2,7 @@
 import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers"
 import { ContractTransactionResponse, LogDescription } from "ethers"
 import { ethers, helpers } from "hardhat"
-import { assert, expect } from "chai"
+import { expect } from "chai"
 import { GOVERNANCE_TIME_DELAY, to1e18 } from "../utils"
 import { ZERO_ADDRESS } from "../../helpers/constants"
 import {
@@ -14,9 +14,9 @@ import {
   User,
   WithdrawCollParams,
 } from "./interfaces"
-import { LIQUIDATION_ABI } from "./abi"
-import { fastForwardTime } from "./time"
-import { beforeAndAfter, getAddresses, loadTestSetup } from "./context"
+import { LIQUIDATION_ABI, PCV_ABI } from "./abi"
+import { SECONDS_IN_ONE_YEAR, fastForwardTime } from "./time"
+import { getAddresses, loadTestSetup } from "./context"
 
 export const NO_GAS = {
   maxFeePerGas: 0,
@@ -30,7 +30,7 @@ export async function removeMintlist(
 ) {
   await contracts.musd
     .connect(owner)
-    .startRevokeMintList(await contracts.borrowerOperations.getAddress())
+    .startRevokeMintList([await contracts.borrowerOperations.getAddress()])
   await fastForwardTime(GOVERNANCE_TIME_DELAY + 1)
   await contracts.musd.connect(owner).finalizeRevokeMintList()
 }
@@ -47,7 +47,7 @@ export async function getOpenTroveTotalDebt(
   const price = await contracts.priceFeed.fetchPrice()
   const recoveryMode = await contracts.troveManager.checkRecoveryMode(price)
   const compositeDebt =
-    await contracts.borrowerOperations.getCompositeDebt(musdAmount)
+    await contracts.troveManager.getCompositeDebt(musdAmount)
 
   if (recoveryMode) {
     return compositeDebt
@@ -155,29 +155,6 @@ export async function updatePCVSnapshot(
   )
 }
 
-export async function updateInterestRateDataSnapshot(
-  contracts: Contracts,
-  state: ContractsState,
-  interestRate: number,
-  checkPoint: CheckPoint,
-) {
-  const { principal, interest, lastUpdatedTime } =
-    await contracts.interestRateManager.interestRateData(interestRate)
-
-  const data = state.interestRateManager.interestRateData[interestRate] ?? {}
-
-  data.principal ??= beforeAndAfter()
-  data.principal[checkPoint] = principal
-
-  data.interest ??= beforeAndAfter()
-  data.interest[checkPoint] = interest
-
-  data.lastUpdatedTime ??= beforeAndAfter()
-  data.lastUpdatedTime[checkPoint] = lastUpdatedTime
-
-  state.interestRateManager.interestRateData[interestRate] = data
-}
-
 export async function updatePendingSnapshot(
   contracts: Contracts,
   user: User,
@@ -273,6 +250,16 @@ export async function updateWalletSnapshot(
   user.btc[checkPoint] = await ethers.provider.getBalance(user.address)
 }
 
+export async function updateWalletSnapshots(
+  contracts: Contracts,
+  users: User[],
+  checkPoint: CheckPoint,
+) {
+  await Promise.all(
+    users.map((user) => updateWalletSnapshot(contracts, user, checkPoint)),
+  )
+}
+
 export async function updateTroveManagerSnapshot(
   contracts: Contracts,
   state: ContractsState,
@@ -287,10 +274,6 @@ export async function updateTroveManagerSnapshot(
     await contracts.troveManager.totalStakesSnapshot()
   state.troveManager.troves[checkPoint] =
     await contracts.troveManager.getTroveOwnersCount()
-  state.troveManager.baseRate[checkPoint] =
-    await contracts.troveManager.baseRate()
-  state.troveManager.lastFeeOperationTime[checkPoint] =
-    await contracts.troveManager.lastFeeOperationTime()
   state.troveManager.liquidation.collateral[checkPoint] =
     await contracts.troveManager.L_Collateral()
   state.troveManager.liquidation.principal[checkPoint] =
@@ -411,6 +394,47 @@ export async function getDebtAndCollFromTroveUpdatedEvents(
   }
 }
 
+export async function getEmittedWithdrawCollateralValues(
+  tx: ContractTransactionResponse,
+) {
+  const [recipient, collateralAmount] = (
+    await getAllEventsByName(tx, PCV_ABI, "CollateralWithdraw")
+  )[0].args
+
+  return {
+    recipient,
+    collateralAmount,
+  }
+}
+
+export async function getEmittedPCVtoSPDepositValues(
+  tx: ContractTransactionResponse,
+) {
+  const [user, musdAmount, collateralAmount] = (
+    await getAllEventsByName(tx, PCV_ABI, "PCVDepositSP")
+  )[0].args
+
+  return {
+    user,
+    musdAmount,
+    collateralAmount,
+  }
+}
+
+export async function getEmittedSPtoPCVWithdrawalValues(
+  tx: ContractTransactionResponse,
+) {
+  const [user, musdAmount, collateralAmount] = (
+    await getAllEventsByName(tx, PCV_ABI, "PCVWithdrawSP")
+  )[0].args
+
+  return {
+    user,
+    musdAmount,
+    collateralAmount,
+  }
+}
+
 export async function getEmittedLiquidationValues(
   liquidationTx: ContractTransactionResponse,
 ) {
@@ -447,7 +471,7 @@ export async function addColl(contracts: Contracts, inputs: AddCollParams) {
 
   return contracts.borrowerOperations
     .connect(inputs.sender)
-    .addColl(amount, params.lowerHint, params.upperHint, {
+    .addColl(params.lowerHint, params.upperHint, {
       value: amount, // The amount of chain base asset to send
     })
 }
@@ -486,7 +510,7 @@ export async function adjustTroveToICR(
   // Calculate the debt required to reach the target ICR
   const targetDebt = (coll * price) / targetICR
   const increasedTotalDebt = targetDebt - debt
-  const borrowingRate = await contracts.troveManager.getBorrowingRate()
+  const borrowingRate = await contracts.troveManager.BORROWING_FEE_FLOOR()
 
   /* Total increase in debt after the call = targetDebt - debt
    * Requested increase in debt factors in the borrow fee, note you must multiply by to1e18(1) before the division to avoid rounding errors
@@ -496,12 +520,7 @@ export async function adjustTroveToICR(
 
   await contracts.borrowerOperations
     .connect(from)
-    .withdrawMUSD(
-      to1e18("100") / 100n,
-      requestedDebtIncrease,
-      ZERO_ADDRESS,
-      ZERO_ADDRESS,
-    )
+    .withdrawMUSD(requestedDebtIncrease, ZERO_ADDRESS, ZERO_ADDRESS)
 
   return { requestedDebtIncrease, increasedTotalDebt }
 }
@@ -514,11 +533,7 @@ export async function openTrove(contracts: Contracts, inputs: OpenTroveParams) {
   if (params.upperHint === undefined) params.upperHint = ZERO_ADDRESS
 
   // open minimum debt amount unless extraMUSDAmount is specificed.
-  // if (!params.musdAmount) params.musdAmount = (await contracts.borrowerOperations.MIN_NET_DEBT()) + 1n // add 1 to avoid rounding issues
-
-  // max fee size cant exceed 100%
-  if (params.maxFeePercentage === undefined) params.maxFeePercentage = "100"
-  const maxFeePercentage = to1e18(params.maxFeePercentage) / 100n
+  // if (!params.musdAmount) params.musdAmount = (await contracts.borrowerOperations.minNetDebt()) + 1n // add 1 to avoid rounding issues
 
   // ICR default of 150%
   if (params.ICR === undefined) params.ICR = "200"
@@ -534,23 +549,16 @@ export async function openTrove(contracts: Contracts, inputs: OpenTroveParams) {
   // amount of debt to take on
   const totalDebt = await getOpenTroveTotalDebt(contracts, musdAmount)
   const netDebt =
-    totalDebt - (await contracts.troveManager.getMUSDGasCompensation())
+    totalDebt - (await contracts.troveManager.MUSD_GAS_COMPENSATION())
 
   // amount of assets required for the loan
   const assetAmount = (ICR * totalDebt) / price
 
   const tx = await contracts.borrowerOperations
     .connect(params.sender)
-    .openTrove(
-      maxFeePercentage,
-      musdAmount,
-      assetAmount,
-      params.upperHint,
-      params.lowerHint,
-      {
-        value: assetAmount, // The amount of chain base asset to send
-      },
-    )
+    .openTrove(musdAmount, params.upperHint, params.lowerHint, {
+      value: assetAmount, // The amount of chain base asset to send
+    })
 
   return {
     musdAmount,
@@ -763,15 +771,6 @@ export function transferMUSD(
     .transfer(receiver.wallet, amount, NO_GAS)
 }
 
-export async function setBaseRate(contracts: Contracts, rate: bigint) {
-  if ("setBaseRate" in contracts.troveManager) {
-    await contracts.troveManager.setBaseRate(rate)
-    await contracts.troveManager.setLastFeeOpTimeToNow()
-  } else {
-    assert.fail("TroveManagerTester not loaded")
-  }
-}
-
 export async function setupTests() {
   const testSetup = await loadTestSetup()
   const { contracts, state } = testSetup
@@ -914,7 +913,6 @@ export async function getRedemptionHints(
   redemptionAmount: bigint,
   price: bigint,
 ) {
-  await contracts.troveManager.callUpdateDefaultPoolInterest(NO_GAS)
   const { firstRedemptionHint, partialRedemptionHintNICR } =
     await contracts.hintHelpers.getRedemptionHints(redemptionAmount, price, 0)
 
@@ -959,7 +957,6 @@ export async function performRedemption(
       lowerPartialRedemptionHint,
       partialRedemptionHintNICR,
       maxIterations,
-      to1e18("1"),
       NO_GAS,
     )
 }
@@ -971,11 +968,10 @@ export function calculateInterestOwed(
   endTimeSeconds: bigint,
 ) {
   const elapsedSeconds = endTimeSeconds - startTimeSeconds
-  const secondsInOneYear = 31536000n
 
   return (
     (principal * BigInt(interestRateBips) * elapsedSeconds) /
-    (10000n * secondsInOneYear)
+    (10000n * SECONDS_IN_ONE_YEAR)
   )
 }
 
@@ -1028,6 +1024,7 @@ export async function testUpdatesInterestOwed(
 export async function testUpdatesSystemInterestOwed(
   contracts: Contracts,
   state: ContractsState,
+  addresses: TestingAddresses,
   userA: User,
   userB: User,
   governance: User,
@@ -1039,36 +1036,46 @@ export async function testUpdatesSystemInterestOwed(
     ICR: "1000",
     sender: userA.wallet,
   })
-  await updateInterestRateDataSnapshot(contracts, state, 100, "before")
 
   await setInterestRate(contracts, governance, 200)
   await openTrove(contracts, {
     musdAmount: "50,000",
     sender: userB.wallet,
   })
-  await updateInterestRateDataSnapshot(contracts, state, 200, "before")
+
+  await updateContractsSnapshot(
+    contracts,
+    state,
+    "activePool",
+    "before",
+    addresses,
+  )
+  await updateTroveSnapshots(contracts, [userA, userB], "before")
 
   await fn()
-  await updateTroveSnapshot(contracts, userA, "after")
-  await updateInterestRateDataSnapshot(contracts, state, 100, "after")
-  await updateTroveSnapshot(contracts, userB, "after")
-  await updateInterestRateDataSnapshot(contracts, state, 200, "after")
-
-  // Check that 100 bps interest rate data is updated
-  expect(
-    state.interestRateManager.interestRateData[100].interest.after,
-  ).to.be.greaterThan(
-    state.interestRateManager.interestRateData[100].interest.before,
+
+  await updateTroveSnapshots(contracts, [userA, userB], "after")
+  await updateContractsSnapshot(
+    contracts,
+    state,
+    "activePool",
+    "after",
+    addresses,
+  )
+
+  expect(state.activePool.interest.after).to.be.closeTo(
+    userA.trove.interestOwed.after +
+      userB.trove.interestOwed.after +
+      calculateInterestOwed(
+        userB.trove.debt.after,
+        200,
+        userB.trove.lastInterestUpdateTime.before,
+        userA.trove.lastInterestUpdateTime.after,
+      ),
+    5n,
   )
-  expect(
-    state.interestRateManager.interestRateData[100].interest.after,
-  ).to.equal(userA.trove.interestOwed.after)
-
-  // Check that 200 bps interest rate data is unchanged
-  expect(
-    state.interestRateManager.interestRateData[200].interest.after,
-  ).to.equal(state.interestRateManager.interestRateData[200].interest.before)
-  expect(
-    state.interestRateManager.interestRateData[200].interest.after,
-  ).to.equal(userB.trove.interestOwed.after)
+}
+
+export function collateralToRedistribute(collateral: bigint): bigint {
+  return (collateral * 995n) / 1000n
 }
diff --git a/solidity/test/helpers/interfaces.ts b/solidity/test/helpers/interfaces.ts
index 4db9319..0b79594 100644
--- a/solidity/test/helpers/interfaces.ts
+++ b/solidity/test/helpers/interfaces.ts
@@ -4,6 +4,7 @@ import type { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signer
 import {
   ActivePool,
   BorrowerOperations,
+  BorrowerOperationsSignatures,
   CollSurplusPool,
   DefaultPool,
   GasPool,
@@ -22,10 +23,12 @@ import {
 export interface TestingAddresses {
   activePool: string
   borrowerOperations: string
+  borrowerOperationsSignatures: string
   collSurplusPool: string
   defaultPool: string
   gasPool: string
   hintHelpers: string
+  interestRateManager: string
   mockAggregator: string
   mockERC20: string
   musd: string
@@ -51,17 +54,9 @@ type BeforeAndAfter = {
   after: bigint
 }
 
-type InterestRateInfo = {
-  principal: BeforeAndAfter
-  interest: BeforeAndAfter
-  lastUpdatedTime: BeforeAndAfter
-}
-
 export interface ContractsState {
   troveManager: {
-    baseRate: BeforeAndAfter
     collateralSnapshot: BeforeAndAfter
-    lastFeeOperationTime: BeforeAndAfter
     liquidation: {
       collateral: BeforeAndAfter
       principal: BeforeAndAfter
@@ -101,14 +96,12 @@ export interface ContractsState {
     currentEpoch: BeforeAndAfter
     currentScale: BeforeAndAfter
   }
-  interestRateManager: {
-    interestRateData: Record<number, InterestRateInfo>
-  }
 }
 
 export interface Contracts {
   activePool: ActivePool
   borrowerOperations: BorrowerOperations
+  borrowerOperationsSignatures: BorrowerOperationsSignatures
   collSurplusPool: CollSurplusPool
   defaultPool: DefaultPool
   gasPool: GasPool
@@ -200,7 +193,6 @@ export interface OpenTroveParams {
   musdAmount: string | bigint
   ICR?: string
   lowerHint?: string
-  maxFeePercentage?: string
   sender: HardhatEthersSigner
   upperHint?: string
 }
diff --git a/solidity/test/helpers/time.ts b/solidity/test/helpers/time.ts
index 3a1c2bd..edfccad 100644
--- a/solidity/test/helpers/time.ts
+++ b/solidity/test/helpers/time.ts
@@ -1,5 +1,10 @@
 import { ethers } from "hardhat"
 
+// https://sibenotes.com/maths/how-many-seconds-are-in-a-year/
+// 365.2425 days per year * 24 hours per day *
+// 60 minutes per hour * 60 seconds per minute
+export const SECONDS_IN_ONE_YEAR = 31_556_952n
+
 export async function getLatestBlockTimestamp() {
   const { provider } = ethers
   const latestBlock = await provider.getBlock("latest")
diff --git a/solidity/test/normal/AccessControl.test.ts b/solidity/test/normal/AccessControl.test.ts
index 84f5bb4..75f9efd 100644
--- a/solidity/test/normal/AccessControl.test.ts
+++ b/solidity/test/normal/AccessControl.test.ts
@@ -15,12 +15,13 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
   let bob: User
   let carol: User
   let deployer: User
+  let whale: User
 
   let addresses: TestingAddresses
   let contracts: Contracts
 
   beforeEach(async () => {
-    ;({ alice, bob, carol, deployer, contracts, addresses } =
+    ;({ alice, bob, carol, deployer, whale, contracts, addresses } =
       await setupTests())
 
     await Promise.all(
@@ -32,6 +33,12 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
         }),
       ),
     )
+
+    await openTrove(contracts, {
+      sender: whale.wallet,
+      ICR: "600",
+      musdAmount: "200,000",
+    })
   })
 
   describe("BorrowerOperations", () => {
@@ -41,9 +48,9 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
           .connect(alice.wallet)
           .moveCollateralGainToTrove(
             alice.address,
-            to1e18("2"),
             alice.address,
             alice.address,
+            { value: to1e18("2") },
           ),
       ).to.be.revertedWith("BorrowerOps: Caller is not Stability Pool")
     })
@@ -67,7 +74,7 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
     it("refinance(): reverts when called on a trove that is not active", async () => {
       await dropPriceAndLiquidate(contracts, deployer, carol)
       await expect(
-        contracts.borrowerOperations.connect(carol.wallet).refinance(to1e18(1)),
+        contracts.borrowerOperations.connect(carol.wallet).refinance(),
       ).to.be.revertedWith("BorrowerOps: Trove does not exist or is closed")
     })
 
@@ -118,21 +125,11 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
       )
     })
 
-    it("setMaxInterestRate(): reverts when called by account that is not governance", async () => {
+    it("addPrincipal(): reverts when called by account that is not borrower operations or trove manager", async () => {
       await expect(
         contracts.interestRateManager
           .connect(alice.wallet)
-          .setMaxInterestRate(1000n),
-      ).to.be.revertedWith(
-        "InterestRateManager: Only governance can call this function",
-      )
-    })
-
-    it("addPrincipalToRate(): reverts when called by account that is not borrower operations or trove manager", async () => {
-      await expect(
-        contracts.interestRateManager
-          .connect(alice.wallet)
-          .addPrincipalToRate(1000n, to1e18(2300)),
+          .addPrincipal(to1e18(2300), 1000n),
       ).to.be.revertedWith(
         "InterestRateManager: Only BorrowerOperations or TroveManager may call this function.",
       )
@@ -148,31 +145,11 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
       )
     })
 
-    it("addInterestToRate(): reverts when called by account that is not borrower operations or trove manager", async () => {
+    it("removePrincipal(): reverts when called by account that is not borrower operations or trove manager", async () => {
       await expect(
         contracts.interestRateManager
           .connect(alice.wallet)
-          .addInterestToRate(1000n, to1e18(4300)),
-      ).to.be.revertedWith(
-        "InterestRateManager: Only BorrowerOperations or TroveManager may call this function.",
-      )
-    })
-
-    it("removePrincipalFromRate(): reverts when called by account that is not borrower operations or trove manager", async () => {
-      await expect(
-        contracts.interestRateManager
-          .connect(alice.wallet)
-          .removePrincipalFromRate(1000n, to1e18(4300)),
-      ).to.be.revertedWith(
-        "InterestRateManager: Only BorrowerOperations or TroveManager may call this function.",
-      )
-    })
-
-    it("removeInterestFromRate(): reverts when called by account that is not borrower operations or trove manager", async () => {
-      await expect(
-        contracts.interestRateManager
-          .connect(alice.wallet)
-          .removeInterestFromRate(1000n, to1e18(4300)),
+          .removePrincipal(to1e18(4300), 1000n),
       ).to.be.revertedWith(
         "InterestRateManager: Only BorrowerOperations or TroveManager may call this function.",
       )
@@ -368,7 +345,7 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
   describe("StabilityPool", () => {
     it("offset(): reverts when called by an account that is not TroveManager", async () => {
       await expect(
-        contracts.stabilityPool.connect(alice.wallet).offset(100, 10),
+        contracts.stabilityPool.connect(alice.wallet).offset(100, 0, 10),
       ).to.be.revertedWith("StabilityPool: Caller is not TroveManager")
     })
 
@@ -431,15 +408,19 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
   })
 
   describe("PCV", () => {
-    async function payDebt() {
-      await contracts.pcv.connect(deployer.wallet).initialize()
-      const debtToPay = await contracts.pcv.debtToPay()
-      await contracts.musd.unprotectedMint(addresses.pcv, debtToPay)
-      await contracts.pcv.connect(deployer.wallet).payDebt(debtToPay)
-    }
+    it("withdrawFromStabilityPool() reverts when caller is not owner, council or treasury", async () => {
+      await expect(
+        contracts.pcv.connect(alice.wallet).withdrawFromStabilityPool(0),
+      ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
+    })
+
+    it("depositToStabilityPool(): reverts when caller is not owner, council or treasury", async () => {
+      await expect(
+        contracts.pcv.connect(alice.wallet).depositToStabilityPool(0),
+      ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
+    })
 
     it("withdrawMUSD(): reverts when caller is not owner, council or treasury", async () => {
-      await payDebt()
       await expect(
         contracts.pcv.connect(alice.wallet).withdrawMUSD(alice.address, 1),
       ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
@@ -458,7 +439,6 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
     })
 
     it("withdrawCollateral(): reverts when caller is not owner, council or treasury", async () => {
-      await payDebt()
       await expect(
         contracts.pcv
           .connect(alice.wallet)
@@ -466,15 +446,15 @@ describe("Access Control: Liquity functions with the caller restricted to Liquit
       ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
     })
 
-    it("payDebt(): reverts when caller is not owner, council or treasury", async () => {
+    it("distributeMUSD(): reverts when caller is not owner, council or treasury", async () => {
       await expect(
-        contracts.pcv.connect(alice.wallet).payDebt(1),
+        contracts.pcv.connect(alice.wallet).distributeMUSD(1),
       ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
     })
 
     it("initialize(): reverts when caller is not owner, council or treasury", async () => {
       await expect(
-        contracts.pcv.connect(alice.wallet).initialize(),
+        contracts.pcv.connect(alice.wallet).initializeDebt(),
       ).to.be.revertedWith("PCV: caller must be owner or council or treasury")
     })
 
diff --git a/solidity/test/normal/BorrowerOperations.test.ts b/solidity/test/normal/BorrowerOperations.test.ts
index c82d324..07873e0 100644
--- a/solidity/test/normal/BorrowerOperations.test.ts
+++ b/solidity/test/normal/BorrowerOperations.test.ts
@@ -15,9 +15,9 @@ import {
   getTroveEntireDebt,
   NO_GAS,
   openTrove,
+  performRedemption,
   REFINANCING_FEE_PAID,
   removeMintlist,
-  setBaseRate,
   setInterestRate,
   setupTests,
   TestingAddresses,
@@ -25,7 +25,6 @@ import {
   testUpdatesSystemInterestOwed,
   TROVE_UPDATED_ABI,
   updateContractsSnapshot,
-  updateInterestRateDataSnapshot,
   updatePCVSnapshot,
   updatePendingSnapshot,
   updateRewardSnapshot,
@@ -33,6 +32,7 @@ import {
   updateTroveSnapshot,
   updateTroveSnapshots,
   updateWalletSnapshot,
+  updateWalletSnapshots,
   User,
 } from "../helpers"
 import { to1e18 } from "../utils"
@@ -56,7 +56,7 @@ describe("BorrowerOperations in Normal Mode", () => {
   let treasury: User
   let contracts: Contracts
   let state: ContractsState
-  let MIN_NET_DEBT: bigint
+  let minNetDebt: bigint
   let MUSD_GAS_COMPENSATION: bigint
 
   async function checkOpenTroveEvents(
@@ -113,20 +113,37 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   }
 
-  async function setNewRate(rate: bigint) {
-    await setBaseRate(contracts, rate)
-  }
-
   async function setupCarolsTroveAndAdjustRate() {
     await openTrove(contracts, {
       musdAmount: "20,000",
       ICR: "500",
       sender: carol.wallet,
     })
+  }
 
-    // Artificially make baseRate 5%
-    const newRate = to1e18(5) / 100n
-    await setNewRate(newRate)
+  async function setupSignatureTests(borrowerUser: User = carol) {
+    const borrower = borrowerUser.address
+    const contractAddress = addresses.borrowerOperationsSignatures
+    const nonce =
+      await contracts.borrowerOperationsSignatures.getNonce(borrower)
+    const domain = {
+      name: "BorrowerOperationsSignatures",
+      version: "1",
+      chainId: (await ethers.provider.getNetwork()).chainId,
+      verifyingContract: contractAddress,
+    }
+    const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+    const interestRate = await contracts.interestRateManager.interestRate()
+
+    return {
+      borrower,
+      recipient: borrower,
+      contractAddress,
+      nonce,
+      domain,
+      deadline,
+      interestRate,
+    }
   }
 
   beforeEach(async () => {
@@ -144,7 +161,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       addresses,
     } = await setupTests())
 
-    MIN_NET_DEBT = await contracts.borrowerOperations.MIN_NET_DEBT()
+    minNetDebt = await contracts.borrowerOperations.minNetDebt()
     MUSD_GAS_COMPENSATION =
       await contracts.borrowerOperations.MUSD_GAS_COMPENSATION()
 
@@ -165,150 +182,10 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("setNewRate()", () => {
-    it("Changes the base", async () => {
-      const baseRateBefore = await contracts.troveManager.baseRate()
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-      expect(await contracts.troveManager.baseRate()).to.be.greaterThan(
-        baseRateBefore,
-      )
-      expect(await contracts.troveManager.baseRate()).to.equal(newRate)
-    })
-  })
-
   describe("openTrove()", () => {
-    it("Decays a non-zero base rate", async () => {
-      // setup
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-
-      // Check baseRate is now non-zero
-      const baseRate1 = await contracts.troveManager.baseRate()
-      expect(baseRate1).is.equal(newRate)
-
-      // 2 hours pass
-      await fastForwardTime(7200)
-
-      // Dennis opens trove
-      await openTrove(contracts, {
-        musdAmount: "2,037",
-        sender: dennis.wallet,
-      })
-
-      // Check baseRate has decreased
-      const baseRate2 = await contracts.troveManager.baseRate()
-      expect(baseRate2).is.lessThan(baseRate1)
-
-      // 1 hour passes
-      await fastForwardTime(3600)
-
-      // Eric opens trove
-      await openTrove(contracts, {
-        musdAmount: "2,012",
-        sender: eric.wallet,
-      })
-
-      const baseRate3 = await contracts.troveManager.baseRate()
-      expect(baseRate3).is.lessThan(baseRate2)
-    })
-
-    it("Doesn't change base rate if it is already zero", async () => {
-      // Check baseRate is zero
-      expect(await contracts.troveManager.baseRate()).to.equal(0)
-
-      // 2 hours pass
-      await fastForwardTime(7200)
-
-      // Dennis opens trove
-      await openTrove(contracts, {
-        musdAmount: "2,000",
-        sender: dennis.wallet,
-      })
-
-      // Check baseRate is still 0
-      expect(await contracts.troveManager.baseRate()).to.equal(0)
-
-      // 1 hour passes
-      await fastForwardTime(3600)
-
-      // Eric opens trove
-      await openTrove(contracts, {
-        musdAmount: "2,000",
-        sender: eric.wallet,
-      })
-
-      expect(await contracts.troveManager.baseRate()).to.equal(0)
-    })
-
-    it("Doesn't update lastFeeOpTime if less time than decay interval has passed since the last fee operation", async () => {
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-      const lastFeeOpTime1 = await contracts.troveManager.lastFeeOperationTime()
-
-      // Dennis triggers a fee
-      await openTrove(contracts, {
-        musdAmount: "2,000",
-        sender: dennis.wallet,
-      })
-      const lastFeeOpTime2 = await contracts.troveManager.lastFeeOperationTime()
-
-      // Check that the last fee operation time did not update, as borrower D's debt issuance occured
-      // since before minimum interval had passed
-      expect(lastFeeOpTime2).to.equal(lastFeeOpTime1)
-
-      // 1 minute passes
-      await fastForwardTime(60)
-
-      // Check that now, at least one minute has passed since lastFeeOpTime_1
-      const timeNow = await getLatestBlockTimestamp()
-      expect(BigInt(timeNow)).to.be.oneOf([
-        lastFeeOpTime1 + 60n,
-        lastFeeOpTime1 + 61n,
-        lastFeeOpTime1 + 62n,
-      ])
-
-      // Eric triggers a fee
-      await openTrove(contracts, {
-        musdAmount: "2,000",
-        sender: eric.wallet,
-      })
-      const lastFeeOpTime3 = await contracts.troveManager.lastFeeOperationTime()
-
-      // Check that the last fee operation time DID update, as borrower's debt issuance occured
-      // after minimum interval had passed
-      expect(lastFeeOpTime3).to.greaterThan(lastFeeOpTime1)
-    })
-
-    it("Borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity", async () => {
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-
-      // 59 minutes pass
-      fastForwardTime(3540)
-
-      // Borrower triggers a fee, before 60 minute decay interval has passed
-      await openTrove(contracts, {
-        musdAmount: "20,000",
-        sender: dennis.wallet,
-      })
-
-      // 1 minute pass
-      fastForwardTime(60)
-
-      // Borrower triggers another fee
-      await openTrove(contracts, {
-        musdAmount: "20,000",
-        sender: eric.wallet,
-      })
-
-      // Check base rate has decreased even though Borrower tried to stop it decaying
-      expect(await contracts.troveManager.baseRate()).is.lessThan(newRate)
-    })
-
     it("Opens a trove with net debt >= minimum net debt", async () => {
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -321,36 +198,8 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(await contracts.sortedTroves.contains(eric.address)).to.equal(true)
     })
 
-    it("Succeeds when fee is less than max fee percentage", async () => {
-      // setup
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-
-      // Attempt with maxFee > 5%
-      await openTrove(contracts, {
-        musdAmount: "10,000",
-        sender: dennis.wallet,
-        maxFeePercentage: "5.0000000000000001",
-      })
-      expect(await contracts.musd.balanceOf(dennis.wallet)).to.equal(
-        to1e18("10,000"),
-      )
-
-      // Attempt with maxFee 100%
-      await openTrove(contracts, {
-        musdAmount: "20,000",
-        sender: eric.wallet,
-        maxFeePercentage: "100",
-      })
-      expect(await contracts.musd.balanceOf(eric.wallet)).to.equal(
-        to1e18("20,000"),
-      )
-    })
-
     it("Borrowing at non-zero base records the (drawn debt + fee  + liq. reserve) on the Trove struct", async () => {
       const musdAmount = to1e18("20,000")
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
 
       fastForwardTime(7200)
 
@@ -383,14 +232,14 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(carol.trove.status.before).is.equal(0)
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
       // Get the expected debt based on the mUSD request (adding fee and liq. reserve on top)
       const expectedDebt =
-        MIN_NET_DEBT +
-        (await contracts.troveManager.getBorrowingFee(MIN_NET_DEBT)) +
+        minNetDebt +
+        (await contracts.troveManager.getBorrowingFee(minNetDebt)) +
         MUSD_GAS_COMPENSATION
 
       await updateTroveSnapshot(contracts, carol, "after")
@@ -498,7 +347,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(dennis.trove.debt.before).to.equal(0n)
 
       const { tx } = await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: dennis.wallet,
       })
 
@@ -510,7 +359,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
       await updateTroveSnapshot(contracts, dennis, "after")
       expect(dennis.trove.debt.after).to.equal(
-        MIN_NET_DEBT + MUSD_GAS_COMPENSATION + emittedFee,
+        minNetDebt + MUSD_GAS_COMPENSATION + emittedFee,
       )
     })
 
@@ -518,7 +367,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       const debtBefore = await contracts.activePool.getDebt()
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -528,7 +377,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: dennis.wallet,
       })
 
@@ -586,10 +435,14 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
     })
 
-    it("Adds the trove's principal to the principal for its interest rate", async () => {
-      const principalBefore = (
-        await contracts.interestRateManager.interestRateData(0)
-      ).principal
+    it("Adds the trove's principal to the active pool", async () => {
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
 
       await openTrove(contracts, {
         musdAmount: "5,000",
@@ -597,22 +450,24 @@ describe("BorrowerOperations in Normal Mode", () => {
         sender: dennis.wallet,
       })
 
-      const principalAfter = (
-        await contracts.interestRateManager.interestRateData(0)
-      ).principal
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
 
       await updateTroveSnapshot(contracts, dennis, "before")
-      expect(principalAfter - principalBefore).to.equal(
-        dennis.trove.debt.before,
+
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before + dennis.trove.debt.before,
       )
     })
 
     it("Borrowing at non-zero base rate sends mUSD fee to PCV contract", async () => {
       state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
 
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-
       await fastForwardTime(7200)
 
       await openTrove(contracts, {
@@ -629,8 +484,6 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(dennis.musd.before).to.equal(0)
 
       const musdAmount = to1e18("40,000")
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
 
       fastForwardTime(7200)
 
@@ -645,9 +498,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("Borrowing at zero base rate changes the PCV contract mUSD fees collected", async () => {
-      state.troveManager.baseRate.before =
-        await contracts.troveManager.baseRate()
-      expect(state.troveManager.baseRate.before).to.be.equal(0)
       state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
 
       await openTrove(contracts, {
@@ -663,7 +513,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
     it("Borrowing at zero base rate charges minimum fee", async () => {
       const { tx } = await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -677,7 +527,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       const BORROWING_FEE_FLOOR =
         await contracts.borrowerOperations.BORROWING_FEE_FLOOR()
       const expectedFee =
-        (BORROWING_FEE_FLOOR * MIN_NET_DEBT) / 1000000000000000000n
+        (BORROWING_FEE_FLOOR * minNetDebt) / 1000000000000000000n
       expect(expectedFee).to.equal(emittedFee)
     })
 
@@ -687,7 +537,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(state.troveManager.troves.before).to.equal(2n)
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -701,7 +551,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await contracts.troveManager.totalStakes()
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -720,7 +570,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -741,7 +591,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
 
       await openTrove(contracts, {
-        musdAmount: MIN_NET_DEBT,
+        musdAmount: minNetDebt,
         sender: carol.wallet,
       })
 
@@ -777,12 +627,14 @@ describe("BorrowerOperations in Normal Mode", () => {
             musdAmount: "0",
             sender: carol.wallet,
           }),
-        ).to.be.revertedWithPanic()
+        ).to.be.revertedWith(
+          "BorrowerOps: Trove's net debt must be greater than minimum",
+        )
       })
 
       it("Reverts if net debt < minimum net debt", async () => {
         const amount =
-          (await contracts.borrowerOperations.MIN_NET_DEBT()) -
+          (await contracts.borrowerOperations.minNetDebt()) -
           (await contracts.borrowerOperations.MUSD_GAS_COMPENSATION()) -
           1n
         await expect(
@@ -795,51 +647,6 @@ describe("BorrowerOperations in Normal Mode", () => {
         )
       })
 
-      it("Reverts if max fee > 100%", async () => {
-        await expect(
-          openTrove(contracts, {
-            musdAmount: "10,000",
-            sender: carol.wallet,
-            maxFeePercentage: "101",
-          }),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-      })
-
-      it("Reverts if max fee < 0.5% in Normal mode", async () => {
-        await expect(
-          openTrove(contracts, {
-            musdAmount: "10,000",
-            sender: carol.wallet,
-            maxFeePercentage: "0",
-          }),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-
-        await expect(
-          openTrove(contracts, {
-            musdAmount: "10,000",
-            sender: carol.wallet,
-            maxFeePercentage: "0.4999999999999999",
-          }),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-      })
-
-      it("Reverts if fee exceeds max fee percentage", async () => {
-        // setup
-        const newRate = to1e18(5) / 100n
-        await setNewRate(newRate)
-
-        // actual fee percentage: 0.05000000186264514
-        // user's max fee percentage:  0.005
-
-        await expect(
-          openTrove(contracts, {
-            musdAmount: "10,000",
-            sender: carol.wallet,
-            maxFeePercentage: "0.5",
-          }),
-        ).to.be.revertedWith("Fee exceeded provided maximum")
-      })
-
       it("Reverts when opening the trove would cause the TCR of the system to fall below the CCR", async () => {
         const TCR = await getTCR(contracts)
         assert.equal(TCR, to1e18(150) / 100n)
@@ -891,30 +698,10 @@ describe("BorrowerOperations in Normal Mode", () => {
 
         await checkOpenTroveEvents(transactions, TROVE_UPDATED_ABI)
       })
-
-      it("Emits a TroveUpdated event with the correct collateral and debt after changed baseRate", async () => {
-        // system state change via Tester functionality
-        const newRate = to1e18(5) / 100n
-        await setNewRate(newRate)
-
-        // data setup
-        const transactions = [
-          {
-            musdAmount: "5,000",
-            sender: dennis.wallet,
-          },
-          {
-            musdAmount: "3,000",
-            sender: eric.wallet,
-          },
-        ]
-        await checkOpenTroveEvents(transactions, TROVE_UPDATED_ABI)
-      })
     })
   })
 
   describe("openTroveWithSignature()", () => {
-    const maxFeePercentage = to1e18(100) / 100n
     const debtAmount = to1e18(2000)
     const assetAmount = to1e18(10)
     const upperHint = ZERO_ADDRESS
@@ -922,54 +709,38 @@ describe("BorrowerOperations in Normal Mode", () => {
 
     const types = {
       OpenTrove: [
-        { name: "borrower", type: "address" },
-        { name: "maxFeePercentage", type: "uint256" },
-        { name: "debtAmount", type: "uint256" },
         { name: "assetAmount", type: "uint256" },
-        { name: "upperHint", type: "address" },
-        { name: "lowerHint", type: "address" },
+        { name: "debtAmount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
         { name: "nonce", type: "uint256" },
         { name: "deadline", type: "uint256" },
       ],
     }
 
     it("opens a trove with a valid signature and deadline", async () => {
-      const borrower = carol.address
-      const contractAddress = addresses.borrowerOperations
-
-      const nonce = await contracts.borrowerOperations.getNonce(borrower)
-
-      const domain = {
-        name: "BorrowerOperations",
-        version: "1",
-        chainId: (await ethers.provider.getNetwork()).chainId,
-        verifyingContract: contractAddress,
-      }
-
-      const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+      const { borrower, recipient, nonce, domain, deadline } =
+        await setupSignatureTests()
 
       const value = {
-        borrower,
-        maxFeePercentage,
-        debtAmount,
         assetAmount,
-        upperHint,
-        lowerHint,
+        debtAmount,
+        borrower,
+        recipient,
         nonce,
         deadline,
       }
 
       const signature = await carol.wallet.signTypedData(domain, types, value)
 
-      await contracts.borrowerOperations
+      await contracts.borrowerOperationsSignatures
         .connect(carol.wallet)
         .openTroveWithSignature(
-          maxFeePercentage,
           debtAmount,
-          assetAmount,
           upperHint,
           lowerHint,
           carol.address,
+          carol.address,
           signature,
           deadline,
           { value: assetAmount },
@@ -982,384 +753,313 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(carol.trove.debt.after).to.be.equal(expectedDebt)
     })
 
-    it("correctly increments the nonce after a successful transaction", async () => {
-      const borrower = carol.address
-      const contractAddress = addresses.borrowerOperations
+    it("withdraws the mUSD to the recipient", async () => {
+      const { borrower, nonce, domain, deadline } = await setupSignatureTests()
 
-      const nonce = await contracts.borrowerOperations.getNonce(borrower)
+      const recipient = dennis.wallet.address
 
-      const domain = {
-        name: "BorrowerOperations",
-        version: "1",
-        chainId: (await ethers.provider.getNetwork()).chainId,
-        verifyingContract: contractAddress,
+      const value = {
+        assetAmount,
+        debtAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
       }
 
-      const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+      const signature = await carol.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, dennis, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(carol.wallet)
+        .openTroveWithSignature(
+          debtAmount,
+          upperHint,
+          lowerHint,
+          carol.address,
+          recipient,
+          signature,
+          deadline,
+          { value: assetAmount },
+        )
+
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.musd.after).to.equal(dennis.musd.before + debtAmount)
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, recipient, nonce, domain, deadline } =
+        await setupSignatureTests()
 
       const value = {
-        borrower,
-        maxFeePercentage,
-        debtAmount,
         assetAmount,
-        upperHint,
-        lowerHint,
+        debtAmount,
+        borrower,
+        recipient,
         nonce,
         deadline,
       }
 
       const signature = await carol.wallet.signTypedData(domain, types, value)
 
-      await contracts.borrowerOperations
+      await contracts.borrowerOperationsSignatures
         .connect(carol.wallet)
         .openTroveWithSignature(
-          maxFeePercentage,
           debtAmount,
-          assetAmount,
           upperHint,
           lowerHint,
           carol.address,
+          carol.address,
           signature,
           deadline,
           { value: assetAmount },
         )
 
-      const newNonce = await contracts.borrowerOperations.getNonce(borrower)
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
 
       expect(newNonce - nonce).to.equal(1)
     })
 
     context("Expected Reverts", () => {
-      it("reverts when the recovered address does not match the borrower's", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
-
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
-
-        const domain = {
-          name: "BorrowerOperations",
-          version: "1",
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
-        }
-
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
-
-        const value = {
+      const testRevert = async (
+        override: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests()
+
+        const data = {
+          assetAmount,
           borrower,
-          maxFeePercentage,
+          recipient,
           debtAmount,
-          assetAmount,
           upperHint,
           lowerHint,
           nonce,
           deadline,
+          signer: carol.wallet,
+          caller: carol.wallet,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
         }
 
-        // Sign with Alice's wallet instead of Carol's
-        const signature = await alice.wallet.signTypedData(domain, types, value)
-
-        await expect(
-          contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
-            ),
-        ).to.be.revertedWith("Invalid signature")
-      })
-
-      it("reverts when the deadline has passed", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
-
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
+        const overridenData = { ...data, ...override }
 
         const domain = {
-          name: "BorrowerOperations",
-          version: "1",
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
+          name: overridenData.domainName,
+          version: overridenData.domainVersion,
+          chainId: overridenData.chainId,
+          verifyingContract: overridenData.verifyingContract,
         }
 
-        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
-
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
+        const signedValues = {
+          assetAmount: data.assetAmount,
+          borrower: data.borrower,
+          recipient: data.recipient,
+          debtAmount: data.debtAmount,
+          nonce: overridenData.nonce,
+          deadline: data.deadline,
         }
 
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+        const signature = await overridenData.signer.signTypedData(
+          domain,
+          types,
+          signedValues,
+        )
 
         await expect(
-          contracts.borrowerOperations
-            .connect(carol.wallet)
+          contracts.borrowerOperationsSignatures
+            .connect(overridenData.caller)
             .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
+              overridenData.debtAmount,
+              overridenData.upperHint,
+              overridenData.lowerHint,
+              overridenData.borrower,
+              overridenData.recipient,
               signature,
-              deadline,
-              { value: assetAmount },
+              overridenData.deadline,
+              { value: overridenData.assetAmount },
             ),
-        ).to.be.revertedWith("Signature expired")
+        ).to.be.revertedWith(message)
+      }
+      it("reverts when the recovered address does not match the borrower's", async () => {
+        await testRevert({ signer: alice.wallet })
       })
 
-      it("reverts when the nonce is invalid", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
+      it("reverts when the signed recipient doesn't match the call", async () => {
+        await testRevert({ recipient: dennis.wallet })
+      })
 
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
 
-        const domain = {
-          name: "BorrowerOperations",
-          version: "1",
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
-        }
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 42 })
+      })
 
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+      it("reverts when the contract address is not correctly specified", async () => {
+        await testRevert(
+          { verifyingContract: addresses.pcv }, // PCV contract address instead of BorrowerOperations
+        )
+      })
 
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
-        }
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
 
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
 
-        // Submit a valid transaction to increment the nonce
-        await contracts.borrowerOperations
-          .connect(carol.wallet)
-          .openTroveWithSignature(
-            maxFeePercentage,
-            debtAmount,
-            assetAmount,
-            upperHint,
-            lowerHint,
-            carol.address,
-            signature,
-            deadline,
-            { value: assetAmount },
-          )
-
-        // Attempt to resend the same transaction which should now be invalid due to the nonce
+      it("reverts when the collateral amount is different than the signed value", async () => {
+        await testRevert({ assetAmount: to1e18("22") })
+      })
+
+      it("reverts when the debt is different than the signed value", async () => {
+        await testRevert({ debtAmount: to1e18("8000") })
+      })
+
+      it("reverts when the implementation is called from a non-BorrowerOperations or BorrowerOperationsSignatures address", async () => {
         await expect(
           contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
+            .connect(bob.wallet)
+            .restrictedOpenTrove(
+              bob.address,
+              bob.address,
               debtAmount,
-              assetAmount,
               upperHint,
               lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
             ),
-        ).to.be.revertedWith("Invalid signature")
+        ).to.be.revertedWith(
+          "BorrowerOps: Caller is not BorrowerOperationsSignatures",
+        )
       })
+    })
+  })
 
-      it("reverts when the contract address is not correctly specified", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.pcv // PCV contract address instead of BorrowerOperations
-
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
-
-        const domain = {
-          name: "BorrowerOperations",
-          version: "1",
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
-        }
-
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
-
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
-        }
-
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+  describe("proposeMinNetDebt()", () => {
+    it("sets the proposed min debt debt", async () => {
+      const newMinNetDebt = to1e18(500)
+      await contracts.borrowerOperations
+        .connect(council.wallet)
+        .proposeMinNetDebt(newMinNetDebt)
 
+      expect(await contracts.borrowerOperations.proposedMinNetDebt()).to.equal(
+        newMinNetDebt,
+      )
+    })
+    context("Expected Reverts", () => {
+      it("reverts if the proposed min net debt is not high enough", async () => {
         await expect(
           contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
-            ),
-        ).to.be.revertedWith("Invalid signature")
+            .connect(council.wallet)
+            .proposeMinNetDebt(10001n),
+        ).to.be.revertedWith("Minimum Net Debt must be at least $50.")
       })
+    })
+  })
 
-      it("reverts when the chain id is not correctly specified", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
+  describe("approveMinNetDebt()", () => {
+    it("requires two transactions to change the min net debt and a 7 day time delay", async () => {
+      const newMinNetDebt = to1e18(300)
+      await contracts.borrowerOperations
+        .connect(council.wallet)
+        .proposeMinNetDebt(newMinNetDebt)
 
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
+      // Simulate 7 days passing
+      const timeToIncrease = 7 * 24 * 60 * 60 // 7 days in seconds
+      await fastForwardTime(timeToIncrease)
 
-        const domain = {
-          name: "BorrowerOperations",
-          version: "1",
-          chainId: 0n, // Incorrect chain id
-          verifyingContract: contractAddress,
-        }
+      await contracts.borrowerOperations
+        .connect(council.wallet)
+        .approveMinNetDebt()
 
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+      expect(await contracts.borrowerOperations.minNetDebt()).to.equal(
+        newMinNetDebt,
+      )
+    })
 
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
-        }
+    it("changes the minimum net debt for users to open troves", async () => {
+      await expect(
+        openTrove(contracts, {
+          musdAmount: "300",
+          ICR: "200",
+          sender: carol.wallet,
+        }),
+      ).to.be.revertedWith(
+        "BorrowerOps: Trove's net debt must be greater than minimum",
+      )
 
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+      const newMinNetDebt = to1e18(300)
+      await contracts.borrowerOperations
+        .connect(council.wallet)
+        .proposeMinNetDebt(newMinNetDebt)
 
-        await expect(
-          contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
-            ),
-        ).to.be.revertedWith("Invalid signature")
-      })
+      // Simulate 7 days passing
+      const timeToIncrease = 7 * 24 * 60 * 60 // 7 days in seconds
+      await fastForwardTime(timeToIncrease)
 
-      it("reverts when the contract version is not correctly specified", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
+      await contracts.borrowerOperations
+        .connect(council.wallet)
+        .approveMinNetDebt()
 
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
+      await openTrove(contracts, {
+        musdAmount: "300",
+        ICR: "200",
+        sender: carol.wallet,
+      })
 
-        const domain = {
-          name: "BorrowerOperations",
-          version: "0", // Incorrect version
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
-        }
+      await updateTroveSnapshot(contracts, carol, "after")
 
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
+      expect(carol.trove.debt.after).to.be.greaterThan(0n)
+    })
 
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
-        }
+    context("Expected Reverts", () => {
+      it("reverts if the time delay has not finished", async () => {
+        await contracts.borrowerOperations
+          .connect(council.wallet)
+          .proposeMinNetDebt(to1e18(300))
 
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+        // Simulate 6 days passing
+        const timeToIncrease = 6 * 24 * 60 * 60 // 6 days in seconds
+        await fastForwardTime(timeToIncrease)
 
         await expect(
           contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
-            ),
-        ).to.be.revertedWith("Invalid signature")
+            .connect(council.wallet)
+            .approveMinNetDebt(),
+        ).to.be.revertedWith(
+          "Must wait at least 7 days before approving a change to Minimum Net Debt",
+        )
       })
 
-      it("reverts when the contract name is not correctly specified", async () => {
-        const borrower = carol.address
-        const contractAddress = addresses.borrowerOperations
-
-        const nonce = await contracts.borrowerOperations.getNonce(borrower)
-
-        const domain = {
-          name: "TroveManager", // Incorrect contract name
-          version: "1",
-          chainId: (await ethers.provider.getNetwork()).chainId,
-          verifyingContract: contractAddress,
-        }
-
-        const deadline = Math.floor(Date.now() / 1000) + 3600 // 1 hour from now
-
-        const value = {
-          borrower,
-          maxFeePercentage,
-          debtAmount,
-          assetAmount,
-          upperHint,
-          lowerHint,
-          nonce,
-          deadline,
-        }
+      it("reverts if called by a non-governance address", async () => {
+        await contracts.borrowerOperations
+          .connect(council.wallet)
+          .proposeMinNetDebt(to1e18(300))
 
-        const signature = await carol.wallet.signTypedData(domain, types, value)
+        // Simulate 8 days passing
+        const timeToIncrease = 8 * 24 * 60 * 60 // 8 days in seconds
+        await fastForwardTime(timeToIncrease)
 
         await expect(
           contracts.borrowerOperations
-            .connect(carol.wallet)
-            .openTroveWithSignature(
-              maxFeePercentage,
-              debtAmount,
-              assetAmount,
-              upperHint,
-              lowerHint,
-              carol.address,
-              signature,
-              deadline,
-              { value: assetAmount },
-            ),
-        ).to.be.revertedWith("Invalid signature")
+            .connect(alice.wallet)
+            .approveMinNetDebt(),
+        ).to.be.revertedWith(
+          "BorrowerOps: Only governance can call this function",
+        )
       })
     })
   })
@@ -1425,28 +1125,40 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(carol.trove.interestOwed.after).to.equal(0)
     })
 
-    it("removes principal and interest from system interest rate data", async () => {
+    it("removes principal and interest from the active pool", async () => {
       await setInterestRate(contracts, council, 1000)
       await setupCarolsTrove()
 
       await fastForwardTime(60 * 60 * 24 * 365)
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
 
       await contracts.musd
         .connect(bob.wallet)
         .transfer(carol.wallet, to1e18("10,000"))
+
       await contracts.borrowerOperations.connect(carol.wallet).closeTrove()
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshots(contracts, [alice, bob], "after")
 
       await updateTroveSnapshot(contracts, carol, "after")
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(0)
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(0)
+      expect(state.activePool.principal.after).to.equal(
+        alice.trove.debt.after + bob.trove.debt.after,
+      )
+      expect(state.activePool.interest.after).to.equal(0)
     })
 
     it("sets Trove's stake to zero", async () => {
@@ -1574,7 +1286,6 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       // do a transaction that will update Alice's reward snapshot values
       await contracts.borrowerOperations.withdrawMUSD(
-        to1e18(1),
         1n,
         alice.wallet,
         alice.wallet,
@@ -1792,70 +1503,309 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("addColl()", () => {
-    it("active Trove: adds the correct collateral amount to the Trove", async () => {
-      await updateTroveSnapshot(contracts, alice, "before")
-      expect(alice.trove.status.before).to.equal(1) // status
-
-      const collateralTopUp = to1e18(1)
-      await addColl(contracts, {
-        amount: collateralTopUp,
-        sender: alice.wallet,
-      })
+  describe("closeTroveWithSignature()", () => {
+    const types = {
+      CloseTrove: [
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
 
-      await updateTroveSnapshot(contracts, alice, "after")
-      expect(alice.trove.status.after).to.equal(1) // status
-      expect(alice.trove.collateral.after).to.equal(
-        alice.trove.collateral.before + collateralTopUp,
-      )
+    beforeEach(async () => {
+      // Artificially mint to Bob so he has enough to close his trove
+      await contracts.musd.unprotectedMint(bob.wallet, to1e18("20,000"))
     })
 
-    it("active Trove: Trove is in sortedList before and after", async () => {
-      expect(await contracts.sortedTroves.contains(alice.address)).to.equal(
-        true,
-      )
-      expect(await contracts.sortedTroves.isEmpty()).to.equal(false)
-
-      const collateralTopUp = to1e18(1)
-      await addColl(contracts, {
-        amount: collateralTopUp,
-        sender: alice.wallet,
-      })
+    it("closes the Trove with a valid signature", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      expect(await contracts.sortedTroves.contains(alice.address)).to.equal(
-        true,
-      )
-      expect(await contracts.sortedTroves.isEmpty()).to.equal(false)
-    })
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-    it("active Trove: updates the stake and updates the total stakes", async () => {
-      await updateTroveSnapshot(contracts, alice, "before")
-      state.troveManager.stakes.before =
-        await contracts.troveManager.totalStakes()
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      const collateralTopUp = to1e18(1)
-      await addColl(contracts, {
-        amount: collateralTopUp,
-        sender: alice.wallet,
-      })
+      // grant alice enough tokens to let her close bob's trove
+      await contracts.musd.unprotectedMint(alice.wallet, to1e18("40,000"))
 
-      await updateTroveSnapshot(contracts, alice, "after")
-      state.troveManager.stakes.after =
-        await contracts.troveManager.totalStakes()
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .closeTroveWithSignature(borrower, borrower, signature, deadline)
 
-      expect(state.troveManager.stakes.after).is.equal(
-        state.troveManager.stakes.before +
-          alice.trove.stake.after -
-          alice.trove.stake.before,
-      )
-      expect(state.troveManager.stakes.after).to.equal(
-        state.troveManager.stakes.before + collateralTopUp,
-      )
+      expect(bob.trove.status.after).to.equal(0)
     })
 
-    it("no mintlist, can add collateral", async () => {
-      await updateTroveSnapshot(contracts, alice, "before")
-      await removeMintlist(contracts, deployer.wallet)
+    it("releases collateral to the recipient", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const recipient = dennis.wallet.address
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      // grant alice enough tokens to let her close bob's trove
+      await contracts.musd.unprotectedMint(alice.wallet, to1e18("40,000"))
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, dennis, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .closeTroveWithSignature(borrower, recipient, signature, deadline)
+
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.btc.after).to.equal(
+        dennis.btc.before + bob.trove.collateral.before,
+      )
+    })
+
+    it("uses the caller's musd to close the trove", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const recipient = dennis.wallet.address
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      // grant alice enough tokens to let her close bob's trove
+      await contracts.musd.unprotectedMint(alice.wallet, to1e18("40,000"))
+
+      await updateWalletSnapshots(contracts, [alice, bob, dennis], "before")
+
+      // Alice pays for Bob's trove to close and send the funds to Dennis
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .closeTroveWithSignature(
+          borrower,
+          recipient,
+          signature,
+          deadline,
+          NO_GAS,
+        )
+
+      await updateWalletSnapshots(contracts, [alice, bob, dennis], "after")
+
+      // Alice must pay all of bob's debt except the $200 gas comp
+      expect(alice.musd.after).to.equal(
+        alice.musd.before - bob.trove.debt.before + to1e18(200),
+      )
+      expect(alice.btc.after).to.equal(alice.btc.before)
+
+      expect(bob.musd.after).to.equal(bob.musd.before)
+      expect(bob.btc.after).to.equal(bob.btc.before)
+
+      expect(dennis.musd.after).to.equal(dennis.musd.before)
+      expect(dennis.btc.after).to.equal(
+        dennis.btc.before + bob.trove.collateral.before,
+      )
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      // grant alice enough tokens to let her close bob's trove
+      await contracts.musd.unprotectedMint(alice.wallet, to1e18("40,000"))
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .closeTroveWithSignature(borrower, borrower, signature, deadline)
+
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
+    })
+
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        override: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, recipient, deadline, nonce } =
+          await setupSignatureTests(bob)
+
+        const data = {
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: alice.wallet,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+        }
+
+        const overridenData = { ...data, ...override }
+
+        const domain = {
+          name: overridenData.domainName,
+          version: overridenData.domainVersion,
+          chainId: overridenData.chainId,
+          verifyingContract: overridenData.verifyingContract,
+        }
+
+        const signedValues = {
+          borrower: data.borrower,
+          recipient: data.recipient,
+          nonce: overridenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const signature = await overridenData.signer.signTypedData(
+          domain,
+          types,
+          signedValues,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overridenData.caller)
+            .closeTroveWithSignature(
+              overridenData.borrower,
+              overridenData.recipient,
+              signature,
+              overridenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the signed recipient does not match the call", async () => {
+        await testRevert({ recipient: dennis.wallet.address })
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 42 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        await testRevert({ verifyingContract: addresses.pcv })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0 })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the implementation is called from a non-BorrowerOperationsSignatures address", async () => {
+        await expect(
+          contracts.borrowerOperations
+            .connect(bob.wallet)
+            .restrictedCloseTrove(bob.address, bob.address, bob.address),
+        ).to.be.revertedWith(
+          "BorrowerOps: Caller is not BorrowerOperationsSignatures",
+        )
+      })
+    })
+  })
+
+  describe("addColl()", () => {
+    it("active Trove: adds the correct collateral amount to the Trove", async () => {
+      await updateTroveSnapshot(contracts, alice, "before")
+      expect(alice.trove.status.before).to.equal(1) // status
+
+      const collateralTopUp = to1e18(1)
+      await addColl(contracts, {
+        amount: collateralTopUp,
+        sender: alice.wallet,
+      })
+
+      await updateTroveSnapshot(contracts, alice, "after")
+      expect(alice.trove.status.after).to.equal(1) // status
+      expect(alice.trove.collateral.after).to.equal(
+        alice.trove.collateral.before + collateralTopUp,
+      )
+    })
+
+    it("active Trove: Trove is in sortedList before and after", async () => {
+      expect(await contracts.sortedTroves.contains(alice.address)).to.equal(
+        true,
+      )
+      expect(await contracts.sortedTroves.isEmpty()).to.equal(false)
+
+      const collateralTopUp = to1e18(1)
+      await addColl(contracts, {
+        amount: collateralTopUp,
+        sender: alice.wallet,
+      })
+
+      expect(await contracts.sortedTroves.contains(alice.address)).to.equal(
+        true,
+      )
+      expect(await contracts.sortedTroves.isEmpty()).to.equal(false)
+    })
+
+    it("active Trove: updates the stake and updates the total stakes", async () => {
+      await updateTroveSnapshot(contracts, alice, "before")
+      state.troveManager.stakes.before =
+        await contracts.troveManager.totalStakes()
+
+      const collateralTopUp = to1e18(1)
+      await addColl(contracts, {
+        amount: collateralTopUp,
+        sender: alice.wallet,
+      })
+
+      await updateTroveSnapshot(contracts, alice, "after")
+      state.troveManager.stakes.after =
+        await contracts.troveManager.totalStakes()
+
+      expect(state.troveManager.stakes.after).is.equal(
+        state.troveManager.stakes.before +
+          alice.trove.stake.after -
+          alice.trove.stake.before,
+      )
+      expect(state.troveManager.stakes.after).to.equal(
+        state.troveManager.stakes.before + collateralTopUp,
+      )
+    })
+
+    it("no mintlist, can add collateral", async () => {
+      await updateTroveSnapshot(contracts, alice, "before")
+      await removeMintlist(contracts, deployer.wallet)
 
       const collateralTopUp = to1e18(1)
       await addColl(contracts, {
@@ -1901,10 +1851,11 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
     })
 
-    it("updates the system interest owed for the interest rate of the Trove", async () => {
+    it("updates the system interest", async () => {
       await testUpdatesSystemInterestOwed(
         contracts,
         state,
+        addresses,
         carol,
         dennis,
         council,
@@ -1928,66 +1879,236 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("withdrawColl()", () => {
-    it("updates the stake and updates the total stakes", async () => {
-      await setupCarolsTrove()
-      await updateTroveSnapshot(contracts, alice, "before")
+  describe("addCollWithSignature()", () => {
+    const assetAmount = to1e18(1)
+    const upperHint = ZERO_ADDRESS
+    const lowerHint = ZERO_ADDRESS
+
+    const types = {
+      AddColl: [
+        { name: "assetAmount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
+
+    it("adds the correct collateral amount to the trove with a valid signature", async () => {
       await updateTroveSnapshot(contracts, bob, "before")
-      await updateTroveSnapshot(contracts, carol, "before")
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      state.troveManager.stakes.before =
-        await contracts.troveManager.totalStakes()
+      const value = {
+        assetAmount,
+        borrower,
+        nonce,
+        deadline,
+      }
 
-      expect(carol.trove.stake.before).to.equal(carol.trove.collateral.before)
-      expect(
-        alice.trove.stake.before +
-          bob.trove.stake.before +
-          carol.trove.stake.before,
-      ).to.equal(state.troveManager.stakes.before)
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      const withdrawalAmount = 1n
-      await contracts.borrowerOperations
+      await contracts.borrowerOperationsSignatures
         .connect(carol.wallet)
-        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
-      await updateTroveSnapshot(contracts, carol, "after")
+        .addCollWithSignature(
+          upperHint,
+          lowerHint,
+          bob.address,
+          signature,
+          deadline,
+          { value: assetAmount },
+        )
 
-      state.troveManager.stakes.after =
-        await contracts.troveManager.totalStakes()
-      expect(
-        alice.trove.stake.before +
-          bob.trove.stake.before +
-          carol.trove.stake.after,
-      ).to.equal(state.troveManager.stakes.after)
-      expect(carol.trove.stake.after).to.equal(
-        carol.trove.stake.before - withdrawalAmount,
-      )
-      expect(carol.trove.collateral.after).to.equal(
-        carol.trove.collateral.before - withdrawalAmount,
+      await updateTroveSnapshot(contracts, bob, "after")
+
+      expect(bob.trove.collateral.after).to.equal(
+        bob.trove.collateral.before + assetAmount,
       )
     })
 
-    it("leaves the Trove active when the user withdraws less than all the collateral", async () => {
-      const withdrawalAmount = 1n
-      await setupCarolsTrove()
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      await contracts.borrowerOperations
+      const value = {
+        borrower,
+        assetAmount,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await contracts.borrowerOperationsSignatures
         .connect(carol.wallet)
-        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
+        .addCollWithSignature(
+          upperHint,
+          lowerHint,
+          bob.address,
+          signature,
+          deadline,
+          { value: assetAmount },
+        )
 
-      await updateTroveSnapshot(contracts, carol, "after")
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
 
-      expect(carol.trove.status.after).to.equal(1)
-      expect(await contracts.sortedTroves.contains(carol.wallet)).to.equal(true)
+      expect(newNonce - nonce).to.equal(1)
     })
 
-    it("reduces the Trove's collateral by the correct amount", async () => {
-      const withdrawalAmount = 1n
-      await setupCarolsTrove()
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, deadline, nonce } = await setupSignatureTests(bob)
 
-      await updateTroveSnapshot(contracts, carol, "before")
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
+        const data = {
+          assetAmount,
+          upperHint,
+          lowerHint,
+          borrower,
+          nonce,
+          deadline,
+          caller: carol.wallet,
+          signer: bob.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const overridenData = { ...data, ...overrides }
+
+        const value = {
+          assetAmount: data.assetAmount,
+          borrower: data.borrower,
+          nonce: overridenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const domain = {
+          name: overridenData.domainName,
+          version: overridenData.domainVersion,
+          chainId: overridenData.chainId,
+          verifyingContract: overridenData.verifyingContract,
+        }
+
+        const signature = await overridenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overridenData.caller)
+            .addCollWithSignature(
+              overridenData.upperHint,
+              overridenData.lowerHint,
+              overridenData.borrower,
+              signature,
+              overridenData.deadline,
+              { value: overridenData.assetAmount },
+            ),
+        ).to.be.revertedWith(message)
+      }
+
+      it("reverts when the recovered address does not match the borrower's", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 777 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the collateral amount is different than the signed value", async () => {
+        await testRevert({ assetAmount: to1e18("22") })
+      })
+    })
+  })
+
+  describe("withdrawColl()", () => {
+    it("updates the stake and updates the total stakes", async () => {
+      await setupCarolsTrove()
+      await updateTroveSnapshot(contracts, alice, "before")
+      await updateTroveSnapshot(contracts, bob, "before")
+      await updateTroveSnapshot(contracts, carol, "before")
+
+      state.troveManager.stakes.before =
+        await contracts.troveManager.totalStakes()
+
+      expect(carol.trove.stake.before).to.equal(carol.trove.collateral.before)
+      expect(
+        alice.trove.stake.before +
+          bob.trove.stake.before +
+          carol.trove.stake.before,
+      ).to.equal(state.troveManager.stakes.before)
+
+      const withdrawalAmount = 1n
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
+      await updateTroveSnapshot(contracts, carol, "after")
+
+      state.troveManager.stakes.after =
+        await contracts.troveManager.totalStakes()
+      expect(
+        alice.trove.stake.before +
+          bob.trove.stake.before +
+          carol.trove.stake.after,
+      ).to.equal(state.troveManager.stakes.after)
+      expect(carol.trove.stake.after).to.equal(
+        carol.trove.stake.before - withdrawalAmount,
+      )
+      expect(carol.trove.collateral.after).to.equal(
+        carol.trove.collateral.before - withdrawalAmount,
+      )
+    })
+
+    it("leaves the Trove active when the user withdraws less than all the collateral", async () => {
+      const withdrawalAmount = 1n
+      await setupCarolsTrove()
+
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
+
+      await updateTroveSnapshot(contracts, carol, "after")
+
+      expect(carol.trove.status.after).to.equal(1)
+      expect(await contracts.sortedTroves.contains(carol.wallet)).to.equal(true)
+    })
+
+    it("reduces the Trove's collateral by the correct amount", async () => {
+      const withdrawalAmount = 1n
+      await setupCarolsTrove()
+
+      await updateTroveSnapshot(contracts, carol, "before")
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .withdrawColl(withdrawalAmount, carol.wallet, carol.wallet)
       await updateTroveSnapshot(contracts, carol, "after")
 
       expect(carol.trove.collateral.after).to.equal(
@@ -2111,10 +2232,11 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
     })
 
-    it("updates the system interest owed for the Trove's interest rate", async () => {
+    it("updates the system interest", async () => {
       await testUpdatesSystemInterestOwed(
         contracts,
         state,
+        addresses,
         carol,
         dennis,
         council,
@@ -2230,228 +2352,328 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("withdrawMUSD()", () => {
-    it("updates the Trove's interest owed", async () => {
-      await testUpdatesInterestOwed(contracts, carol, council, () =>
-        contracts.borrowerOperations
-          .connect(carol.wallet)
-          .withdrawMUSD(to1e18(1), to1e18(1), carol.wallet, carol.wallet),
-      )
-    })
+  describe("withdrawCollWithSignature()", () => {
+    const amount = 1n
+    const upperHint = ZERO_ADDRESS
+    const lowerHint = ZERO_ADDRESS
 
-    it("updates the system interest owed for the Trove's interest rate", async () => {
-      await testUpdatesSystemInterestOwed(
-        contracts,
-        state,
-        carol,
-        dennis,
-        council,
-        () =>
-          contracts.borrowerOperations
-            .connect(carol.wallet)
-            .withdrawMUSD(to1e18(1), to1e18(1), carol.wallet, carol.wallet),
-      )
-    })
+    const types = {
+      WithdrawColl: [
+        { name: "amount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
 
-    it("decays a non-zero base rate", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      const newRate = to1e18(5) / 100n
-      await setupCarolsTroveAndAdjustRate()
+    it("reduces the Trove's collateral by the correct amount with a valid signature", async () => {
+      await setupCarolsTrove() // open additional trove to prevent going into recovery mode
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      await fastForwardTime(7200)
-      // first withdrawal
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      const value = {
+        amount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-      const baseRate2 = await contracts.troveManager.baseRate()
-      expect(newRate).is.greaterThan(baseRate2)
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      await fastForwardTime(3600)
-      // second withdrawal
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      await contracts.borrowerOperationsSignatures
+        .connect(carol.wallet)
+        .withdrawCollWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          bob.address,
+          bob.address,
+          signature,
+          deadline,
+        )
+
+      await updateTroveSnapshot(contracts, bob, "after")
 
-      const baseRate3 = await contracts.troveManager.baseRate()
-      expect(baseRate2).is.greaterThan(baseRate3)
+      expect(bob.trove.collateral.after).to.equal(
+        bob.trove.collateral.before - amount,
+      )
     })
 
-    it("doesn't change base rate if it is already zero", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      await setupCarolsTrove()
+    it("sends the collateral to the recipient with a valid signature", async () => {
+      await setupCarolsTrove() // open additional trove to prevent going into recovery mode
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      // first withdrawal
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      const recipient = dennis.wallet.address
+
+      const value = {
+        amount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-      expect(await contracts.troveManager.baseRate()).is.equal(0n)
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      await fastForwardTime(3600)
+      await updateWalletSnapshot(contracts, dennis, "before")
 
-      // second withdrawal
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      await contracts.borrowerOperationsSignatures
+        .connect(carol.wallet)
+        .withdrawCollWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          bob.address,
+          recipient,
+          signature,
+          deadline,
+        )
 
-      expect(await contracts.troveManager.baseRate()).is.equal(0n)
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.btc.after).to.equal(dennis.btc.before + amount)
     })
 
-    it("lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
+    it("correctly increments the nonce after a successful transaction", async () => {
       await setupCarolsTrove()
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      // Artificially make baseRate 5%
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
-
-      const lastFeeOpTime1 = await contracts.troveManager.lastFeeOperationTime()
-      await fastForwardTime(10)
+      const value = {
+        borrower,
+        recipient,
+        amount,
+        nonce,
+        deadline,
+      }
 
-      // trigger a fee
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      await expect(lastFeeOpTime1).to.equal(
-        await contracts.troveManager.lastFeeOperationTime(),
-      )
-      await fastForwardTime(60)
+      await contracts.borrowerOperationsSignatures
+        .connect(carol.wallet)
+        .withdrawCollWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          bob.address,
+          bob.address,
+          signature,
+          deadline,
+        )
 
-      // trigger second fee
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
 
-      expect(lastFeeOpTime1).to.be.lessThan(
-        await contracts.troveManager.lastFeeOperationTime(),
-      )
+      expect(newNonce - nonce).to.equal(1)
     })
 
-    it("borrowing at zero base rate changes mUSD fees", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      await setupCarolsTrove()
-
-      state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet)
-      state.pcv.musd.after = await contracts.musd.balanceOf(addresses.pcv)
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        await setupCarolsTrove()
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests(bob)
 
-      expect(state.pcv.musd.after).is.greaterThan(state.pcv.musd.before)
-    })
+        const data = {
+          amount,
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: carol.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
 
-    it("increases the Trove's mUSD debt by the correct amount", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      const borrowingRate = await contracts.troveManager.getBorrowingRate()
-      await setupCarolsTrove()
+        const overriddenData = { ...data, ...overrides }
 
-      await updateTroveSnapshot(contracts, carol, "before")
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
-      await updateTroveSnapshot(contracts, carol, "after")
+        const value = {
+          amount: data.amount,
+          borrower: data.borrower,
+          recipient: data.recipient,
+          nonce: overriddenData.nonce,
+          deadline: data.deadline,
+        }
 
-      expect(carol.trove.debt.after).to.equal(
-        carol.trove.debt.before +
-          (amount * (to1e18(1) + borrowingRate)) / to1e18(1),
-      )
-    })
+        const domain = {
+          name: overriddenData.domainName,
+          version: overriddenData.domainVersion,
+          chainId: overriddenData.chainId,
+          verifyingContract: overriddenData.verifyingContract,
+        }
 
-    it("borrowing at zero base rate sends debt request to user", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      await setupCarolsTrove()
+        const signature = await overriddenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
 
-      // Check baseRate is zero
-      expect(await contracts.troveManager.baseRate()).to.equal(0)
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overriddenData.caller)
+            .withdrawCollWithSignature(
+              overriddenData.amount,
+              upperHint,
+              lowerHint,
+              overriddenData.borrower,
+              overriddenData.recipient,
+              signature,
+              overriddenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
 
-      await fastForwardTime(7200)
+      it("reverts when the recovered address does not match the borrower's", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
 
-      carol.musd.before = await contracts.musd.balanceOf(carol.wallet)
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
-      carol.musd.after = await contracts.musd.balanceOf(carol.wallet)
+      it("reverts when the signed recipient does not match the call", async () => {
+        await testRevert({ recipient: dennis.address })
+      })
 
-      expect(carol.musd.after).to.equal(carol.musd.before + amount)
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 1234n })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the asset amount is does not match the signed value", async () => {
+        await testRevert({ amount: to1e18(777) })
+      })
     })
+  })
 
-    it("withdrawMUSD(): borrowing at non-zero base rate sends requested amount to the user", async () => {
-      const maxFeePercentage = to1e18(1)
+  describe("withdrawMUSD()", () => {
+    it("updates the Trove's interest owed", async () => {
+      await testUpdatesInterestOwed(contracts, carol, council, () =>
+        contracts.borrowerOperations
+          .connect(carol.wallet)
+          .withdrawMUSD(to1e18(1), carol.wallet, carol.wallet),
+      )
+    })
+
+    it("updates the system interest", async () => {
+      await testUpdatesSystemInterestOwed(
+        contracts,
+        state,
+        addresses,
+        carol,
+        dennis,
+        council,
+        () =>
+          contracts.borrowerOperations
+            .connect(carol.wallet)
+            .withdrawMUSD(to1e18(1), carol.wallet, carol.wallet),
+      )
+    })
+
+    it("borrowing at zero base rate changes mUSD fees", async () => {
       const amount = to1e18(1)
-      await setupCarolsTroveAndAdjustRate()
+      await setupCarolsTrove()
 
-      carol.musd.before = await contracts.musd.balanceOf(carol.wallet)
+      state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
       await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
-      carol.musd.after = await contracts.musd.balanceOf(carol.wallet)
+        .connect(bob.wallet)
+        .withdrawMUSD(amount, bob.wallet, bob.wallet)
+      state.pcv.musd.after = await contracts.musd.balanceOf(addresses.pcv)
 
-      expect(carol.musd.after).to.equal(carol.musd.before + amount)
+      expect(state.pcv.musd.after).is.greaterThan(state.pcv.musd.before)
     })
 
-    it("withdrawMUSD(): borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity", async () => {
-      const maxFeePercentage = to1e18(1)
+    it("increases the Trove's mUSD debt by the correct amount", async () => {
       const amount = to1e18(1)
+      const borrowingRate = await contracts.troveManager.BORROWING_FEE_FLOOR()
+      await setupCarolsTrove()
 
-      await openTrove(contracts, {
-        musdAmount: "20,000",
-        ICR: "500",
-        sender: carol.wallet,
-      })
+      await updateTroveSnapshot(contracts, carol, "before")
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
+      await updateTroveSnapshot(contracts, carol, "after")
+
+      expect(carol.trove.debt.after).to.equal(
+        carol.trove.debt.before +
+          (amount * (to1e18(1) + borrowingRate)) / to1e18(1),
+      )
+    })
 
-      const newRate = to1e18(5) / 100n
-      await setNewRate(newRate)
+    it("borrowing at zero base rate sends debt request to user", async () => {
+      const amount = to1e18(1)
+      await setupCarolsTrove()
 
-      // 30 seconds
-      fastForwardTime(30)
+      await fastForwardTime(7200)
 
-      // Borrower triggers a fee, before 60 minute decay interval has passed
+      carol.musd.before = await contracts.musd.balanceOf(carol.wallet)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
+      carol.musd.after = await contracts.musd.balanceOf(carol.wallet)
+
+      expect(carol.musd.after).to.equal(carol.musd.before + amount)
+    })
 
-      // 1 minute pass
-      fastForwardTime(60)
+    it("withdrawMUSD(): borrowing at non-zero base rate sends requested amount to the user", async () => {
+      const amount = to1e18(1)
+      await setupCarolsTroveAndAdjustRate()
 
-      // Borrower triggers another fee
+      carol.musd.before = await contracts.musd.balanceOf(carol.wallet)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
+      carol.musd.after = await contracts.musd.balanceOf(carol.wallet)
 
-      // Check base rate has decreased even though Borrower tried to stop it decaying
-      expect(await contracts.troveManager.baseRate()).is.lessThan(newRate)
+      expect(carol.musd.after).to.equal(carol.musd.before + amount)
     })
 
     it("borrowing at non-zero base rate sends mUSD fee to PCV contract", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
       await setupCarolsTroveAndAdjustRate()
 
       state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
       state.pcv.musd.after = await contracts.musd.balanceOf(addresses.pcv)
       expect(state.pcv.musd.after).to.greaterThan(state.pcv.musd.before)
     })
 
     it("borrowing at non-zero base records the (drawn debt + fee) on the Trove struct", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
       await setupCarolsTroveAndAdjustRate()
 
       await updateTroveSnapshot(contracts, carol, "before")
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -2469,7 +2691,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("increases mUSD debt in ActivePool by correct amount", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
 
       await setupCarolsTrove()
@@ -2487,7 +2708,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet)
+        .withdrawMUSD(amount, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updateContractsSnapshot(
@@ -2514,7 +2735,6 @@ describe("BorrowerOperations in Normal Mode", () => {
         await removeMintlist(contracts, deployer.wallet)
         await expect(
           contracts.borrowerOperations.withdrawMUSD(
-            to1e18(1),
             1n,
             alice.wallet,
             alice.wallet,
@@ -2522,6 +2742,21 @@ describe("BorrowerOperations in Normal Mode", () => {
         ).to.be.revertedWith("MUSD: Caller not allowed to mint")
       })
 
+      it("reverts when withdrawal exceeds maxBorrowingCapacity", async () => {
+        // Price increases 50,000 --> 300,000
+        const price = to1e18("300,000")
+        await contracts.mockAggregator.connect(deployer.wallet).setPrice(price)
+
+        const amount = to1e18("10,000")
+        await expect(
+          contracts.borrowerOperations
+            .connect(bob.wallet)
+            .withdrawMUSD(amount, bob.wallet, bob.wallet),
+        ).to.be.revertedWith(
+          "BorrowerOps: An operation that exceeds maxBorrowingCapacity is not permitted",
+        )
+      })
+
       it("reverts when withdrawal would leave trove with ICR < MCR", async () => {
         await setupCarolsTrove() // add extra trove so we can drop Bob's c-ratio below the MCR without putting the system into recovery mode
 
@@ -2533,13 +2768,12 @@ describe("BorrowerOperations in Normal Mode", () => {
           false,
         )
 
-        const maxFeePercentage = to1e18(1)
         const amount = 1n
 
         await expect(
           contracts.borrowerOperations
             .connect(bob.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet),
+            .withdrawMUSD(amount, bob.wallet, bob.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
@@ -2571,87 +2805,38 @@ describe("BorrowerOperations in Normal Mode", () => {
         await fastForwardTime(100 * 24 * 60 * 60)
 
         // Attempt to withdraw mUSD from the first trove, it should succeed
-        const maxFeePercentage = to1e18(1)
         const amount = to1e18(1)
         await contracts.borrowerOperations
           .connect(carol.wallet)
-          .withdrawMUSD(
-            maxFeePercentage,
-            amount,
-            carol.wallet,
-            carol.wallet,
-            NO_GAS,
-          )
+          .withdrawMUSD(amount, carol.wallet, carol.wallet, NO_GAS)
 
         // Attempt to withdraw mUSD from the second trove, it should fail due to interest accrued
         await expect(
           contracts.borrowerOperations
             .connect(dennis.wallet)
-            .withdrawMUSD(
-              maxFeePercentage,
-              amount,
-              dennis.wallet,
-              dennis.wallet,
-              NO_GAS,
-            ),
+            .withdrawMUSD(amount, dennis.wallet, dennis.wallet, NO_GAS),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
       })
 
-      it("reverts if max fee > 100%", async () => {
-        const maxFeePercentage = to1e18(1) + 1n
-        const amount = 1n
-        await expect(
-          contracts.borrowerOperations
-            .connect(bob.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-      })
-
-      it("reverts if max fee < 0.5% in Normal mode", async () => {
-        const maxFeePercentage = to1e18(0.005) - 1n
-        const amount = 1n
-        await expect(
-          contracts.borrowerOperations
-            .connect(bob.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-      })
-
-      it("reverts if fee exceeds max fee percentage", async () => {
-        const newRate = to1e18(5) / 100n
-        await setupCarolsTroveAndAdjustRate()
-
-        // Set max fee percentage to 4.999999999999999999
-        const maxFeePercentage = newRate - 1n
-        const amount = to1e18(1)
-        await expect(
-          contracts.borrowerOperations
-            .connect(bob.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet),
-        ).to.be.revertedWith("Fee exceeded provided maximum")
-      })
-
       it("reverts when calling address does not have active trove", async () => {
-        const maxFeePercentage = to1e18(1)
         const amount = to1e18(1)
 
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, carol.wallet, carol.wallet),
+            .withdrawMUSD(amount, carol.wallet, carol.wallet),
         ).to.be.revertedWith("BorrowerOps: Trove does not exist or is closed")
       })
 
       it("reverts when requested withdrawal amount is zero mUSD", async () => {
-        const maxFeePercentage = to1e18(1)
         const amount = 0
 
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, alice.wallet, alice.wallet),
+            .withdrawMUSD(amount, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Debt increase requires non-zero debtChange",
         )
@@ -2664,13 +2849,12 @@ describe("BorrowerOperations in Normal Mode", () => {
         expect(tcr).to.equal(to1e18(1.5))
 
         // Bob attempts to withdraw 1 mUSD.
-        const maxFeePercentage = to1e18(1)
         const amount = to1e18(1)
 
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, alice.wallet, alice.wallet),
+            .withdrawMUSD(amount, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in TCR < CCR is not permitted",
         )
@@ -2678,132 +2862,406 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("repayMUSD()", () => {
-    it("updates the Trove's interest owed", async () => {
-      await setInterestRate(contracts, council, 100)
-      await openTrove(contracts, {
-        musdAmount: "50,000",
-        ICR: "1000",
-        sender: carol.wallet,
-      })
-      await updateTroveSnapshot(contracts, carol, "before")
+  describe("withdrawMUSDWithSignature()", () => {
+    const amount = to1e18("1")
+    const upperHint = ZERO_ADDRESS
+    const lowerHint = ZERO_ADDRESS
 
-      const amount = to1e18("1,000")
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .repayMUSD(amount, carol.wallet, carol.wallet)
+    const types = {
+      WithdrawMUSD: [
+        { name: "amount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
 
-      await fastForwardTime(60 * 60 * 24 * 7) // fast-forward one week
+    beforeEach(async () => {
+      // Open an additional trove to keep us from going into recovery mode
+      await setupCarolsTrove()
+    })
 
-      await updateTroveSnapshot(contracts, carol, "after")
+    it("increases the Trove's debt by the correct amount with a valid signature", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { domain, deadline } = await setupSignatureTests()
+      const borrower = bob.address
+      const recipient = bob.address
+      const nonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      const value = {
+        amount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-      // Carol's debt repayment gets applied to interest first
-      expect(carol.trove.interestOwed.after).to.equal(0n)
-      expect(carol.trove.debt.after).to.equal(
-        carol.trove.debt.before -
-          amount +
-          calculateInterestOwed(
-            carol.trove.debt.before,
-            100,
-            carol.trove.lastInterestUpdateTime.before,
-            carol.trove.lastInterestUpdateTime.after,
-          ),
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .withdrawMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          borrower,
+          signature,
+          deadline,
+        )
+      const borrowingRate = await contracts.troveManager.BORROWING_FEE_FLOOR()
+      await updateTroveSnapshot(contracts, bob, "after")
+      expect(bob.trove.debt.after).to.equal(
+        bob.trove.debt.before +
+          (amount * (to1e18(1) + borrowingRate)) / to1e18(1),
       )
     })
 
-    it("updates the system interest owed for the Trove's interest rate", async () => {
-      await setInterestRate(contracts, council, 100)
-      await openTrove(contracts, {
-        musdAmount: "50,000",
-        ICR: "1000",
-        sender: carol.wallet,
-      })
-      await updateInterestRateDataSnapshot(contracts, state, 100, "before")
-
-      await setInterestRate(contracts, council, 200)
-      await openTrove(contracts, {
-        musdAmount: "50,000",
-        sender: dennis.wallet,
-      })
-      await updateInterestRateDataSnapshot(contracts, state, 200, "before")
+    it("send the mUSD to the recipient", async () => {
+      const { domain, deadline } = await setupSignatureTests()
+      const borrower = bob.address
+      const recipient = dennis.address
+      const nonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
 
-      const amount = to1e18("1,000")
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .repayMUSD(amount, carol.wallet, carol.wallet)
-      await updateTroveSnapshot(contracts, carol, "after")
-      await updateInterestRateDataSnapshot(contracts, state, 100, "after")
-      await updateTroveSnapshot(contracts, dennis, "after")
-      await updateInterestRateDataSnapshot(contracts, state, 200, "after")
+      const value = {
+        amount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-      // Check that 100 bps interest rate data is updated
-      expect(
-        state.interestRateManager.interestRateData[100].interest.after,
-      ).to.equal(0n)
-      expect(
-        state.interestRateManager.interestRateData[100].principal.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[100].principal.before -
-          amount +
-          calculateInterestOwed(
-            state.interestRateManager.interestRateData[100].principal.before,
-            100,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .before,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .after,
-          ),
-      )
+      const signature = await bob.wallet.signTypedData(domain, types, value)
 
-      // Check that 200 bps interest rate data is unchanged
-      expect(
-        state.interestRateManager.interestRateData[200].interest.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[200].interest.before,
-      )
-      expect(
-        state.interestRateManager.interestRateData[200].interest.after,
-      ).to.equal(dennis.trove.interestOwed.after)
-    })
+      await updateWalletSnapshot(contracts, dennis, "before")
 
-    it("succeeds when it would leave trove with net debt >= minimum net debt", async () => {
-      const amount = to1e18("1,000")
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .repayMUSD(amount, bob.wallet, bob.wallet)
-      await updateTroveSnapshot(contracts, bob, "after")
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .withdrawMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          recipient,
+          signature,
+          deadline,
+        )
 
-      expect(bob.trove.debt.after).is.greaterThan(MIN_NET_DEBT)
+      await updateWalletSnapshot(contracts, dennis, "after")
+      expect(dennis.musd.after).to.equal(dennis.musd.before + amount)
     })
 
-    it("succeeds when it would leave trove with net debt >= minimum net debt including interest", async () => {
-      // Set interest rate to 10% and open a trove now accruing interest
-      await setInterestRate(contracts, council, 1000)
-      await openTrove(contracts, {
-        sender: dennis.wallet,
-        musdAmount: "3,000",
-        ICR: "200",
-      })
-
-      // Fast-forward a year
-      await fastForwardTime(365 * 24 * 60 * 60)
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
 
-      await updateTroveSnapshot(contracts, dennis, "before")
+      const value = {
+        amount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
 
-      // Dennis's trove should succeed due to the interest putting him over the minimum
-      await contracts.borrowerOperations
-        .connect(dennis.wallet)
-        .repayMUSD(
-          dennis.trove.debt.before - MIN_NET_DEBT,
-          dennis.wallet,
-          dennis.wallet,
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .withdrawMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          borrower,
+          signature,
+          deadline,
         )
 
-      await updateTroveSnapshot(contracts, dennis, "after")
-      expect(dennis.trove.debt.after).to.be.greaterThan(MIN_NET_DEBT)
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
     })
 
-    it("reduces the Trove's mUSD debt by the correct amount", async () => {
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        override: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests(bob)
+
+        const data = {
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: alice.wallet,
+          types,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+        }
+
+        const overridenData = { ...data, ...override }
+
+        const domain = {
+          name: overridenData.domainName,
+          version: overridenData.domainVersion,
+          chainId: overridenData.chainId,
+          verifyingContract: overridenData.verifyingContract,
+        }
+
+        const signedValues = {
+          amount: data.amount,
+          borrower: data.borrower,
+          recipient: data.recipient,
+          nonce: overridenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const signature = await overridenData.signer.signTypedData(
+          domain,
+          types,
+          signedValues,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overridenData.caller)
+            .withdrawMUSDWithSignature(
+              overridenData.amount,
+              overridenData.upperHint,
+              overridenData.lowerHint,
+              overridenData.borrower,
+              overridenData.recipient,
+              signature,
+              overridenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
+
+      it("reverts when withdrawal exceeds maxBorrowingCapacity", async () => {
+        // Price increases 50,000 --> 300,000
+        const price = to1e18("300,000")
+        await contracts.mockAggregator.connect(deployer.wallet).setPrice(price)
+
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests(bob)
+
+        const changedAmount = to1e18("10,000")
+
+        const domain = {
+          name: "BorrowerOperationsSignatures",
+          version: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const signedValues = {
+          amount: changedAmount,
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+        }
+
+        const signature = await bob.wallet.signTypedData(
+          domain,
+          types,
+          signedValues,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(alice.wallet)
+            .withdrawMUSDWithSignature(
+              changedAmount,
+              upperHint,
+              lowerHint,
+              borrower,
+              recipient,
+              signature,
+              deadline,
+            ),
+        ).to.be.revertedWith(
+          "BorrowerOps: An operation that exceeds maxBorrowingCapacity is not permitted",
+        )
+      })
+
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the signed recipient does not match the call", async () => {
+        await testRevert({ recipient: dennis.address })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 111 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the musd amount does not match the signature", async () => {
+        await testRevert({ amount: to1e18(42) })
+      })
+    })
+  })
+
+  describe("repayMUSD()", () => {
+    it("updates the Trove's interest owed", async () => {
+      await setInterestRate(contracts, council, 100)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "1000",
+        sender: carol.wallet,
+      })
+      await updateTroveSnapshot(contracts, carol, "before")
+
+      const amount = to1e18("1,000")
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .repayMUSD(amount, carol.wallet, carol.wallet)
+
+      await fastForwardTime(60 * 60 * 24 * 7) // fast-forward one week
+
+      await updateTroveSnapshot(contracts, carol, "after")
+
+      // Carol's debt repayment gets applied to interest first
+      expect(carol.trove.interestOwed.after).to.equal(0n)
+      expect(carol.trove.debt.after).to.equal(
+        carol.trove.debt.before -
+          amount +
+          calculateInterestOwed(
+            carol.trove.debt.before,
+            100,
+            carol.trove.lastInterestUpdateTime.before,
+            carol.trove.lastInterestUpdateTime.after,
+          ),
+      )
+    })
+
+    it("updates the system interest", async () => {
+      await setInterestRate(contracts, council, 100)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "1000",
+        sender: carol.wallet,
+      })
+
+      await setInterestRate(contracts, council, 200)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        sender: dennis.wallet,
+      })
+
+      await updateTroveSnapshots(contracts, [carol, dennis], "before")
+
+      const amount = to1e18("1,000")
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .repayMUSD(amount, carol.wallet, carol.wallet)
+
+      await updateTroveSnapshots(contracts, [carol, dennis], "after")
+
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+
+      const carolInterest = calculateInterestOwed(
+        carol.trove.debt.before,
+        Number(carol.trove.interestRate.before),
+        carol.trove.lastInterestUpdateTime.before,
+        carol.trove.lastInterestUpdateTime.after,
+      )
+
+      // interest adjustment is the minimum of interest accrued and repayed amount
+      const interestAdjustment = carolInterest < amount ? carolInterest : amount
+
+      expect(state.activePool.interest.after).to.equal(
+        calculateInterestOwed(
+          carol.trove.debt.before,
+          Number(carol.trove.interestRate.before),
+          carol.trove.lastInterestUpdateTime.before,
+          carol.trove.lastInterestUpdateTime.after,
+        ) +
+          calculateInterestOwed(
+            dennis.trove.debt.before,
+            Number(dennis.trove.interestRate.before),
+            dennis.trove.lastInterestUpdateTime.before,
+            carol.trove.lastInterestUpdateTime.after,
+          ) -
+          interestAdjustment,
+      )
+    })
+
+    it("succeeds when it would leave trove with net debt >= minimum net debt", async () => {
+      const amount = to1e18("1,000")
+      await contracts.borrowerOperations
+        .connect(bob.wallet)
+        .repayMUSD(amount, bob.wallet, bob.wallet)
+      await updateTroveSnapshot(contracts, bob, "after")
+
+      expect(bob.trove.debt.after).is.greaterThan(minNetDebt)
+    })
+
+    it("succeeds when it would leave trove with net debt >= minimum net debt including interest", async () => {
+      // Set interest rate to 10% and open a trove now accruing interest
+      await setInterestRate(contracts, council, 1000)
+      await openTrove(contracts, {
+        sender: dennis.wallet,
+        musdAmount: "3,000",
+        ICR: "200",
+      })
+
+      // Fast-forward a year
+      await fastForwardTime(365 * 24 * 60 * 60)
+
+      await updateTroveSnapshot(contracts, dennis, "before")
+
+      // Dennis's trove should succeed due to the interest putting him over the minimum
+      await contracts.borrowerOperations
+        .connect(dennis.wallet)
+        .repayMUSD(
+          dennis.trove.debt.before - minNetDebt,
+          dennis.wallet,
+          dennis.wallet,
+        )
+
+      await updateTroveSnapshot(contracts, dennis, "after")
+      expect(dennis.trove.debt.after).to.be.greaterThan(minNetDebt)
+    })
+
+    it("reduces the Trove's mUSD debt by the correct amount", async () => {
       const amount = to1e18("1,000")
       await updateTroveSnapshot(contracts, bob, "before")
       await contracts.borrowerOperations
@@ -3027,68 +3485,259 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
-  describe("adjustTrove()", () => {
-    it("removes principal and interest from system interest rate data when decreasing debt", async () => {
-      await setInterestRate(contracts, council, 1000)
-      await openTrove(contracts, {
-        musdAmount: "10,000",
-        ICR: "2000",
-        sender: carol.wallet,
-      })
-      await openTrove(contracts, {
-        musdAmount: "10,000",
-        ICR: "2000",
-        sender: dennis.wallet,
-      })
+  describe("repayMUSDWithSignature()", () => {
+    const amount = to1e18("100")
+    const upperHint = ZERO_ADDRESS
+    const lowerHint = ZERO_ADDRESS
 
-      await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
+    const types = {
+      RepayMUSD: [
+        { name: "amount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
-      await updateTroveSnapshots(contracts, [carol, dennis], "before")
+    it("reduces the Trove's debt by the correct amount with a valid signature", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+      const value = {
+        amount,
+        borrower,
+        nonce,
+        deadline,
+      }
 
-      const maxFeePercentage = to1e18(1)
-      const debtChange = to1e18(5000)
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .repayMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          signature,
+          deadline,
         )
+      await updateTroveSnapshot(contracts, bob, "after")
+      expect(bob.trove.debt.after).to.equal(bob.trove.debt.before - amount)
+    })
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
-      await updateTroveSnapshots(contracts, [carol, dennis], "after")
-      const after = BigInt(await getLatestBlockTimestamp())
+    it("the caller pays the mUSD", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+      const value = {
+        amount,
+        borrower,
+        nonce,
+        deadline,
+      }
 
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(
-        calculateInterestOwed(
-          dennis.trove.debt.before,
-          1000,
-          dennis.trove.lastInterestUpdateTime.before,
-          after,
-        ),
-      )
+      await updateWalletSnapshot(contracts, alice, "before")
+      await updateWalletSnapshot(contracts, bob, "before")
 
-      const principalAdjustment =
-        debtChange -
-        calculateInterestOwed(
-          carol.trove.debt.before,
-          1000,
-          carol.trove.lastInterestUpdateTime.before,
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .repayMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          signature,
+          deadline,
+        )
+
+      await updateWalletSnapshot(contracts, alice, "after")
+      await updateWalletSnapshot(contracts, bob, "after")
+      expect(alice.musd.after).to.equal(alice.musd.before - amount)
+      expect(bob.musd.after).to.equal(bob.musd.before)
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+      const value = {
+        amount,
+        borrower,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .repayMUSDWithSignature(
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          signature,
+          deadline,
+        )
+
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
+    })
+
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, nonce, deadline } = await setupSignatureTests(bob)
+
+        const data = {
+          amount,
+          upperHint,
+          lowerHint,
+          borrower,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: alice.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const overriddenData = { ...data, ...overrides }
+
+        const value = {
+          amount: data.amount,
+          borrower: data.borrower,
+          nonce: overriddenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const domain = {
+          name: overriddenData.domainName,
+          version: overriddenData.domainVersion,
+          chainId: overriddenData.chainId,
+          verifyingContract: overriddenData.verifyingContract,
+        }
+
+        const signature = await overriddenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overriddenData.caller)
+            .repayMUSDWithSignature(
+              overriddenData.amount,
+              overriddenData.upperHint,
+              overriddenData.lowerHint,
+              overriddenData.borrower,
+              signature,
+              overriddenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 87 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the amount does not match the signature", async () => {
+        await testRevert({ amount: to1e18(333) })
+      })
+    })
+  })
+
+  describe("adjustTrove()", () => {
+    it("removes principal and interest from system interest", async () => {
+      await setInterestRate(contracts, council, 1000)
+      await openTrove(contracts, {
+        musdAmount: "10,000",
+        ICR: "2000",
+        sender: carol.wallet,
+      })
+      await openTrove(contracts, {
+        musdAmount: "10,000",
+        ICR: "2000",
+        sender: dennis.wallet,
+      })
+
+      await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
+
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateTroveSnapshots(contracts, [carol, dennis], "before")
+
+      const debtChange = to1e18(5000)
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet)
+
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshots(contracts, [carol, dennis], "after")
+      const after = BigInt(await getLatestBlockTimestamp())
+
+      expect(state.activePool.interest.after).to.equal(
+        calculateInterestOwed(
+          dennis.trove.debt.before,
+          1000,
+          dennis.trove.lastInterestUpdateTime.before,
+          after,
+        ),
+      )
+
+      const principalAdjustment =
+        debtChange -
+        calculateInterestOwed(
+          carol.trove.debt.before,
+          1000,
+          carol.trove.lastInterestUpdateTime.before,
           after,
         )
 
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[1000].principal.before -
-          principalAdjustment,
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before - principalAdjustment,
       )
     })
 
@@ -3107,30 +3756,31 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await updateTroveSnapshots(contracts, [carol, dennis], "before")
 
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(5000)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
       await updateTroveSnapshots(contracts, [carol, dennis], "after")
       const after = BigInt(await getLatestBlockTimestamp())
 
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(
+      expect(state.activePool.interest.after).to.be.closeTo(
         calculateInterestOwed(
           dennis.trove.debt.before,
           1000,
@@ -3143,16 +3793,13 @@ describe("BorrowerOperations in Normal Mode", () => {
             carol.trove.lastInterestUpdateTime.before,
             after,
           ),
+        2n,
       )
 
       const fee = await contracts.troveManager.getBorrowingFee(debtChange)
 
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[1000].principal.before +
-          debtChange +
-          fee,
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before + debtChange + fee,
       )
     })
 
@@ -3160,15 +3807,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       await testUpdatesInterestOwed(contracts, carol, council, () =>
         contracts.borrowerOperations
           .connect(carol.wallet)
-          .adjustTrove(
-            to1e18(1),
-            0,
-            to1e18(1),
-            true,
-            0,
-            carol.wallet,
-            carol.wallet,
-          ),
+          .adjustTrove(0, to1e18(1), true, carol.wallet, carol.wallet),
       )
     })
 
@@ -3176,290 +3815,112 @@ describe("BorrowerOperations in Normal Mode", () => {
       await testUpdatesSystemInterestOwed(
         contracts,
         state,
+        addresses,
         carol,
         dennis,
         council,
         () =>
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              to1e18(1),
-              true,
-              0,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, to1e18(1), true, carol.wallet, carol.wallet),
       )
     })
 
-    it("decays a non-zero base rate", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(1)
-      const newRate = to1e18(5) / 100n
-      await setupCarolsTroveAndAdjustRate()
-      await fastForwardTime(7200)
-
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
-
-      const baseRate2 = await contracts.troveManager.baseRate()
-      expect(newRate).is.greaterThan(baseRate2)
+    it("adjusts maxBorrowingCapacity proportionally on collateral withdrawal", async () => {
+      await setupCarolsTrove()
+      await updateTroveSnapshot(contracts, carol, "before")
 
-      await fastForwardTime(3600)
-      // second withdrawal
+      const collWithdrawal = carol.trove.collateral.before / 5n // 20% of current collateral
       await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(to1e18(1), 0, to1e18(37), true, 0, bob.wallet, bob.wallet)
-
-      const baseRate3 = await contracts.troveManager.baseRate()
-      expect(baseRate2).is.greaterThan(baseRate3)
-    })
-
-    it("doesn't decay a non-zero base rate when user issues 0 debt", async () => {
-      const maxFeePercentage = to1e18(1)
-      const assetAmount = to1e18(1)
+        .connect(carol.wallet)
+        .adjustTrove(collWithdrawal, 0, false, carol.wallet, carol.wallet)
 
-      await setupCarolsTroveAndAdjustRate()
-      await fastForwardTime(7200)
-      await updateTroveManagerSnapshot(contracts, state, "before")
+      await updateTroveSnapshot(contracts, carol, "after")
 
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          0,
-          false,
-          assetAmount,
-          bob.wallet,
-          bob.wallet,
-          {
-            value: assetAmount,
-          },
-        )
+      const price = await contracts.priceFeed.fetchPrice()
+      const expectedMaxBorrowingCapacity =
+        (carol.trove.collateral.after * price) / to1e18("1.1")
 
-      await updateTroveManagerSnapshot(contracts, state, "after")
-      // Check baseRate has not decreased
-      expect(state.troveManager.baseRate.after).is.equal(
-        state.troveManager.baseRate.before,
+      expect(carol.trove.maxBorrowingCapacity.after).to.be.equal(
+        expectedMaxBorrowingCapacity,
       )
     })
 
-    it("doesn't change base rate if it is already zero", async () => {
-      const maxFeePercentage = to1e18(1)
-
+    it("does not increase maxBorrowingCapacity on collateral withdrawal even if price has risen", async () => {
       await setupCarolsTrove()
-      await fastForwardTime(7200)
-      await updateTroveManagerSnapshot(contracts, state, "before")
-
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          to1e18(37),
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
-
-      await updateTroveManagerSnapshot(contracts, state, "after")
-      // Check baseRate has not decreased
-      expect(state.troveManager.baseRate.after).is.equal(
-        state.troveManager.baseRate.before,
-      )
-      expect(state.troveManager.baseRate.after).is.equal(0)
-    })
-
-    it("lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation", async () => {
-      const maxFeePercentage = to1e18(1)
-
-      await setupCarolsTroveAndAdjustRate()
-      await contracts.troveManager.setLastFeeOpTimeToNow()
-      await updateTroveManagerSnapshot(contracts, state, "before")
+      await updateTroveSnapshot(contracts, carol, "before")
 
-      await fastForwardTime(10)
+      // Increase the price to double Carol's ICR
+      await dropPrice(contracts, deployer, carol, to1e18("600"))
 
+      const collWithdrawal = 1n
       await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          to1e18(37),
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
+        .connect(carol.wallet)
+        .adjustTrove(collWithdrawal, 0, false, carol.wallet, carol.wallet)
 
-      await updateTroveManagerSnapshot(contracts, state, "after")
+      await updateTroveSnapshot(contracts, carol, "after")
 
-      expect(state.troveManager.lastFeeOperationTime.before).is.equal(
-        state.troveManager.lastFeeOperationTime.after,
+      expect(carol.trove.maxBorrowingCapacity.after).to.be.equal(
+        carol.trove.maxBorrowingCapacity.before,
       )
-      expect(state.troveManager.lastFeeOperationTime.before).is.greaterThan(0)
     })
 
-    it("borrower can't grief the baseRate and stop it decaying by issuing debt at higher frequency than the decay granularity", async () => {
-      const maxFeePercentage = to1e18(1)
-
-      await setupCarolsTroveAndAdjustRate()
-      await updateTroveManagerSnapshot(contracts, state, "before")
-
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          to1e18(37),
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
+    it("decreases maxBorrowingCapacity on collateral withdrawal if price has fallen", async () => {
+      await setupCarolsTrove()
+      await updateTroveSnapshot(contracts, carol, "before")
 
-      await fastForwardTime(60)
+      const price = await dropPrice(contracts, deployer, carol, to1e18("290"))
 
+      const collWithdrawal = 1n
       await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          to1e18(37),
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
-      await updateTroveManagerSnapshot(contracts, state, "after")
-      expect(state.troveManager.baseRate.before).to.be.greaterThan(
-        state.troveManager.baseRate.after,
-      )
-    })
-
-    it("borrowing at non-zero base records the (drawn debt + fee) on the Trove struct", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(37)
-
-      await setupCarolsTroveAndAdjustRate()
+        .connect(carol.wallet)
+        .adjustTrove(collWithdrawal, 0, false, carol.wallet, carol.wallet)
 
-      await updateTroveSnapshot(contracts, bob, "before")
-      await fastForwardTime(60)
+      await updateTroveSnapshot(contracts, carol, "after")
 
-      const tx = await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          bob.wallet,
-          bob.wallet,
-        )
+      const expectedMaxBorrowingCapacity =
+        (carol.trove.collateral.after * price) / to1e18("1.1")
 
-      const emittedFee = await getEventArgByName(
-        tx,
-        BORROWING_FEE_PAID,
-        "BorrowingFeePaid",
-        1,
+      expect(carol.trove.maxBorrowingCapacity.after).to.be.lessThan(
+        carol.trove.maxBorrowingCapacity.before,
       )
-
-      await updateTroveSnapshot(contracts, bob, "after")
-
-      expect(bob.trove.debt.after).to.equal(
-        bob.trove.debt.before + amount + emittedFee,
+      expect(carol.trove.maxBorrowingCapacity.after).to.be.equal(
+        expectedMaxBorrowingCapacity,
       )
     })
 
-    it("Borrowing at non-zero base rate sends requested amount to the user", async () => {
-      const maxFeePercentage = to1e18(1)
+    it("Borrowing at zero base rate sends total requested mUSD to the user", async () => {
       const amount = to1e18(37)
 
-      await setupCarolsTroveAndAdjustRate()
+      await setupCarolsTrove()
       await updateWalletSnapshot(contracts, carol, "before")
       await fastForwardTime(7200)
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
-
-      await updateWalletSnapshot(contracts, carol, "after")
-      expect(carol.musd.after).to.equal(carol.musd.before + amount)
-    })
-
-    it("Borrowing at zero base rate sends total requested mUSD to the user", async () => {
-      const maxFeePercentage = to1e18(1)
-      const amount = to1e18(37)
-
-      await setupCarolsTrove()
-      await updateWalletSnapshot(contracts, carol, "before")
-      await fastForwardTime(7200)
-
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, amount, true, carol.wallet, carol.wallet)
 
       await updateWalletSnapshot(contracts, carol, "after")
       expect(carol.musd.after).to.equal(carol.musd.before + amount)
     })
 
     it("Borrowing at zero base rate changes mUSD balance of PCV contract", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(37)
 
       state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
 
       await setupCarolsTrove()
       await fastForwardTime(7200)
-      expect(await contracts.troveManager.baseRate()).is.equal(0)
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, amount, true, carol.wallet, carol.wallet)
 
       state.pcv.musd.after = await contracts.musd.balanceOf(addresses.pcv)
       expect(state.pcv.musd.after).to.be.greaterThan(state.pcv.musd.before)
     })
 
     it("borrowing at non-zero base rate sends mUSD fee to PCV contract", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(37)
 
       state.pcv.musd.before = await contracts.musd.balanceOf(addresses.pcv)
@@ -3469,22 +3930,13 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, amount, true, carol.wallet, carol.wallet)
 
       state.pcv.musd.after = await contracts.musd.balanceOf(addresses.pcv)
       expect(state.pcv.musd.after).to.be.greaterThan(state.pcv.musd.before)
     })
 
     it("With 0 coll change, doesnt change borrower's coll or ActivePool coll", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(37)
 
       await setupCarolsTrove()
@@ -3499,15 +3951,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          amount,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, amount, true, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updateContractsSnapshot(
@@ -3527,7 +3971,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("With 0 debt change, doesnt change borrower's debt or ActivePool debt", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
 
       await setupCarolsTrove()
@@ -3542,18 +3985,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          0,
-          false,
-          amount,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: amount,
-          },
-        )
+        .adjustTrove(0, 0, false, carol.wallet, carol.wallet, {
+          value: amount,
+        })
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updateContractsSnapshot(
@@ -3576,19 +4010,10 @@ describe("BorrowerOperations in Normal Mode", () => {
       await updateTroveSnapshot(contracts, carol, "before")
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
       const expectedInterest = calculateInterestOwed(
@@ -3610,23 +4035,13 @@ describe("BorrowerOperations in Normal Mode", () => {
       await updateTroveSnapshot(contracts, carol, "before")
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(5000)
       const collChange = to1e18(1)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       await updateTroveSnapshot(contracts, carol, "after")
       const expectedInterest = calculateInterestOwed(
@@ -3645,7 +4060,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's debt and coll with an increase in both", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3653,18 +4067,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -3683,7 +4088,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's debt and coll with a decrease in both", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3691,15 +4095,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          collChange,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(collChange, debtChange, false, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -3712,7 +4108,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's debt and coll with coll increase, debt decrease", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3720,18 +4115,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -3744,7 +4130,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's debt and coll with coll decrease, debt increase", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3752,15 +4137,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          collChange,
-          debtChange,
-          true,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(collChange, debtChange, true, carol.wallet, carol.wallet)
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -3779,7 +4156,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's stake and totalStakes with a coll increase", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
 
       await setupCarolsTrove()
@@ -3788,18 +4164,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          0,
-          false,
-          amount,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: amount,
-          },
-        )
+        .adjustTrove(0, 0, false, carol.wallet, carol.wallet, {
+          value: amount,
+        })
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updateTroveManagerSnapshot(contracts, state, "after")
@@ -3813,7 +4180,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("updates borrower's stake and totalStakes with a coll decrease", async () => {
-      const maxFeePercentage = to1e18(1)
       const amount = to1e18(1)
 
       await setupCarolsTrove()
@@ -3822,15 +4188,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          amount,
-          0,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(amount, 0, false, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updateTroveManagerSnapshot(contracts, state, "after")
@@ -3844,7 +4202,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("changes mUSD balance by the requested decrease", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3852,15 +4209,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          collChange,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(collChange, debtChange, false, carol.wallet, carol.wallet)
 
       await updateWalletSnapshot(contracts, carol, "after")
       expect(carol.musd.after).to.be.equal(carol.musd.before - debtChange)
@@ -3873,20 +4222,11 @@ describe("BorrowerOperations in Normal Mode", () => {
       await updateTroveSnapshot(contracts, carol, "before")
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(5000)
       const collChange = to1e18(1)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          collChange,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(collChange, debtChange, false, carol.wallet, carol.wallet)
 
       await updateWalletSnapshot(contracts, carol, "after")
       await updateTroveSnapshot(contracts, carol, "after")
@@ -3896,7 +4236,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("changes mUSD balance by the requested increase", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3904,25 +4243,15 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       await updateWalletSnapshot(contracts, carol, "after")
       expect(carol.musd.after).to.be.equal(carol.musd.before + debtChange)
     })
 
     it("Changes the activePool collateral and raw collateral balance by the requested decrease", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3936,15 +4265,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          collChange,
-          debtChange,
-          false,
-          0,
-          carol.wallet,
-          carol.wallet,
-        )
+        .adjustTrove(collChange, debtChange, false, carol.wallet, carol.wallet)
       await updateContractsSnapshot(
         contracts,
         state,
@@ -3962,7 +4283,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("Changes the activePool collateral and raw collateral balance by the amount of collateral sent", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -3976,18 +4296,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
       await updateContractsSnapshot(
         contracts,
         state,
@@ -4005,7 +4316,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("Changes the mUSD debt in ActivePool by requested decrease", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -4019,18 +4329,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
       await updateContractsSnapshot(
         contracts,
         state,
@@ -4057,23 +4358,13 @@ describe("BorrowerOperations in Normal Mode", () => {
       )
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(5000)
       const collChange = to1e18(1)
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
       await updateContractsSnapshot(
         contracts,
         state,
@@ -4095,7 +4386,6 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("Changes the mUSD debt in ActivePool by requested increase", async () => {
-      const maxFeePercentage = to1e18(1)
       const debtChange = to1e18(50)
       const collChange = to1e18(1)
       await setupCarolsTrove()
@@ -4109,18 +4399,9 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -4155,7 +4436,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(to1e18(1), 0, amount, false, 0, carol.wallet, carol.wallet)
+        .adjustTrove(0, amount, false, carol.wallet, carol.wallet)
 
       await updateTroveSnapshot(contracts, carol, "after")
       const expectedInterest = calculateInterestOwed(
@@ -4191,15 +4472,9 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              false,
-              collateralTopUp,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(0, debtChange, false, alice.wallet, alice.wallet, {
+              value: collateralTopUp,
+            }),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
@@ -4223,15 +4498,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              false,
-              0,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, debtChange, false, carol.wallet, carol.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
@@ -4258,65 +4525,14 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              false,
-              collateralTopUp,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(0, debtChange, false, alice.wallet, alice.wallet, {
+              value: collateralTopUp,
+            }),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
       })
 
-      it("reverts if max fee < 0.5% in Normal mode", async () => {
-        const collateralTopUp = to1e18(0.02)
-        const debtChange = to1e18(1)
-
-        await expect(
-          contracts.borrowerOperations
-            .connect(alice.wallet)
-            .adjustTrove(
-              0,
-              0,
-              debtChange,
-              true,
-              collateralTopUp,
-              alice.wallet,
-              alice.wallet,
-            ),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-        await expect(
-          contracts.borrowerOperations
-            .connect(alice.wallet)
-            .adjustTrove(
-              1n,
-              0,
-              debtChange,
-              true,
-              collateralTopUp,
-              alice.wallet,
-              alice.wallet,
-            ),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-        await expect(
-          contracts.borrowerOperations
-            .connect(alice.wallet)
-            .adjustTrove(
-              4999999999999999n,
-              0,
-              debtChange,
-              true,
-              collateralTopUp,
-              alice.wallet,
-              alice.wallet,
-            ),
-        ).to.be.revertedWith("Max fee percentage must be between 0.5% and 100%")
-      })
-
       it("reverts when calling address has no active trove", async () => {
         const collateralTopUp = to1e18(1)
         const debtChange = to1e18(50)
@@ -4324,15 +4540,9 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              true,
-              collateralTopUp,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet, {
+              value: collateralTopUp,
+            }),
         ).to.be.revertedWith("BorrowerOps: Trove does not exist or is closed")
       })
 
@@ -4341,15 +4551,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              true,
-              0,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in TCR < CCR is not permitted",
         )
@@ -4368,11 +4570,9 @@ describe("BorrowerOperations in Normal Mode", () => {
           contracts.borrowerOperations
             .connect(alice.wallet)
             .adjustTrove(
-              to1e18(1),
               0,
               remainingDebt + 1n,
               false,
-              assetAmount,
               alice.wallet,
               alice.wallet,
               {
@@ -4391,11 +4591,9 @@ describe("BorrowerOperations in Normal Mode", () => {
           contracts.borrowerOperations
             .connect(alice.wallet)
             .adjustTrove(
-              to1e18(1),
               alice.trove.collateral.before + 1n,
               0,
               true,
-              0,
               alice.wallet,
               alice.wallet,
             ),
@@ -4415,15 +4613,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              to1e18(1),
-              0,
-              debtChange,
-              true,
-              0,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
         )
@@ -4435,11 +4625,9 @@ describe("BorrowerOperations in Normal Mode", () => {
           contracts.borrowerOperations
             .connect(alice.wallet)
             .adjustTrove(
-              to1e18(1),
               alice.trove.collateral.before,
               alice.trove.debt.before,
               true,
-              0,
               alice.wallet,
               alice.wallet,
             ),
@@ -4452,7 +4640,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(to1e18(1), 0, 0, true, 0, alice.wallet, alice.wallet),
+            .adjustTrove(0, 0, true, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Debt increase requires non-zero debtChange",
         )
@@ -4464,11 +4652,9 @@ describe("BorrowerOperations in Normal Mode", () => {
           contracts.borrowerOperations
             .connect(alice.wallet)
             .adjustTrove(
-              to1e18(1),
               to1e18(1),
               to1e18(1),
               true,
-              assetAmount,
               alice.wallet,
               alice.wallet,
               {
@@ -4482,7 +4668,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(to1e18(1), 0, 0, false, 0, alice.wallet, alice.wallet),
+            .adjustTrove(0, 0, false, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: There must be either a collateral change or a debt change",
         )
@@ -4494,11 +4680,9 @@ describe("BorrowerOperations in Normal Mode", () => {
           contracts.borrowerOperations
             .connect(alice.wallet)
             .adjustTrove(
-              to1e18(1),
               0,
               alice.trove.debt.before,
               false,
-              0,
               alice.wallet,
               alice.wallet,
             ),
@@ -4507,15 +4691,424 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
   })
 
+  describe("adjustTroveWithSignature()", () => {
+    const collWithdrawal = 0
+    const debtChange = to1e18("50")
+    const isDebtIncrease = true
+    const assetAmount = 0
+    const upperHint = ZERO_ADDRESS
+    const lowerHint = ZERO_ADDRESS
+
+    const types = {
+      AdjustTrove: [
+        { name: "collWithdrawal", type: "uint256" },
+        { name: "debtChange", type: "uint256" },
+        { name: "isDebtIncrease", type: "bool" },
+        { name: "assetAmount", type: "uint256" },
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
+
+    beforeEach(async () => {
+      // Open an additional trove to keep us from going into recovery mode
+      await setupCarolsTrove()
+    })
+
+    it("adjusts the Trove's debt by the correct amount with a valid signature", async () => {
+      await updateTroveSnapshot(contracts, bob, "before")
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const value = {
+        collWithdrawal,
+        debtChange,
+        isDebtIncrease,
+        assetAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          collWithdrawal,
+          debtChange,
+          isDebtIncrease,
+          upperHint,
+          lowerHint,
+          borrower,
+          borrower,
+          signature,
+          deadline,
+        )
+
+      // Note this test only covers a debt increase, but the trove adjustment logic is shared with `adjustTrove`
+      await updateTroveSnapshot(contracts, bob, "after")
+      const borrowingRate = await contracts.troveManager.BORROWING_FEE_FLOOR()
+      expect(bob.trove.debt.after).to.equal(
+        bob.trove.debt.before +
+          (debtChange * (to1e18(1) + borrowingRate)) / to1e18(1),
+      )
+    })
+
+    it("the caller pays the mUSD", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const value = {
+        collWithdrawal,
+        debtChange,
+        isDebtIncrease: false,
+        assetAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, alice, "before")
+      await updateWalletSnapshot(contracts, bob, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          collWithdrawal,
+          debtChange,
+          value.isDebtIncrease,
+          upperHint,
+          lowerHint,
+          borrower,
+          borrower,
+          signature,
+          deadline,
+        )
+
+      await updateWalletSnapshot(contracts, alice, "after")
+      await updateWalletSnapshot(contracts, bob, "after")
+
+      expect(alice.musd.after).to.equal(alice.musd.before - debtChange)
+      expect(bob.musd.after).to.equal(bob.musd.before)
+    })
+
+    it("sends collateral to the recipient", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const recipient = dennis.wallet.address
+
+      const withdrawnCollateral = 6090000000000000n
+
+      const value = {
+        collWithdrawal: withdrawnCollateral,
+        debtChange,
+        isDebtIncrease,
+        assetAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, dennis, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          withdrawnCollateral,
+          debtChange,
+          isDebtIncrease,
+          upperHint,
+          lowerHint,
+          borrower,
+          recipient,
+          signature,
+          deadline,
+        )
+
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.btc.after).to.equal(dennis.btc.before + withdrawnCollateral)
+    })
+
+    it("allows the caller to pay for collateral increases", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const recipient = dennis.wallet.address
+
+      const addedCollateral = to1e18(1)
+
+      const value = {
+        collWithdrawal: 0n,
+        debtChange: 0n,
+        isDebtIncrease: false,
+        assetAmount: addedCollateral,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await updateTroveSnapshot(contracts, bob, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          value.collWithdrawal,
+          value.debtChange,
+          value.isDebtIncrease,
+          upperHint,
+          lowerHint,
+          value.borrower,
+          value.recipient,
+          signature,
+          value.deadline,
+          { value: value.assetAmount },
+        )
+
+      await updateTroveSnapshot(contracts, bob, "after")
+
+      expect(bob.trove.collateral.after).to.equal(
+        bob.trove.collateral.before + addedCollateral,
+      )
+    })
+
+    it("sends musd to the recipient", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const recipient = dennis.wallet.address
+
+      const value = {
+        collWithdrawal,
+        debtChange,
+        isDebtIncrease,
+        assetAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, dennis, "before")
+
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          collWithdrawal,
+          debtChange,
+          isDebtIncrease,
+          upperHint,
+          lowerHint,
+          borrower,
+          recipient,
+          signature,
+          deadline,
+        )
+
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.musd.after).to.equal(dennis.musd.before + debtChange)
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      const value = {
+        collWithdrawal,
+        debtChange,
+        isDebtIncrease,
+        assetAmount,
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .adjustTroveWithSignature(
+          collWithdrawal,
+          debtChange,
+          isDebtIncrease,
+          upperHint,
+          lowerHint,
+          borrower,
+          borrower,
+          signature,
+          deadline,
+        )
+
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
+    })
+
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests(bob)
+
+        const data = {
+          collWithdrawal,
+          debtChange,
+          isDebtIncrease,
+          assetAmount,
+          upperHint,
+          lowerHint,
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: carol.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const overriddenData = { ...data, ...overrides }
+
+        const value = {
+          collWithdrawal: data.collWithdrawal,
+          debtChange: data.debtChange,
+          isDebtIncrease: data.isDebtIncrease,
+          assetAmount: data.assetAmount,
+          borrower: data.borrower,
+          recipient: data.recipient,
+          nonce: overriddenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const domain = {
+          name: overriddenData.domainName,
+          version: overriddenData.domainVersion,
+          chainId: overriddenData.chainId,
+          verifyingContract: overriddenData.verifyingContract,
+        }
+
+        const signature = await overriddenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overriddenData.caller)
+            .adjustTroveWithSignature(
+              overriddenData.collWithdrawal,
+              overriddenData.debtChange,
+              overriddenData.isDebtIncrease,
+              overriddenData.upperHint,
+              overriddenData.lowerHint,
+              overriddenData.borrower,
+              overriddenData.recipient,
+              signature,
+              overriddenData.deadline,
+              { value: overriddenData.assetAmount },
+            ),
+        ).to.be.revertedWith(message)
+      }
+
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the signed recipient does not match the call", async () => {
+        await testRevert({ recipient: dennis.address })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 999 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+
+      it("reverts when the collateral withdrawn does not match the signature", async () => {
+        await testRevert({ collWithdrawal: to1e18(123) })
+      })
+
+      it("reverts when the debt change does not match the signature", async () => {
+        await testRevert({ debtChange: to1e18(7) })
+      })
+
+      it("reverts when the debt increase flag does not match the signature", async () => {
+        await testRevert({ isDebtIncrease: false })
+      })
+
+      it("reverts when the asset amount does not match the signature", async () => {
+        await testRevert({ assetAmount: to1e18(888) })
+      })
+
+      it("reverts when the implementation is called from a non-BorrowerOperationsSignatures address", async () => {
+        await expect(
+          contracts.borrowerOperations
+            .connect(bob.wallet)
+            .restrictedAdjustTrove(
+              bob.address,
+              bob.address,
+              alice.address,
+              0,
+              to1e18(100),
+              false,
+              bob.address,
+              bob.address,
+            ),
+        ).to.be.revertedWith(
+          "BorrowerOps: Caller is not BorrowerOperationsSignatures",
+        )
+      })
+    })
+  })
+
   describe("refinance()", () => {
     it("changes the trove's interest rate to the current interest rate", async () => {
       await setupCarolsTrove()
       await setInterestRate(contracts, council, 1000)
       await updateTroveSnapshot(contracts, carol, "before")
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
       expect(carol.trove.interestRate.before).to.be.equal(0)
@@ -4529,9 +5122,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       const now = await getLatestBlockTimestamp()
       await updateTroveSnapshot(contracts, carol, "after")
@@ -4547,7 +5138,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       expect(carol.trove.interestOwed.after).to.equal(expectedInterest)
     })
 
-    it("updates the system principal and interest owed for the new interest rate of the Trove and the previous one", async () => {
+    it("updates the system principal and interest", async () => {
       await setInterestRate(contracts, council, 1000)
       await openTrove(contracts, {
         musdAmount: "10,000",
@@ -4564,38 +5155,92 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       await setInterestRate(contracts, council, 500)
 
-      await updateInterestRateDataSnapshot(contracts, state, 500, "before")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
-      await updateTroveSnapshots(contracts, [carol, dennis], "before")
-
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
-
-      await updateInterestRateDataSnapshot(contracts, state, 500, "after")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
-      await updateTroveSnapshots(contracts, [carol, dennis], "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateTroveSnapshots(contracts, [carol, dennis], "before")
+
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
+
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshots(contracts, [carol, dennis], "after")
+
+      const carolInterest = calculateInterestOwed(
+        carol.trove.debt.before,
+        Number(carol.trove.interestRate.before),
+        carol.trove.lastInterestUpdateTime.before,
+        carol.trove.lastInterestUpdateTime.after,
+      )
+      const carolFee = (carol.trove.debt.before + carolInterest) / 1000n
+
+      const dennisInterest = calculateInterestOwed(
+        dennis.trove.debt.before,
+        Number(dennis.trove.interestRate.before),
+        dennis.trove.lastInterestUpdateTime.before,
+        carol.trove.lastInterestUpdateTime.after,
+      )
+
+      expect(state.activePool.interest.after).to.be.closeTo(
+        carolInterest + dennisInterest,
+        2n,
+      )
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before + carolFee,
+      )
+    })
+
+    it("updates the ActivePool principal", async () => {
+      await setInterestRate(contracts, council, 1000)
+      await setupCarolsTrove()
+      await updateTroveSnapshot(contracts, carol, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+
+      await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
+
+      await setInterestRate(contracts, council, 500)
+      await updateTroveSnapshot(contracts, carol, "before")
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
+
       const after = BigInt(await getLatestBlockTimestamp())
+      await updateTroveSnapshot(contracts, carol, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(
+      const debt =
+        carol.trove.debt.before +
         calculateInterestOwed(
-          dennis.trove.debt.before,
+          carol.trove.debt.before,
           1000,
-          dennis.trove.lastInterestUpdateTime.before,
+          carol.trove.lastInterestUpdateTime.before,
           after,
-        ),
+        )
+
+      const expectedFee = debt / 1000n
+
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before + expectedFee,
       )
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(dennis.trove.debt.before)
-      expect(
-        state.interestRateManager.interestRateData[500].interest.after,
-      ).to.equal(carol.trove.interestOwed.after)
-      expect(
-        state.interestRateManager.interestRateData[500].principal.after,
-      ).to.equal(carol.trove.debt.after)
     })
 
     it("updates the ActivePool interest", async () => {
@@ -4613,9 +5258,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       await fastForwardTime(60 * 60 * 24 * 365) // fast-forward one year
 
       await setInterestRate(contracts, council, 500)
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       const after = BigInt(await getLatestBlockTimestamp())
 
@@ -4645,9 +5288,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       await updateTroveSnapshot(contracts, carol, "before")
       await updatePCVSnapshot(contracts, state, "before")
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
       await updatePCVSnapshot(contracts, state, "after")
@@ -4662,9 +5303,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       await setupCarolsTrove()
       await updateTroveSnapshot(contracts, carol, "before")
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -4694,9 +5333,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         .connect(council.wallet)
         .setRefinancingFeePercentage(1)
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -4719,9 +5356,7 @@ describe("BorrowerOperations in Normal Mode", () => {
         .connect(council.wallet)
         .setRefinancingFeePercentage(50)
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -4741,7 +5376,7 @@ describe("BorrowerOperations in Normal Mode", () => {
 
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .refinance(to1e18(1))
+        .refinance()
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -4766,7 +5401,7 @@ describe("BorrowerOperations in Normal Mode", () => {
       await setInterestRate(contracts, council, 500)
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .refinance(to1e18(1))
+        .refinance()
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -4795,14 +5430,19 @@ describe("BorrowerOperations in Normal Mode", () => {
     })
 
     it("Updates maximum borrowing capacity based on current price and collateral", async () => {
+      // Open a huge trove to prevent recovery mode
+      await openTrove(contracts, {
+        musdAmount: "200,000",
+        ICR: "1000",
+        sender: dennis.wallet,
+      })
+
       await setupCarolsTrove()
       await updateTroveSnapshot(contracts, carol, "before")
 
-      const price = await dropPrice(contracts, deployer, carol, to1e18("110"))
+      const price = await dropPrice(contracts, deployer, carol, to1e18("111"))
 
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateTroveSnapshot(contracts, carol, "after")
 
@@ -4820,23 +5460,376 @@ describe("BorrowerOperations in Normal Mode", () => {
       await updateWalletSnapshot(contracts, carol, "before")
 
       await setInterestRate(contracts, council, 500)
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(carol.wallet).refinance()
 
       await updateWalletSnapshot(contracts, carol, "after")
       expect(carol.musd.after).to.equal(carol.musd.before)
     })
 
     context("Expected Reverts", () => {
-      it("Reverts if fee exceeds max fee percentage", async () => {
+      it("should revert if the fee would put the system into recovery mode", async () => {
+        await setInterestRate(contracts, council, 500)
+        await expect(
+          contracts.borrowerOperations.connect(alice.wallet).refinance(),
+        ).to.be.revertedWith(
+          "BorrowerOps: An operation that would result in TCR < CCR is not permitted",
+        )
+      })
+
+      it("should revert if the operation would put the user below MCR", async () => {
+        // Open a trove for Carol to prevent hitting recovery mode
         await setupCarolsTrove()
-        await setNewRate(to1e18(20) / 100n)
+        await setInterestRate(contracts, council, 500)
+        await dropPrice(contracts, deployer, alice, to1e18("110"))
         await expect(
-          contracts.borrowerOperations
-            .connect(carol.wallet)
-            .refinance(to1e18("0.01")),
-        ).to.be.revertedWith("Fee exceeded provided maximum")
+          contracts.borrowerOperations.connect(alice.wallet).refinance(),
+        ).to.be.revertedWith(
+          "BorrowerOps: An operation that would result in ICR < MCR is not permitted",
+        )
+      })
+    })
+  })
+
+  describe("refinanceWithSignature()", () => {
+    const types = {
+      Refinance: [
+        { name: "borrower", type: "address" },
+        { name: "interestRate", type: "uint16" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
+
+    it("changes the trove's interest rate to the current interest rate with a valid signature", async () => {
+      const newRate = 1000
+      await setInterestRate(contracts, council, newRate)
+      const { borrower, interestRate, domain, nonce } =
+        await setupSignatureTests(bob)
+
+      // Open a trove with high ICR to prevent recovery mode
+      await setupCarolsTrove()
+
+      // account for governance delay in setting interest rate
+      const timeToNewRate = 7 * 24 * 60 * 60 // 7 days in seconds
+      const deadline = Math.floor(Date.now() / 1000) + 3600 + timeToNewRate // 1 hour from interest rate change approval
+
+      const value = {
+        borrower,
+        interestRate,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .refinanceWithSignature(borrower, signature, deadline)
+
+      await updateTroveSnapshot(contracts, bob, "after")
+      expect(bob.trove.interestRate.after).to.equal(newRate)
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, interestRate, domain, deadline, nonce } =
+        await setupSignatureTests(bob)
+
+      // Open a trove with high ICR to prevent recovery mode
+      await setupCarolsTrove()
+
+      const value = {
+        borrower,
+        interestRate,
+        nonce,
+        deadline,
+      }
+
+      const signature = await bob.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(alice.wallet)
+        .refinanceWithSignature(borrower, signature, deadline)
+
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
+    })
+
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        const { borrower, interestRate, nonce, deadline } =
+          await setupSignatureTests(bob)
+
+        const data = {
+          borrower,
+          interestRate,
+          nonce,
+          deadline,
+          signer: bob.wallet,
+          caller: alice.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const overriddenData = { ...data, ...overrides }
+
+        const value = {
+          borrower: data.borrower,
+          interestRate: overriddenData.interestRate,
+          nonce: overriddenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const domain = {
+          name: overriddenData.domainName,
+          version: overriddenData.domainVersion,
+          chainId: overriddenData.chainId,
+          verifyingContract: overriddenData.verifyingContract,
+        }
+
+        const signature = await overriddenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overriddenData.caller)
+            .refinanceWithSignature(
+              overriddenData.borrower,
+              signature,
+              overriddenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
+
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: alice.wallet })
+      })
+
+      it("reverts when the interest rate is different than the signed value", async () => {
+        await testRevert({ interestRate: 200 })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 666 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
+      })
+    })
+  })
+
+  describe("claimCollateralWithSignature()", () => {
+    const types = {
+      ClaimCollateral: [
+        { name: "borrower", type: "address" },
+        { name: "recipient", type: "address" },
+        { name: "nonce", type: "uint256" },
+        { name: "deadline", type: "uint256" },
+      ],
+    }
+
+    beforeEach(async () => {
+      // Redeem against Alice's trove so she has a surplus to claim
+      await updateTroveSnapshot(contracts, alice, "before")
+      await updateWalletSnapshot(contracts, alice, "before")
+      await performRedemption(contracts, bob, alice, alice.trove.debt.before)
+    })
+
+    it("allows the user to claim their collateral surplus with a valid signature", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(alice)
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await alice.wallet.signTypedData(domain, types, value)
+
+      const surplus = await contracts.collSurplusPool.getCollateral(
+        alice.wallet,
+      )
+
+      await contracts.borrowerOperationsSignatures
+        .connect(bob.wallet)
+        .claimCollateralWithSignature(
+          borrower,
+          borrower,
+          signature,
+          deadline,
+          NO_GAS,
+        )
+
+      await updateWalletSnapshot(contracts, alice, "after")
+
+      expect(alice.btc.after).to.equal(alice.btc.before + surplus)
+    })
+
+    it("sends the collateral to the recipient", async () => {
+      const { borrower, domain, deadline, nonce } =
+        await setupSignatureTests(alice)
+
+      const recipient = dennis.address
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await alice.wallet.signTypedData(domain, types, value)
+
+      await updateWalletSnapshot(contracts, dennis, "before")
+      const surplus = await contracts.collSurplusPool.getCollateral(
+        alice.wallet,
+      )
+
+      await contracts.borrowerOperationsSignatures
+        .connect(bob.wallet)
+        .claimCollateralWithSignature(borrower, recipient, signature, deadline)
+
+      await updateWalletSnapshot(contracts, dennis, "after")
+
+      expect(dennis.btc.after).to.equal(dennis.btc.before + surplus)
+    })
+
+    it("correctly increments the nonce after a successful transaction", async () => {
+      const { borrower, recipient, domain, deadline, nonce } =
+        await setupSignatureTests(alice)
+
+      const value = {
+        borrower,
+        recipient,
+        nonce,
+        deadline,
+      }
+
+      const signature = await alice.wallet.signTypedData(domain, types, value)
+      await contracts.borrowerOperationsSignatures
+        .connect(bob.wallet)
+        .claimCollateralWithSignature(borrower, borrower, signature, deadline)
+
+      const newNonce =
+        await contracts.borrowerOperationsSignatures.getNonce(borrower)
+      expect(newNonce - nonce).to.equal(1)
+    })
+
+    context("Expected Reverts", () => {
+      const testRevert = async (
+        overrides: object,
+        message: string = "BorrowerOperationsSignatures: Invalid signature",
+      ) => {
+        await setupCarolsTrove()
+        const { borrower, recipient, nonce, deadline } =
+          await setupSignatureTests(alice)
+
+        const data = {
+          borrower,
+          recipient,
+          nonce,
+          deadline,
+          signer: alice.wallet,
+          caller: carol.wallet,
+          domainName: "BorrowerOperationsSignatures",
+          domainVersion: "1",
+          chainId: (await ethers.provider.getNetwork()).chainId,
+          verifyingContract: addresses.borrowerOperationsSignatures,
+        }
+
+        const overriddenData = { ...data, ...overrides }
+
+        const value = {
+          borrower: data.borrower,
+          recipient: data.recipient,
+          nonce: overriddenData.nonce,
+          deadline: data.deadline,
+        }
+
+        const domain = {
+          name: overriddenData.domainName,
+          version: overriddenData.domainVersion,
+          chainId: overriddenData.chainId,
+          verifyingContract: overriddenData.verifyingContract,
+        }
+
+        const signature = await overriddenData.signer.signTypedData(
+          domain,
+          types,
+          value,
+        )
+
+        await expect(
+          contracts.borrowerOperationsSignatures
+            .connect(overriddenData.caller)
+            .claimCollateralWithSignature(
+              overriddenData.borrower,
+              overriddenData.recipient,
+              signature,
+              overriddenData.deadline,
+            ),
+        ).to.be.revertedWith(message)
+      }
+
+      it("reverts when the recovered address does not match the borrower's address", async () => {
+        await testRevert({ signer: bob.wallet })
+      })
+
+      it("reverts when the signed recipient does not match the call", async () => {
+        await testRevert({ recipient: dennis.address })
+      })
+
+      it("reverts when the deadline has passed", async () => {
+        const deadline = Math.floor(Date.now() / 1000) - 1 // 1 second ago
+        await testRevert({ deadline }, "Signature expired")
+      })
+
+      it("reverts when the nonce is invalid", async () => {
+        await testRevert({ nonce: 66 })
+      })
+
+      it("reverts when the contract address is not correctly specified", async () => {
+        const verifyingContract = addresses.pcv // PCV contract address instead of BorrowerOperations
+        await testRevert({ verifyingContract })
+      })
+
+      it("reverts when the chain id is not correctly specified", async () => {
+        await testRevert({ chainId: 0n })
+      })
+
+      it("reverts when the contract version is not correctly specified", async () => {
+        await testRevert({ domainVersion: "0" })
+      })
+
+      it("reverts when the contract name is not correctly specified", async () => {
+        await testRevert({ domainName: "TroveManager" })
       })
     })
   })
diff --git a/solidity/test/normal/CollSurplusPool.test.ts b/solidity/test/normal/CollSurplusPool.test.ts
index 1092d9c..9305faf 100644
--- a/solidity/test/normal/CollSurplusPool.test.ts
+++ b/solidity/test/normal/CollSurplusPool.test.ts
@@ -80,7 +80,7 @@ describe("CollSurplusPool in Normal Mode", () => {
         await expect(
           contracts.collSurplusPool
             .connect(alice.wallet)
-            .claimColl(alice.wallet),
+            .claimColl(alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "CollSurplusPool: Caller is not Borrower Operations",
         )
diff --git a/solidity/test/normal/HintHelpers_getApproxHint.test.ts b/solidity/test/normal/HintHelpers_getApproxHint.test.ts
index 3deab46..1703236 100644
--- a/solidity/test/normal/HintHelpers_getApproxHint.test.ts
+++ b/solidity/test/normal/HintHelpers_getApproxHint.test.ts
@@ -1,14 +1,25 @@
 import { expect } from "chai"
-import { Contracts, openTrove, setupTests, User } from "../helpers"
+import {
+  Contracts,
+  User,
+  fastForwardTime,
+  openTrove,
+  setInterestRate,
+  setupTests,
+  updateTroveSnapshot,
+} from "../helpers"
 import { to1e18 } from "../utils"
 
 describe("HintHelpers", () => {
   let alice: User
   let bob: User
   let carol: User
+  let council: User
   let dennis: User
+  let deployer: User
   let eric: User
   let frank: User
+  let treasury: User
   let contracts: Contracts
 
   // eslint-disable-next-line prefer-const
@@ -17,8 +28,24 @@ describe("HintHelpers", () => {
   const sqrtLength = Math.ceil(Math.sqrt(6)) // Sqrt of the number of Troves
 
   beforeEach(async () => {
-    ;({ alice, bob, carol, dennis, eric, frank, contracts } =
-      await setupTests())
+    ;({
+      alice,
+      bob,
+      carol,
+      council,
+      dennis,
+      deployer,
+      eric,
+      frank,
+      treasury,
+      contracts,
+    } = await setupTests())
+
+    // Setup PCV governance addresses
+    await contracts.pcv
+      .connect(deployer.wallet)
+      .startChangingRoles(council.address, treasury.address)
+    await contracts.pcv.connect(deployer.wallet).finalizeChangingRoles()
   })
 
   async function setupTroves() {
@@ -35,6 +62,50 @@ describe("HintHelpers", () => {
     )
   }
 
+  describe("getRedemptionHints()", () => {
+    it("ignores interest", async () => {
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "300",
+        sender: alice.wallet,
+      })
+      await setInterestRate(contracts, council, 5000)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "310",
+        sender: bob.wallet,
+      })
+
+      await setInterestRate(contracts, council, 8000)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "320",
+        sender: carol.wallet,
+      })
+
+      await fastForwardTime(365 * 24 * 60 * 60) // one year
+
+      const redeemedAmount = to1e18(1)
+
+      const btcPrice = await contracts.priceFeed.fetchPrice()
+
+      const [firstRedemptionHint, partialRedemptionHintNICR] =
+        await contracts.hintHelpers.getRedemptionHints(to1e18(1), btcPrice, 0)
+
+      const redeemedCollateral = (redeemedAmount * to1e18(1)) / btcPrice
+
+      await updateTroveSnapshot(contracts, alice, "after")
+
+      const nICR = await contracts.hintHelpers.computeNominalCR(
+        alice.trove.collateral.after - redeemedCollateral,
+        alice.trove.debt.after - to1e18(1),
+      )
+
+      expect(firstRedemptionHint).to.equal(alice.address)
+      expect(partialRedemptionHintNICR).to.equal(nICR)
+    })
+  })
+
   describe("getApproxHint()", () => {
     it("returns the address of a Trove within sqrt(length) positions of the correct insert position", async () => {
       await setupTroves()
diff --git a/solidity/test/normal/InterestRateManager.test.ts b/solidity/test/normal/InterestRateManager.test.ts
new file mode 100644
index 0000000..387839a
--- /dev/null
+++ b/solidity/test/normal/InterestRateManager.test.ts
@@ -0,0 +1,105 @@
+import { expect } from "chai"
+import {
+  Contracts,
+  User,
+  fastForwardTime,
+  getLatestBlockTimestamp,
+  setupTests,
+} from "../helpers"
+
+describe("InterestRateManager", () => {
+  let alice: User
+  let council: User
+  let deployer: User
+  let treasury: User
+  let contracts: Contracts
+
+  beforeEach(async () => {
+    ;({ alice, deployer, council, treasury, contracts } = await setupTests())
+
+    // Setup PCV governance addresses
+    await contracts.pcv
+      .connect(deployer.wallet)
+      .startChangingRoles(council.address, treasury.address)
+    await contracts.pcv.connect(deployer.wallet).finalizeChangingRoles()
+  })
+
+  describe("proposeInterestRate()", () => {
+    it("sets the proposed interest rate", async () => {
+      await contracts.interestRateManager
+        .connect(council.wallet)
+        .proposeInterestRate(100)
+
+      const blockTime = BigInt(await getLatestBlockTimestamp())
+
+      expect(
+        await contracts.interestRateManager.proposedInterestRate(),
+      ).to.equal(100)
+      expect(await contracts.interestRateManager.proposalTime()).to.equal(
+        blockTime,
+      )
+    })
+    context("Expected Reverts", () => {
+      it("reverts if the proposed rate exceeds the maximum interest rate", async () => {
+        await expect(
+          contracts.interestRateManager
+            .connect(council.wallet)
+            .proposeInterestRate(10001),
+        ).to.be.revertedWith("Interest rate exceeds the maximum interest rate")
+      })
+    })
+  })
+
+  describe("approveInterestRate()", () => {
+    it("requires two transactions to change the interest rate with a 7 day time delay", async () => {
+      await contracts.interestRateManager
+        .connect(council.wallet)
+        .proposeInterestRate(100)
+
+      // Simulate 7 days passing
+      const timeToIncrease = 7 * 24 * 60 * 60 // 7 days in seconds
+      await fastForwardTime(timeToIncrease)
+
+      await contracts.interestRateManager
+        .connect(council.wallet)
+        .approveInterestRate()
+      expect(await contracts.interestRateManager.interestRate()).to.equal(100)
+    })
+
+    context("Expected Reverts", () => {
+      it("reverts if the time delay has not finished", async () => {
+        await contracts.interestRateManager
+          .connect(council.wallet)
+          .proposeInterestRate(100)
+
+        // Simulate 6 days passing
+        const timeToIncrease = 6 * 24 * 60 * 60 // 6 days in seconds
+        await fastForwardTime(timeToIncrease)
+
+        await expect(
+          contracts.interestRateManager
+            .connect(council.wallet)
+            .approveInterestRate(),
+        ).to.be.revertedWith("Proposal delay not met")
+      })
+
+      it("reverts if called by a non-governance address", async () => {
+        await contracts.interestRateManager
+          .connect(council.wallet)
+          .proposeInterestRate(100)
+
+        // Simulate 6 days passing
+        const timeToIncrease = 6 * 24 * 60 * 60 // 6 days in seconds
+        await fastForwardTime(timeToIncrease)
+
+        await expect(
+          contracts.interestRateManager
+            .connect(alice.wallet)
+            .approveInterestRate(),
+        ).to.be.revertedWith(
+          "InterestRateManager: Only governance can call this function",
+        )
+      })
+    })
+  })
+})
diff --git a/solidity/test/normal/PCV.test.ts b/solidity/test/normal/PCV.test.ts
index 746cbaa..48299b9 100644
--- a/solidity/test/normal/PCV.test.ts
+++ b/solidity/test/normal/PCV.test.ts
@@ -2,10 +2,18 @@ import { expect } from "chai"
 import { ethers } from "hardhat"
 import {
   Contracts,
+  ContractsState,
+  createLiquidationEvent,
   fastForwardTime,
+  getEmittedPCVtoSPDepositValues,
+  getEmittedSPtoPCVWithdrawalValues,
+  getEmittedWithdrawCollateralValues,
   getLatestBlockTimestamp,
+  openTrove,
   setupTests,
   TestingAddresses,
+  updatePCVSnapshot,
+  updateStabilityPoolSnapshot,
   updateWalletSnapshot,
   User,
 } from "../helpers"
@@ -19,8 +27,10 @@ describe("PCV", () => {
   let bob: User
   let council: User
   let deployer: User
+  let whale: User
   let contracts: Contracts
   let treasury: User
+  let state: ContractsState
 
   let bootstrapLoan: bigint
   let delay: bigint
@@ -30,18 +40,27 @@ describe("PCV", () => {
   async function debtPaid() {
     const debtToPay = await contracts.pcv.debtToPay()
     await contracts.musd.unprotectedMint(addresses.pcv, debtToPay)
-    await contracts.pcv.connect(treasury.wallet).payDebt(debtToPay)
+    await contracts.pcv.connect(treasury.wallet).distributeMUSD(debtToPay)
   }
 
   beforeEach(async () => {
-    ;({ alice, bob, council, deployer, treasury, contracts, addresses } =
-      await setupTests())
+    ;({
+      alice,
+      bob,
+      council,
+      deployer,
+      whale,
+      treasury,
+      state,
+      contracts,
+      addresses,
+    } = await setupTests())
 
     // for ease of use when calling onlyOwner* functions
     PCVDeployer = contracts.pcv.connect(deployer.wallet)
 
     bootstrapLoan = await contracts.pcv.BOOTSTRAP_LOAN()
-    await PCVDeployer.initialize()
+    await PCVDeployer.initializeDebt()
     await contracts.pcv
       .connect(deployer.wallet)
       .startChangingRoles(council.address, treasury.address)
@@ -57,7 +76,7 @@ describe("PCV", () => {
     delay = await contracts.pcv.governanceTimeDelay()
   })
 
-  describe("initialize()", () => {
+  describe("initializeDebt()", () => {
     it("bootstrap loan deposited to SP and tracked in PCV", async () => {
       const debtToPay = await contracts.pcv.debtToPay()
       expect(debtToPay).to.equal(bootstrapLoan)
@@ -73,7 +92,7 @@ describe("PCV", () => {
 
     context("Expected Reverts", () => {
       it("reverts when trying to initialize second time", async () => {
-        await expect(PCVDeployer.initialize()).to.be.revertedWith(
+        await expect(PCVDeployer.initializeDebt()).to.be.revertedWith(
           "PCV: already initialized",
         )
       })
@@ -164,17 +183,41 @@ describe("PCV", () => {
   })
 
   describe("depositToStabilityPool()", () => {
-    it("deposits additional mUSD to StabilityPool", async () => {
+    it("deposits additional mUSD to StabilityPool from PCV", async () => {
       const depositAmount = to1e18("20")
       await contracts.musd.unprotectedMint(addresses.pcv, depositAmount)
-      await PCVDeployer.depositToStabilityPool(depositAmount)
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const tx = await PCVDeployer.depositToStabilityPool(depositAmount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.pcv.musd.before).to.equal(depositAmount)
+      expect(state.pcv.musd.after).to.equal(0)
+      expect(state.stabilityPool.musd.before).to.equal(bootstrapLoan)
+      expect(state.stabilityPool.musd.after).to.equal(
+        bootstrapLoan + depositAmount,
+      )
+
       const spBalance = await contracts.stabilityPool.getCompoundedMUSDDeposit(
         addresses.pcv,
       )
-      expect(spBalance).to.equal(bootstrapLoan + depositAmount)
+      expect(state.stabilityPool.musd.after).to.equal(spBalance)
+
+      const { musdAmount } = await getEmittedPCVtoSPDepositValues(tx)
+      expect(depositAmount).to.equal(musdAmount)
     })
 
     context("Expected Reverts", () => {
+      it("reverts when trying to deposit 0 mUSD", async () => {
+        await expect(PCVDeployer.depositToStabilityPool(0n)).to.be.revertedWith(
+          "StabilityPool: Amount must be non-zero",
+        )
+      })
+
       it("reverts when not enough mUSD", async () => {
         await expect(
           PCVDeployer.depositToStabilityPool(bootstrapLoan + 1n),
@@ -183,8 +226,290 @@ describe("PCV", () => {
     })
   })
 
-  describe("withdrawMUSD()", () => {
-    it("withdraws mUSD to recipient", async () => {
+  describe("withdrawFromStabilityPool(),", () => {
+    async function populateStabilityPoolWithBTC() {
+      // setup StabilityPool to have BTC in it via a liquidation
+      const whaleMusd = "300,000"
+      await openTrove(contracts, {
+        musdAmount: whaleMusd,
+        ICR: "200",
+        sender: whale.wallet,
+      })
+      await createLiquidationEvent(contracts, deployer)
+    }
+
+    it("emitts PCVWithdrawSP the correct values", async () => {
+      await populateStabilityPoolWithBTC()
+
+      await updatePCVSnapshot(contracts, state, "before")
+
+      const amount = to1e18("1,000")
+      const tx = await PCVDeployer.withdrawFromStabilityPool(amount)
+      const { musdAmount, collateralAmount } =
+        await getEmittedSPtoPCVWithdrawalValues(tx)
+
+      await updatePCVSnapshot(contracts, state, "after")
+
+      expect(musdAmount).to.equal(amount)
+      expect(collateralAmount).to.equal(
+        state.pcv.collateral.after - state.pcv.collateral.before,
+      )
+    })
+
+    it("has no BTC balance changes when requested amount is greater than 0 and no liquidation has occurred", async () => {
+      // check that StabilityPool BTC stays 0
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      await PCVDeployer.withdrawFromStabilityPool(1n)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.collateral.before).to.equal(0n)
+      expect(state.stabilityPool.collateral.after).to.equal(0n)
+      expect(state.pcv.collateral.before).to.equal(0n)
+      expect(state.pcv.collateral.after).to.equal(0n)
+    })
+
+    it("withdraws mUSD and BTC to PCV when requested amount is greater than 0 and a liquidation has occurred", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // StabilityPool BTC decreases to 0
+      // PCV BTC increases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      await PCVDeployer.withdrawFromStabilityPool(1n)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.collateral.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.collateral.after).to.equal(0n)
+      expect(state.pcv.collateral.before).to.equal(0n)
+      expect(state.pcv.collateral.after).to.equal(
+        state.stabilityPool.collateral.before,
+      )
+    })
+
+    it("withdraws BTC to PCV when requested amount is 0 and a liquidation has occurred", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // StabilityPool BTC decreases to 0
+      // PCV BTC increases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      await PCVDeployer.withdrawFromStabilityPool(0n)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.collateral.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.collateral.after).to.equal(0n)
+      expect(state.pcv.collateral.before).to.equal(0n)
+      expect(state.pcv.collateral.after).to.equal(
+        state.stabilityPool.collateral.before,
+      )
+    })
+
+    it("withdraws requested amount and makes loan repayment, mUSD checks with protocol bootstrap loan restrictions", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // StabilityPool mUSD decreases
+      // PCV balance stays the same
+      // Protocol Loan decreases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const debtToPay = await contracts.pcv.debtToPay()
+      const amount = to1e18("20,000")
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before - amount,
+      )
+      expect(state.pcv.musd.before).to.be.greaterThan(0n) // loan issuance fees
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before)
+
+      const protocolLoanChange = debtToPay - (await contracts.pcv.debtToPay())
+      expect(protocolLoanChange).to.equal(amount)
+    })
+
+    it("withdraws entire balance and makes loan repayment if requested amount is greater than the balance, mUSD checks with protocol bootstrap loan restrictions", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // StabilityPool mUSD is 0
+      // PCV balance stays the same
+      // Protocol Loan decreases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const roundingError = 100000000n // Rounding error that occurs when there is only one depositor into the StabilityPool withdrawing everything after a liquidation has been taken
+      const debtToPay = await contracts.pcv.debtToPay()
+      const amount = bootstrapLoan * 2n
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.musd.after).to.equal(roundingError)
+      expect(state.pcv.musd.before).to.be.greaterThan(0n) // loan issuance fees
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before)
+
+      const protocolLoanChange = debtToPay - (await contracts.pcv.debtToPay())
+      expect(protocolLoanChange).to.equal(
+        state.stabilityPool.musd.before - roundingError,
+      ) // note this will be slightly less than the bootstrap loan as part of the bootstrap is used in taking the liquidation
+    })
+
+    it("has no balance changes if the requested amount is zero, mUSD checks with protocol bootstrap loan restrictions", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // StablityPool mUSD stays the same
+      // PCV balance stays the same
+      // Protocol Loan stays the same
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const debtToPay = await contracts.pcv.debtToPay()
+      const amount = 0n
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before,
+      )
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before)
+
+      const protocolLoanChange = debtToPay - (await contracts.pcv.debtToPay())
+      expect(protocolLoanChange).to.equal(0n)
+    })
+
+    it("withdraws requested amount and makes a loan repayment and keeps the surplus, mUSD checks with protocol bootstrap loan restrictions", async () => {
+      await populateStabilityPoolWithBTC()
+
+      // simulate the accrual of mUSD StabilityPool deposits from fees
+      const accruedFees = to1e18("10,000,000")
+      await contracts.musd.unprotectedMint(addresses.pcv, accruedFees)
+      await PCVDeployer.depositToStabilityPool(accruedFees)
+
+      // StablityPool mUSD decreases
+      // PCV balance increases
+      // Protocol Loan is zero
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const debtToPay = await contracts.pcv.debtToPay()
+      const surplus = to1e18("1,000,000")
+      const amount = debtToPay + surplus
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.before).to.be.lessThan(
+        bootstrapLoan + accruedFees,
+      ) // it's less than because some is used for the liquidation
+      expect(state.stabilityPool.musd.before).to.be.greaterThan(bootstrapLoan) // greater than because of the fees that were deposited
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before - amount,
+      )
+      expect(state.pcv.musd.before).to.be.greaterThan(0n) // loan issuance fees
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before + surplus)
+
+      expect(await contracts.pcv.debtToPay()).to.equal(0n)
+    })
+
+    it("withdraws requested amount, mUSD checks with repaid protocol bootstrap loan", async () => {
+      await populateStabilityPoolWithBTC()
+      await debtPaid()
+
+      // StabilityPool mUSD decreases
+      // PCV balance increases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const amount = to1e18("20,000")
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before - amount,
+      )
+      expect(state.pcv.musd.before).to.be.greaterThan(0n) // loan issuance fees
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before + amount)
+    })
+
+    it("withdraws entire balance if requested amount is greater than the balance, mUSD checks with repaid protocol bootstrap loan", async () => {
+      await populateStabilityPoolWithBTC()
+      await debtPaid()
+
+      // StabilityPool mUSD is 0
+      // PCV balance increases
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const roundingError = 100000000n // Rounding error that occurs when there is only one depositor into the StabilityPool withdrawing everything after a liquidation has been taken
+      const amount = bootstrapLoan * 2n
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.before).to.be.greaterThan(0n)
+      expect(state.stabilityPool.musd.after).to.equal(roundingError)
+      expect(state.pcv.musd.before).to.be.greaterThan(0n) // loan issuance fees
+      expect(state.pcv.musd.after).to.equal(
+        state.pcv.musd.before + state.stabilityPool.musd.before - roundingError,
+      )
+    })
+
+    it("has no balance changes if the requested amount is zero, mUSD checks with repaid protocol bootstrap loan", async () => {
+      await populateStabilityPoolWithBTC()
+      await debtPaid()
+
+      // StablityPool mUSD stays the same
+      // PCV balance stays the same
+
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      const amount = 0n
+      await PCVDeployer.withdrawFromStabilityPool(amount)
+
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before,
+      )
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before)
+    })
+  })
+
+  describe("withdrawMUSD() from PCV", () => {
+    it("withdraws mUSD to recipient when the loan is paid", async () => {
       await debtPaid()
       const value = to1e18("20")
       await contracts.musd.unprotectedMint(addresses.pcv, value)
@@ -195,6 +520,23 @@ describe("PCV", () => {
       expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
     })
 
+    it("withdraws mUSD to recipient after recipient is added to the whitelist when the loan is paid", async () => {
+      await debtPaid()
+      const value = to1e18("20")
+      await contracts.musd.unprotectedMint(addresses.pcv, value)
+
+      await expect(
+        PCVDeployer.withdrawMUSD(bob.address, value),
+      ).to.be.revertedWith("PCV: recipient must be in whitelist")
+
+      // add bob as the recipient
+      await PCVDeployer.addRecipientToWhitelist(addresses.bob)
+
+      await PCVDeployer.withdrawMUSD(alice.address, value)
+      expect(await contracts.musd.balanceOf(alice.address)).to.equal(value)
+      expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
+    })
+
     context("Expected Reverts", () => {
       it("reverts when debt is not paid", async () => {
         await expect(
@@ -226,17 +568,17 @@ describe("PCV", () => {
     })
   })
 
-  describe("payDebt()", () => {
-    it("uses all fees to pay down the debt if feeRecipient is not set", async () => {
+  describe("distributeMUSD()", () => {
+    it("uses all fees to pay down the debt if feeRecipient is not set and there is an active protocol bootstrap loan", async () => {
       const value = bootstrapLoan / 3n
       await contracts.musd.unprotectedMint(addresses.pcv, value)
-      await contracts.pcv.connect(treasury.wallet).payDebt(value)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(value)
       const debtToPay = await contracts.pcv.debtToPay()
       expect(debtToPay).to.equal(bootstrapLoan - value)
       expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
     })
 
-    it("uses all fees to pay down the debt if feeSplitPercentage is 0, even if the feeRecipient is set", async () => {
+    it("uses all fees to pay down the debt if feeSplitPercentage is 0, even if the feeRecipient is set and there is an active protocol bootstrap loan", async () => {
       await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
       await contracts.pcv.connect(council.wallet).setFeeSplit(0n)
 
@@ -244,7 +586,7 @@ describe("PCV", () => {
 
       const value = to1e18("1000")
       await contracts.musd.unprotectedMint(addresses.pcv, value)
-      await contracts.pcv.connect(treasury.wallet).payDebt(value)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(value)
 
       await updateWalletSnapshot(contracts, bob, "after")
 
@@ -254,7 +596,7 @@ describe("PCV", () => {
       expect(bob.musd.after).to.equal(bob.musd.before)
     })
 
-    it("sends the specified percentage to another recipient and uses the rest to pay the debt", async () => {
+    it("sends the specified percentage to another recipient and uses the rest to pay the active protocol bootstrap loan", async () => {
       const split = 50n
       await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
       await contracts.pcv.connect(council.wallet).setFeeSplit(split)
@@ -263,7 +605,7 @@ describe("PCV", () => {
 
       const value = to1e18("1000")
       await contracts.musd.unprotectedMint(addresses.pcv, value)
-      await contracts.pcv.connect(treasury.wallet).payDebt(value)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(value)
 
       await updateWalletSnapshot(contracts, bob, "after")
 
@@ -274,42 +616,28 @@ describe("PCV", () => {
       expect(bob.musd.after - bob.musd.before).to.equal(value - pcvSplit)
     })
 
-    it("sends all fees to the feeRecipient if the debt is completely paid", async () => {
-      await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
-      await contracts.pcv.connect(council.wallet).setFeeSplit(20n)
-
-      const debtToPay = await contracts.pcv.debtToPay()
-      const amountToPay = (debtToPay * 10n) / 8n
-      await contracts.musd.unprotectedMint(addresses.pcv, amountToPay)
-      await contracts.pcv.connect(treasury.wallet).payDebt(amountToPay)
-
-      await updateWalletSnapshot(contracts, bob, "before")
-
-      await contracts.musd.unprotectedMint(addresses.pcv, bootstrapLoan)
-      await contracts.pcv.connect(treasury.wallet).payDebt(bootstrapLoan)
-      await updateWalletSnapshot(contracts, bob, "after")
-
-      expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
-      expect(bob.musd.after - bob.musd.before).to.equal(bootstrapLoan)
-    })
-
-    it("sends remaining fees to the feeRecipient if called with a value greater than the debt", async () => {
+    it("sends remaining fees to the StabilityPool if called with a value greater than the remaining protocol bootstrap loan", async () => {
       // pay down all but 5 musd of the debt
       const debtToPay = await contracts.pcv.debtToPay()
       const debtToLeaveRemaining = to1e18("5")
       const value = debtToPay - debtToLeaveRemaining
       await contracts.musd.unprotectedMint(addresses.pcv, value)
-      await contracts.pcv.connect(treasury.wallet).payDebt(value)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(value)
 
       await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
       await contracts.pcv.connect(council.wallet).setFeeSplit(50n)
       await updateWalletSnapshot(contracts, bob, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
 
       await contracts.musd.unprotectedMint(addresses.pcv, to1e18("20"))
-      await contracts.pcv.connect(treasury.wallet).payDebt(to1e18("20"))
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(to1e18("20"))
       await updateWalletSnapshot(contracts, bob, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
 
-      expect(bob.musd.after - bob.musd.before).to.equal(to1e18("15"))
+      expect(bob.musd.after - bob.musd.before).to.equal(to1e18("10"))
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before + to1e18("5"),
+      )
     })
 
     it("rounding errors in fee splitting favor the debt", async () => {
@@ -320,7 +648,7 @@ describe("PCV", () => {
 
       const value = 1n
       await contracts.musd.unprotectedMint(addresses.pcv, value)
-      await contracts.pcv.connect(treasury.wallet).payDebt(value)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(value)
 
       await updateWalletSnapshot(contracts, bob, "after")
 
@@ -332,20 +660,86 @@ describe("PCV", () => {
       expect(bob.musd.after).to.equal(bob.musd.before)
     })
 
+    it("sends all fees to the StabilityPool if the protocol bootstrap loan is repaid and no recipient is set", async () => {
+      // pay down the bootstrap loan
+      await contracts.musd.unprotectedMint(addresses.pcv, bootstrapLoan)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(bootstrapLoan)
+
+      // simulate fees
+      const protocolFees = to1e18("10")
+      await contracts.musd.unprotectedMint(addresses.pcv, protocolFees)
+
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+      // trigger fee distribution
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(protocolFees)
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before + protocolFees,
+      )
+    })
+
+    it("sends all fees to the StabilityPool if feeSplitPercentage is 0, even if the feeRecipient is set when the protocol bootstrap loan is repaid", async () => {
+      await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
+      await contracts.pcv.connect(council.wallet).setFeeSplit(0n)
+
+      // paydown the bootstrap loan
+      await contracts.musd.unprotectedMint(addresses.pcv, bootstrapLoan)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(bootstrapLoan)
+
+      // simulate fees
+      const protocolFees = to1e18("10")
+      await contracts.musd.unprotectedMint(addresses.pcv, protocolFees)
+
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+      // trigger fee distribution
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(protocolFees)
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before + protocolFees,
+      )
+    })
+
+    it("sends the specified percentage to another recipient and deposits the rest in the StabilityPool when the protocol bootstrap loan is repaid", async () => {
+      // paydown the bootstrap loan
+      await contracts.musd.unprotectedMint(addresses.pcv, bootstrapLoan)
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(bootstrapLoan)
+
+      // set recipient and split
+      const feeSplit = 20n
+      await contracts.pcv.connect(council.wallet).setFeeRecipient(bob.address)
+      await contracts.pcv.connect(council.wallet).setFeeSplit(feeSplit)
+      await updateWalletSnapshot(contracts, bob, "before")
+
+      // simulate fees
+      const protocolFees = to1e18("10")
+      await contracts.musd.unprotectedMint(addresses.pcv, protocolFees)
+
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+      // trigger fee distribution
+      await contracts.pcv.connect(treasury.wallet).distributeMUSD(protocolFees)
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+      await updateWalletSnapshot(contracts, bob, "after")
+
+      expect(await contracts.musd.balanceOf(addresses.pcv)).to.equal(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before +
+          (protocolFees * (100n - feeSplit)) / 100n,
+      )
+      expect(bob.musd.after).to.equal(
+        bob.musd.before + (protocolFees * feeSplit) / 100n,
+      )
+    })
+
     context("Expected Reverts", () => {
       it("reverts when not enough tokens to burn", async () => {
         await expect(
-          contracts.pcv.connect(council.wallet).payDebt(1n),
+          contracts.pcv.connect(council.wallet).distributeMUSD(1n),
         ).to.be.revertedWith("PCV: not enough tokens")
       })
-
-      it("reverts when trying to pay again if no fee recipient is set", async () => {
-        await debtPaid()
-        await contracts.musd.unprotectedMint(addresses.pcv, bootstrapLoan)
-        await expect(
-          contracts.pcv.connect(council.wallet).payDebt(bootstrapLoan),
-        ).to.be.revertedWith("PCV: debt has already paid")
-      })
     })
   })
 
@@ -429,7 +823,23 @@ describe("PCV", () => {
   })
 
   describe("withdrawCollateral()", () => {
-    it("withdraws BTC to recipient", async () => {
+    it("withdraws BTC to recipient when there is a protocol loan", async () => {
+      const value = to1e18("20")
+      await updateWalletSnapshot(contracts, alice, "before")
+      // Send BTC to PCV
+      await deployer.wallet.sendTransaction({
+        to: addresses.pcv,
+        value,
+      })
+      await contracts.pcv
+        .connect(council.wallet)
+        .withdrawCollateral(alice.address, value)
+      await updateWalletSnapshot(contracts, alice, "after")
+      expect(await ethers.provider.getBalance(addresses.pcv)).to.equal(0n)
+      expect(alice.btc.after - alice.btc.before).to.equal(value)
+    })
+
+    it("withdraws BTC to recipient when the protocol loan is repaid", async () => {
       await debtPaid()
       const value = to1e18("20")
       await updateWalletSnapshot(contracts, alice, "before")
@@ -446,6 +856,50 @@ describe("PCV", () => {
       expect(alice.btc.after - alice.btc.before).to.equal(value)
     })
 
+    it("withdraws BTC to recipient after recipient is added to the whitelist", async () => {
+      const value = to1e18("20")
+      // Send BTC to PCV
+      await deployer.wallet.sendTransaction({
+        to: addresses.pcv,
+        value,
+      })
+      const withdrawAmount = to1e18("1")
+      // make sure funds cant be withdrawn to bob
+      await expect(
+        PCVDeployer.withdrawCollateral(bob.address, withdrawAmount),
+      ).to.be.revertedWith("PCV: recipient must be in whitelist")
+
+      // add bob as the recipient
+      await PCVDeployer.addRecipientToWhitelist(addresses.bob)
+      await updateWalletSnapshot(contracts, bob, "before")
+
+      // withdraw collatearl
+      await PCVDeployer.withdrawCollateral(bob.address, withdrawAmount)
+
+      await updateWalletSnapshot(contracts, bob, "after")
+
+      // check he got them
+      expect(bob.btc.after).to.equal(bob.btc.before + withdrawAmount)
+    })
+
+    it("emits correct values on withdrawing collateral from PCV", async () => {
+      const value = to1e18("20")
+      await updateWalletSnapshot(contracts, alice, "before")
+      // Send BTC to PCV
+      await deployer.wallet.sendTransaction({
+        to: addresses.pcv,
+        value,
+      })
+      const tx = await contracts.pcv
+        .connect(council.wallet)
+        .withdrawCollateral(alice.address, value)
+
+      const { recipient, collateralAmount } =
+        await getEmittedWithdrawCollateralValues(tx)
+      expect(recipient).to.equal(alice.address)
+      expect(collateralAmount).to.equal(value)
+    })
+
     context("Expected Reverts", () => {
       it("reverts if recipient is not in whitelist", async () => {
         await debtPaid()
@@ -464,30 +918,30 @@ describe("PCV", () => {
             .withdrawCollateral(alice.address, 1n),
         ).to.be.revertedWith("Sending BTC failed")
       })
-
-      it("reverts when debt is not paid", async () => {
-        await expect(
-          contracts.pcv
-            .connect(treasury.wallet)
-            .withdrawCollateral(alice.address, 1n),
-        ).to.be.revertedWith("PCV: debt must be paid")
-      })
     })
   })
 
   describe("setFeeSplit()", () => {
+    it("sets fee split if percentage is less than max and there is debt", async () => {
+      await PCVDeployer.setFeeRecipient(bob.address)
+      await PCVDeployer.setFeeSplit(2n)
+      expect(await PCVDeployer.feeSplitPercentage()).to.equal(2n)
+    })
+
+    it("sets fee split greater than 50% if the debt is paid", async () => {
+      await debtPaid()
+      await PCVDeployer.setFeeRecipient(bob.address)
+      await PCVDeployer.setFeeSplit(51n)
+      expect(await PCVDeployer.feeSplitPercentage()).to.equal(51n)
+    })
+
     context("Expected Reverts", () => {
       it("reverts if fee split is > 50% before debt is paid", async () => {
+        await PCVDeployer.setFeeRecipient(bob.address)
         await expect(PCVDeployer.setFeeSplit(51n)).to.be.revertedWith(
           "PCV: Fee split must be at most 50 while debt remains.",
         )
       })
-      it("reverts if the debt is paid", async () => {
-        await debtPaid()
-        await expect(PCVDeployer.setFeeSplit(1n)).to.be.revertedWith(
-          "PCV: Must have debt in order to set a fee split.",
-        )
-      })
     })
   })
 
@@ -500,4 +954,66 @@ describe("PCV", () => {
       })
     })
   })
+
+  describe("Rebalancing", () => {
+    it("treasury can withdraw BTC to swap and redeposit mUSD into StabilityPool", async () => {
+      // setup StabilityPool to have BTC in it via a liquidation
+      const whaleMusd = "300,000"
+      await openTrove(contracts, {
+        musdAmount: whaleMusd,
+        ICR: "200",
+        sender: whale.wallet,
+      })
+      await createLiquidationEvent(contracts, deployer)
+
+      let pcvBalance = await ethers.provider.getBalance(addresses.pcv)
+      expect(pcvBalance).to.equal(0n)
+
+      // check state assumptions before
+      await updateWalletSnapshot(contracts, treasury, "before")
+      await updatePCVSnapshot(contracts, state, "before")
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+      const liquidatedBTC = state.stabilityPool.collateral.before
+
+      // call to withdraw BTC from StabilityPool to PCV
+      await contracts.pcv.connect(treasury.wallet).withdrawFromStabilityPool(0n)
+      pcvBalance = await ethers.provider.getBalance(addresses.pcv)
+      expect(pcvBalance).to.be.equal(liquidatedBTC)
+
+      // call to withdraw BTC from PCV to treasury
+      await contracts.pcv
+        .connect(treasury.wallet)
+        .withdrawCollateral(treasury.address, pcvBalance)
+      pcvBalance = await ethers.provider.getBalance(addresses.pcv)
+      expect(pcvBalance).to.equal(0n)
+
+      const treasuryBalance = await ethers.provider.getBalance(treasury.address)
+      expect(treasuryBalance).to.be.greaterThan(treasury.btc.before) // got to account for gas
+      expect(treasuryBalance - liquidatedBTC).to.be.lessThan(
+        treasury.btc.before,
+      ) // got to account for gas
+
+      // simulate acquiring mUSD and sending it back to PCV
+      const value = to1e18("20,000")
+      await contracts.musd.unprotectedMint(treasury.address, value)
+
+      await contracts.musd
+        .connect(treasury.wallet)
+        .transfer(await contracts.pcv.getAddress(), value)
+
+      // redeposit mUSD to PCV
+      await contracts.pcv.connect(treasury.wallet).depositToStabilityPool(value)
+
+      // check state assumptions after
+      await updatePCVSnapshot(contracts, state, "after")
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+
+      expect(state.stabilityPool.collateral.after).to.equal(0n)
+      expect(state.stabilityPool.musd.after).to.equal(
+        state.stabilityPool.musd.before + value,
+      )
+      expect(state.pcv.collateral.after).to.equal(0n)
+      expect(state.pcv.musd.after).to.equal(state.pcv.musd.before) // note there are mint fees in here
+    })
+  })
 })
diff --git a/solidity/test/normal/PriceFeed.test.ts b/solidity/test/normal/PriceFeed.test.ts
index 7247d3e..7386da4 100644
--- a/solidity/test/normal/PriceFeed.test.ts
+++ b/solidity/test/normal/PriceFeed.test.ts
@@ -1,7 +1,13 @@
 import { expect } from "chai"
 import { to1e18 } from "../utils"
 
-import { Contracts, User, getDeployedContract, setupTests } from "../helpers"
+import {
+  Contracts,
+  User,
+  getLatestBlockTimestamp,
+  getDeployedContract,
+  setupTests,
+} from "../helpers"
 import type { PriceFeed } from "../../typechain"
 
 describe("PriceFeed in Normal Mode", () => {
@@ -79,5 +85,19 @@ describe("PriceFeed in Normal Mode", () => {
         to1e18("50,000"),
       )
     })
+
+    context("Expected Reverts", () => {
+      it("reverts when the price feed data is old", async () => {
+        const now = BigInt(await getLatestBlockTimestamp())
+        const fifteenMinutesAgo = now - 15n * 60n
+        await contracts.mockAggregator
+          .connect(deployer.wallet)
+          .setBlockTime(fifteenMinutesAgo)
+
+        await expect(contracts.priceFeed.fetchPrice()).to.be.revertedWith(
+          "PriceFeed: Oracle is stale.",
+        )
+      })
+    })
   })
 })
diff --git a/solidity/test/normal/SortedTroves.test.ts b/solidity/test/normal/SortedTroves.test.ts
index d977890..19a0ab1 100644
--- a/solidity/test/normal/SortedTroves.test.ts
+++ b/solidity/test/normal/SortedTroves.test.ts
@@ -1,7 +1,15 @@
 import { expect } from "chai"
-import { Contracts, User, openTrove, openTroves, setupTests } from "../helpers"
+import {
+  Contracts,
+  User,
+  fastForwardTime,
+  openTrove,
+  openTroves,
+  setInterestRate,
+  setupTests,
+} from "../helpers"
 import { to1e18 } from "../utils"
-import { MAX_BYTES_32 } from "../../helpers/constants"
+import { MAX_BYTES_32, ZERO_ADDRESS } from "../../helpers/constants"
 
 describe("SortedTroves", () => {
   let alice: User
@@ -10,12 +18,30 @@ describe("SortedTroves", () => {
   let dennis: User
   let deployer: User
   let eric: User
+  let treasury: User
   let whale: User
+  let council: User
   let contracts: Contracts
 
   beforeEach(async () => {
-    ;({ alice, bob, carol, dennis, deployer, eric, whale, contracts } =
-      await setupTests())
+    ;({
+      alice,
+      bob,
+      carol,
+      council,
+      dennis,
+      deployer,
+      eric,
+      treasury,
+      whale,
+      contracts,
+    } = await setupTests())
+
+    // Setup PCV governance addresses
+    await contracts.pcv
+      .connect(deployer.wallet)
+      .startChangingRoles(council.address, treasury.address)
+    await contracts.pcv.connect(deployer.wallet).finalizeChangingRoles()
   })
 
   describe("contains()", () => {
@@ -154,4 +180,49 @@ describe("SortedTroves", () => {
       expect(high).to.equal(carol.wallet)
     })
   })
+
+  describe("reInsert()", () => {
+    it("reinserts troves based only on collateral and principal", async () => {
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "300",
+        sender: alice.wallet,
+      })
+      await setInterestRate(contracts, council, 5000)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "310",
+        sender: bob.wallet,
+      })
+
+      await setInterestRate(contracts, council, 8000)
+      await openTrove(contracts, {
+        musdAmount: "50,000",
+        ICR: "320",
+        sender: carol.wallet,
+      })
+
+      await fastForwardTime(365 * 24 * 60 * 60) // one year
+
+      await contracts.borrowerOperations
+        .connect(alice.wallet)
+        .repayMUSD(1n, ZERO_ADDRESS, ZERO_ADDRESS)
+
+      await contracts.borrowerOperations
+        .connect(bob.wallet)
+        .repayMUSD(1n, ZERO_ADDRESS, ZERO_ADDRESS)
+
+      await contracts.borrowerOperations
+        .connect(carol.wallet)
+        .repayMUSD(1n, ZERO_ADDRESS, ZERO_ADDRESS)
+
+      const lowest = await contracts.sortedTroves.getLast()
+      const middle = await contracts.sortedTroves.getPrev(lowest)
+      const highest = await contracts.sortedTroves.getPrev(middle)
+
+      expect(lowest).to.equal(alice.address)
+      expect(middle).to.equal(bob.address)
+      expect(highest).to.equal(carol.address)
+    })
+  })
 })
diff --git a/solidity/test/normal/StabilityPool.test.ts b/solidity/test/normal/StabilityPool.test.ts
index f2d910c..c813b13 100644
--- a/solidity/test/normal/StabilityPool.test.ts
+++ b/solidity/test/normal/StabilityPool.test.ts
@@ -1325,10 +1325,11 @@ describe("StabilityPool in Normal Mode", () => {
       })
     })
 
-    it("updates the system interest owed for the Trove's interest rate", async () => {
+    it("updates the system interest", async () => {
       await testUpdatesSystemInterestOwed(
         contracts,
         state,
+        addresses,
         carol,
         dennis,
         council,
@@ -2021,5 +2022,40 @@ describe("StabilityPool in Normal Mode", () => {
       expect(state.stabilityPool.P.before).to.not.equal(to1e18(1))
       expect(state.stabilityPool.P.after).to.equal(to1e18(1))
     })
+
+    // https://github.com/liquity/dev/security/advisories/GHSA-m9f3-hrx8-x2g3
+    it("Handles the liquity v1 advisory", async () => {
+      const amount = 9799999999999999980001000n / 1005n
+      const nearlyAllThePool = 9999999999999999980000n
+      await openTrove(contracts, {
+        musdAmount: amount,
+        ICR: "111",
+        sender: bob.wallet,
+      })
+
+      await updateTroveSnapshot(contracts, bob, "before")
+      expect(bob.trove.debt.before).to.equal(nearlyAllThePool)
+
+      await provideToSP(contracts, whale, to1e18("10,000"))
+
+      await dropPriceAndLiquidate(contracts, deployer, bob)
+
+      // put us back at $10k
+      await provideToSP(contracts, whale, nearlyAllThePool)
+
+      await openTrove(contracts, {
+        musdAmount: amount,
+        ICR: "111",
+        sender: carol.wallet,
+      })
+
+      await updateTroveSnapshot(contracts, carol, "before")
+      expect(carol.trove.debt.before).to.equal(nearlyAllThePool)
+
+      await dropPriceAndLiquidate(contracts, deployer, carol)
+
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+      expect(state.stabilityPool.P.after).to.be.greaterThanOrEqual(1000000000n)
+    })
   })
 })
diff --git a/solidity/test/normal/TroveManager.test.ts b/solidity/test/normal/TroveManager.test.ts
index 5b1793e..8ce5301 100644
--- a/solidity/test/normal/TroveManager.test.ts
+++ b/solidity/test/normal/TroveManager.test.ts
@@ -26,19 +26,18 @@ import {
   openTrove,
   performRedemption,
   provideToSP,
-  setBaseRate,
   setupTests,
   transferMUSD,
   updateContractsSnapshot,
   updatePCVSnapshot,
   updatePendingSnapshot,
+  updateStabilityPoolSnapshot,
   updateStabilityPoolUserSnapshot,
   updateStabilityPoolUserSnapshots,
   updateTroveManagerSnapshot,
   updateTroveSnapshot,
   updateTroveSnapshots,
   updateWalletSnapshot,
-  updateInterestRateDataSnapshot,
   setInterestRate,
   getTroveEntireDebt,
   TROVE_UPDATED_ABI,
@@ -245,22 +244,30 @@ describe("TroveManager in Normal Mode", () => {
   })
 
   describe("liquidate()", () => {
-    it("removes liquidated trove's principal and interest from system interest rate data", async () => {
+    it("removes liquidated trove's principal and interest from system interest", async () => {
       await setInterestRate(contracts, council, 1000)
       await setupTroves()
       await fastForwardTime(365 * 24 * 60 * 60)
       await updateTroveSnapshots(contracts, [alice, bob], "before")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await dropPriceAndLiquidate(contracts, deployer, alice)
       const after = BigInt(await getLatestBlockTimestamp())
       await updateTroveSnapshots(contracts, [alice, bob], "after")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(bob.trove.debt.after)
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      expect(state.activePool.principal.after).to.equal(bob.trove.debt.after)
+      expect(state.activePool.interest.after).to.equal(
         calculateInterestOwed(
           bob.trove.debt.before,
           1000,
@@ -282,23 +289,32 @@ describe("TroveManager in Normal Mode", () => {
       // liquidate Carol to create pending rewards for everyone
       await dropPriceAndLiquidate(contracts, deployer, carol)
       await updateTroveSnapshots(contracts, [alice, bob], "before")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await dropPriceAndLiquidate(contracts, deployer, alice)
       const after = BigInt(await getLatestBlockTimestamp())
       await updateTroveSnapshots(contracts, [alice, bob], "after")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(bob.trove.debt.after)
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      expect(state.activePool.principal.after).to.equal(bob.trove.debt.after)
+      expect(state.activePool.interest.after).to.be.closeTo(
         calculateInterestOwed(
           bob.trove.debt.before,
           1000,
           bob.trove.lastInterestUpdateTime.before,
           after,
         ),
+        2n,
       )
     })
 
@@ -526,7 +542,13 @@ describe("TroveManager in Normal Mode", () => {
         sender: carol.wallet,
       })
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await updateTroveSnapshot(contracts, carol, "before")
       await updateTroveManagerSnapshot(contracts, state, "before")
 
@@ -550,18 +572,16 @@ describe("TroveManager in Normal Mode", () => {
       // Calculate interest on total system debt
       const interestOwed =
         calculateInterestOwed(
-          state.interestRateManager.interestRateData[1000].principal.before,
+          state.activePool.principal.before,
           1000,
           carol.trove.lastInterestUpdateTime.before,
           carol.trove.lastInterestUpdateTime.after,
-        ) + state.interestRateManager.interestRateData[1000].interest.before
+        ) + state.activePool.interest.before
 
       // Calculate expected tcr
       const remainingColl =
         (entireSystemCollBefore - collGasCompensation) * newPrice
-      const remainingDebt =
-        state.interestRateManager.interestRateData[1000].principal.before +
-        interestOwed
+      const remainingDebt = state.activePool.principal.before + interestOwed
 
       await updateTroveManagerSnapshot(contracts, state, "after")
 
@@ -992,21 +1012,8 @@ describe("TroveManager in Normal Mode", () => {
 
       const aliceLiquidateTime = BigInt(await getLatestBlockTimestamp())
 
-      const defaultInterestAccruedBetweenCarolAndAlice = to1e18(
-        calculateInterestOwed(
-          carol.trove.debt.before,
-          interestRate,
-          carolLiquidationTime,
-          aliceLiquidateTime,
-        ),
-      )
-
-      const pendingDebtLUpdated =
-        lInterestAfterCarolLiquidated +
-        defaultInterestAccruedBetweenCarolAndAlice / bob.trove.collateral.before
-
       const expectedLInterestAfterAliceLiquidated =
-        pendingDebtLUpdated +
+        lInterestAfterCarolLiquidated +
         to1e18(
           calculateInterestOwed(
             alice.trove.debt.before,
@@ -1320,6 +1327,70 @@ describe("TroveManager in Normal Mode", () => {
       )
     })
 
+    it("decreases ActivePool collateral, principal, and interest owed by correct amounts when offset by the stability pool", async () => {
+      await setInterestRate(contracts, council, 1000)
+      await setupTroves()
+      await provideToSP(contracts, bob, to1e18("20,000"))
+
+      await fastForwardTime(365 * 24 * 60 * 60)
+
+      await updateTroveSnapshots(contracts, [alice, bob], "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateStabilityPoolSnapshot(contracts, state, "before")
+
+      // Close Alice's Trove
+      await dropPriceAndLiquidate(contracts, deployer, alice)
+
+      await updateStabilityPoolSnapshot(contracts, state, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshot(contracts, alice, "after")
+      const after = await getLatestBlockTimestamp()
+
+      const aliceInterest = calculateInterestOwed(
+        alice.trove.debt.before,
+        Number(alice.trove.interestRate.before),
+        alice.trove.lastInterestUpdateTime.before,
+        alice.trove.lastInterestUpdateTime.after,
+      )
+
+      const stabilityPoolLoss =
+        state.stabilityPool.musd.before - state.stabilityPool.musd.after
+
+      expect(state.activePool.collateral.after).to.equal(
+        bob.trove.collateral.before,
+      )
+      expect(state.activePool.principal.after).to.equal(bob.trove.debt.before)
+
+      // ActivePool interest should only include Bob's interest
+      const expectedInterest = calculateInterestOwed(
+        bob.trove.debt.before,
+        1000,
+        bob.trove.lastInterestUpdateTime.before,
+        BigInt(after),
+      )
+
+      expect(state.activePool.interest.after).to.be.closeTo(
+        expectedInterest,
+        2n,
+      )
+      expect(state.activePool.principal.after).to.equal(bob.trove.debt.before)
+      expect(stabilityPoolLoss).to.equal(
+        alice.trove.debt.before + aliceInterest,
+      )
+    })
+
     it("increases DefaultPool collateral and mUSD debt by correct amounts", async () => {
       await setupTroves()
       await updateTroveSnapshot(contracts, alice, "before")
@@ -1640,7 +1711,13 @@ describe("TroveManager in Normal Mode", () => {
         sender: carol.wallet,
       })
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await updateTroveSnapshot(contracts, carol, "before")
       await updateTroveManagerSnapshot(contracts, state, "before")
 
@@ -1663,18 +1740,16 @@ describe("TroveManager in Normal Mode", () => {
       const after = await getLatestBlockTimestamp()
       const interestOwed =
         calculateInterestOwed(
-          state.interestRateManager.interestRateData[1000].principal.before,
+          state.activePool.principal.before,
           1000,
           carol.trove.lastInterestUpdateTime.before,
           BigInt(after),
-        ) + state.interestRateManager.interestRateData[1000].interest.before
+        ) + state.activePool.interest.before
 
       // Calculate expected tcr
       const remainingColl =
         (entireSystemCollBefore - collGasCompensation) * newPrice
-      const remainingDebt =
-        state.interestRateManager.interestRateData[1000].principal.before +
-        interestOwed
+      const remainingDebt = state.activePool.principal.before + interestOwed
 
       await updateTroveManagerSnapshot(contracts, state, "after")
 
@@ -1905,6 +1980,38 @@ describe("TroveManager in Normal Mode", () => {
 
       expect(carol.trove.icr.after).to.equal(expectedICR)
     })
+
+    it("reflects accrued interest", async () => {
+      const interestRate = 100
+      await setInterestRate(contracts, council, interestRate)
+      await openTrove(contracts, {
+        musdAmount: "5000",
+        ICR: "400",
+        sender: alice.wallet,
+      })
+
+      await updateTroveSnapshot(contracts, alice, "before")
+
+      await fastForwardTime(50 * 24 * 60 * 60) // 50 days in seconds
+
+      await updateTroveSnapshot(contracts, alice, "after")
+
+      const endTime = BigInt(await getLatestBlockTimestamp())
+      const price = await contracts.priceFeed.fetchPrice()
+
+      const expectedDebt =
+        alice.trove.debt.before +
+        calculateInterestOwed(
+          alice.trove.debt.before,
+          interestRate,
+          alice.trove.lastInterestUpdateTime.before,
+          endTime,
+        )
+
+      const expectedICR = (alice.trove.collateral.before * price) / expectedDebt
+
+      expect(alice.trove.icr.after).to.equal(expectedICR)
+    })
   })
 
   describe("getRedemptionHints()", () => {
@@ -2009,7 +2116,7 @@ describe("TroveManager in Normal Mode", () => {
         sender: alice.wallet,
       })
       await openTrove(contracts, {
-        musdAmount: "2000",
+        musdAmount: "4000",
         ICR: "300",
         sender: bob.wallet,
       })
@@ -2071,34 +2178,6 @@ describe("TroveManager in Normal Mode", () => {
       ).to.equal(collNeeded)
     }
 
-    async function redeemWithFee(
-      feePercentage: number,
-      redemptionAmount: bigint = to1e18("100"),
-    ) {
-      const price = await contracts.priceFeed.fetchPrice()
-      const fee = to1e18(feePercentage) / 100n
-
-      const {
-        firstRedemptionHint,
-        partialRedemptionHintNICR,
-        upperPartialRedemptionHint,
-        lowerPartialRedemptionHint,
-      } = await getRedemptionHints(contracts, dennis, redemptionAmount, price)
-
-      return contracts.troveManager
-        .connect(dennis.wallet)
-        .redeemCollateral(
-          redemptionAmount,
-          firstRedemptionHint,
-          upperPartialRedemptionHint,
-          lowerPartialRedemptionHint,
-          partialRedemptionHintNICR,
-          0,
-          fee,
-          NO_GAS,
-        )
-    }
-
     it("ends the redemption sequence when the token redemption request has been filled", async () => {
       await setupRedemptionTroves()
 
@@ -2113,7 +2192,6 @@ describe("TroveManager in Normal Mode", () => {
           alice.address,
           0,
           0,
-          to1e18("1"),
           NO_GAS,
         )
 
@@ -2159,7 +2237,6 @@ describe("TroveManager in Normal Mode", () => {
         alice.address,
         0,
         2, // Max redemptions set to 2, so we will stop after Bob's trove
-        to1e18("1"),
         NO_GAS,
       )
 
@@ -2198,7 +2275,7 @@ describe("TroveManager in Normal Mode", () => {
     it("performs partial redemption if resultant debt is > minimum net debt", async () => {
       await setupRedemptionTroves()
 
-      const redemptionAmount = to1e18("4120") // Alice and Bob's net debt + 100 mUSD
+      const redemptionAmount = to1e18("6130") // Alice and Bob's net debt + 100 mUSD
       await performRedemption(contracts, dennis, dennis, redemptionAmount)
 
       // Check that Alice and Bob's troves are closed by redemption
@@ -2221,7 +2298,7 @@ describe("TroveManager in Normal Mode", () => {
       await setupRedemptionTroves()
 
       // Alice and Bob's net debt + 300 mUSD.  A partial redemption of 300 mUSD would put Carol below minimum net debt
-      const redemptionAmount = to1e18("4320")
+      const redemptionAmount = to1e18("6330")
 
       await performRedemption(contracts, dennis, dennis, redemptionAmount)
 
@@ -2267,7 +2344,7 @@ describe("TroveManager in Normal Mode", () => {
       // Carol redeems 10 mUSD from Alice's trove ahead of Dennis's redemption
       await contracts.troveManager
         .connect(carol.wallet)
-        .redeemCollateral(to1e18("10"), f, u, l, p, 0, to1e18("1"), NO_GAS)
+        .redeemCollateral(to1e18("10"), f, u, l, p, 0, NO_GAS)
 
       // Dennis tries to redeem with outdated hint
       await contracts.troveManager
@@ -2279,7 +2356,6 @@ describe("TroveManager in Normal Mode", () => {
           lowerPartialRedemptionHint,
           partialRedemptionHintNICR,
           0,
-          to1e18("1"),
           NO_GAS,
         )
 
@@ -2347,7 +2423,6 @@ describe("TroveManager in Normal Mode", () => {
         "0x0000000000000000000000000000000000000000",
         0,
         0,
-        to1e18("1"),
         NO_GAS,
       )
 
@@ -2413,7 +2488,7 @@ describe("TroveManager in Normal Mode", () => {
       )
     })
 
-    it("correctly updates system interest rate and principal data for a partial redemption", async () => {
+    it("correctly updates system interest and principal for a partial redemption", async () => {
       await setInterestRate(contracts, council, 1000)
       await setupRedemptionTroves()
 
@@ -2421,26 +2496,24 @@ describe("TroveManager in Normal Mode", () => {
 
       await fastForwardTime(365 * 24 * 60 * 60) // 1 year in seconds
 
-      await updateTroveSnapshot(contracts, alice, "before")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
-
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await performRedemption(contracts, dennis, alice, redemptionAmount)
 
-      await updateTroveSnapshot(contracts, alice, "after")
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
-
-      const now = BigInt(await getLatestBlockTimestamp())
-      const beforeRedemptionInterest = [alice, bob, carol, dennis].reduce(
-        (acc, user) =>
-          calculateInterestOwed(
-            user.trove.debt.before,
-            1000,
-            user.trove.lastInterestUpdateTime.before,
-            now,
-          ) + acc,
-        0n,
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
       )
 
+      await updateTroveSnapshot(contracts, alice, "after")
       const interestAccrued = calculateInterestOwed(
         alice.trove.debt.before,
         1000,
@@ -2453,18 +2526,25 @@ describe("TroveManager in Normal Mode", () => {
         interestAccrued < redemptionAmount ? interestAccrued : redemptionAmount
       const principalAdjustment = redemptionAmount - interestAdjustment
 
-      expect(
-        state.interestRateManager.interestRateData[1000].interest.after,
-      ).to.equal(beforeRedemptionInterest - interestAdjustment)
-      expect(
-        state.interestRateManager.interestRateData[1000].principal.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[1000].principal.before -
-          principalAdjustment,
+      expect(state.activePool.principal.after).to.equal(
+        state.activePool.principal.before - principalAdjustment,
+      )
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before +
+          calculateInterestOwed(
+            alice.trove.debt.before +
+              bob.trove.debt.before +
+              carol.trove.debt.before +
+              dennis.trove.debt.before,
+            1000,
+            dennis.trove.lastInterestUpdateTime.before,
+            alice.trove.lastInterestUpdateTime.after,
+          ) -
+          interestAdjustment,
       )
     })
 
-    it("correctly updates system interest rate and principal data for a full redemption", async () => {
+    it("correctly updates system interest and principal for a full redemption", async () => {
       const interestRate = 1000
       await setInterestRate(contracts, council, interestRate)
       await setupRedemptionTroves()
@@ -2473,16 +2553,19 @@ describe("TroveManager in Normal Mode", () => {
 
       // stop interest from accruing to make calculations easier
       await setInterestRate(contracts, council, 0)
-      await contracts.borrowerOperations
-        .connect(alice.wallet)
-        .refinance(to1e18(1))
+      await contracts.borrowerOperations.connect(alice.wallet).refinance()
 
-      await updateTroveSnapshot(contracts, alice, "before")
-      await updateInterestRateDataSnapshot(
+      await updateTroveSnapshots(
+        contracts,
+        [alice, bob, carol, dennis],
+        "before",
+      )
+      await updateContractsSnapshot(
         contracts,
         state,
-        interestRate,
+        "activePool",
         "before",
+        addresses,
       )
 
       // subtract 200 mUSD from Alice's debt for gas compensation
@@ -2491,18 +2574,35 @@ describe("TroveManager in Normal Mode", () => {
         to1e18("200")
       await performRedemption(contracts, dennis, alice, redemptionAmount)
 
-      await updateTroveSnapshot(contracts, alice, "after")
-      await updateInterestRateDataSnapshot(contracts, state, 0, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshots(
+        contracts,
+        [alice, bob, carol, dennis],
+        "after",
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[0].interest.after,
-      ).to.equal(0)
-      expect(
-        state.interestRateManager.interestRateData[0].principal.after,
-      ).to.equal(0)
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before +
+          // carol and dennis still accrue interest
+          calculateInterestOwed(
+            bob.trove.debt.before +
+              carol.trove.debt.before +
+              dennis.trove.debt.before,
+            1000,
+            alice.trove.lastInterestUpdateTime.before,
+            alice.trove.lastInterestUpdateTime.after,
+          ) -
+          alice.trove.interestOwed.before,
+      )
     })
 
-    it("correctly updates system interest rate and principal data for a mix of full and partial redemptions", async () => {
+    it("correctly updates system interest and principal for a mix of full and partial redemptions", async () => {
       const interestRate = 1000
       await setInterestRate(contracts, council, interestRate)
       await setupRedemptionTroves()
@@ -2512,37 +2612,52 @@ describe("TroveManager in Normal Mode", () => {
       // stop interest from accruing to make calculations easier
       await setInterestRate(contracts, council, 0)
 
-      await contracts.borrowerOperations
-        .connect(alice.wallet)
-        .refinance(to1e18(1))
-      await updateTroveSnapshot(contracts, alice, "before")
+      await contracts.borrowerOperations.connect(alice.wallet).refinance()
+      await contracts.borrowerOperations.connect(bob.wallet).refinance()
 
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .refinance(to1e18(1))
-      await updateTroveSnapshot(contracts, bob, "before")
+      const aliceDebt = await contracts.troveManager.getTroveDebt(alice.address)
+      const redemptionAmount = aliceDebt + to1e18("400")
 
-      await updateInterestRateDataSnapshot(
+      await updateContractsSnapshot(
         contracts,
         state,
-        interestRate,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateTroveSnapshots(
+        contracts,
+        [alice, bob, carol, dennis],
         "before",
       )
 
-      const redemptionAmount =
-        (await contracts.troveManager.getTroveDebt(alice.address)) +
-        to1e18("400")
       await performRedemption(contracts, dennis, alice, redemptionAmount)
 
-      await updateTroveSnapshots(contracts, [alice, bob], "after")
-      await updateInterestRateDataSnapshot(contracts, state, 0, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshots(
+        contracts,
+        [alice, bob, carol, dennis],
+        "after",
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[0].interest.after,
-      ).to.equal(bob.trove.interestOwed.after)
-      expect(
-        state.interestRateManager.interestRateData[0].principal.after,
-      ).to.equal(bob.trove.debt.after)
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before +
+          // carol and dennis still accrue interest
+          calculateInterestOwed(
+            carol.trove.debt.before + dennis.trove.debt.before,
+            1000,
+            bob.trove.lastInterestUpdateTime.before,
+            bob.trove.lastInterestUpdateTime.after,
+          ) -
+          alice.trove.interestOwed.before -
+          bob.trove.interestOwed.before,
+      )
     })
 
     it("has the same functionality with invalid first hint, zero address", async () => {
@@ -2582,7 +2697,6 @@ describe("TroveManager in Normal Mode", () => {
           lowerPartialRedemptionHint,
           partialRedemptionHintNICR,
           0,
-          to1e18("1"),
           NO_GAS,
         )
 
@@ -2623,7 +2737,6 @@ describe("TroveManager in Normal Mode", () => {
           lowerPartialRedemptionHint,
           partialRedemptionHintNICR,
           0,
-          to1e18("1"),
           NO_GAS,
         )
 
@@ -2697,90 +2810,8 @@ describe("TroveManager in Normal Mode", () => {
       expect(alice.btc.after).to.equal(alice.btc.before + collateralSurplus)
     })
 
-    it("succeeds if fee is less than max fee percentage", async () => {
-      // Open identical troves for everyone but Dennis
-      const users = [alice, bob, carol, dennis]
-      await Promise.all(
-        users.slice(0, -1).map((user) =>
-          openTrove(contracts, {
-            musdAmount: "20000",
-            ICR: "200",
-            sender: user.wallet,
-          }),
-        ),
-      )
-
-      // Open a trove for Dennis with slightly lower ICR
-      await openTrove(contracts, {
-        musdAmount: "40000",
-        ICR: "195",
-        sender: dennis.wallet,
-      })
-
-      // Calculate the fee for redeeming 1/10 of the total supply
-      const totalSupply = await contracts.musd.totalSupply()
-      const attemptedRedemptionAmount = totalSupply / 10n
-      const price = await contracts.priceFeed.fetchPrice()
-      const collNeeded = to1e18(attemptedRedemptionAmount) / price
-      const fee =
-        await contracts.troveManager.getRedemptionFeeWithDecay(collNeeded)
-      const baseRate = await contracts.troveManager.baseRate()
-      const feePercentage = (to1e18(fee) / collNeeded) * 1000n + baseRate
-      const feePercentageNumber = Number(feePercentage) / Number(1e18)
-
-      // Attempt to redeem with a fee 1% more than the calculated fee
-      const redemptionTx = await redeemWithFee(
-        feePercentageNumber + 1,
-        attemptedRedemptionAmount,
-      )
-      const receipt = await redemptionTx.wait()
-
-      // Check that the redemption succeeded
-      expect(receipt?.status).to.equal(1)
-    })
-
-    it("a redemption made when base rate is zero increases the base rate", async () => {
-      await setupRedemptionTroves()
-
-      await setBaseRate(contracts, to1e18("0"))
-
-      await performRedemption(contracts, dennis, dennis, to1e18("100"))
-
-      expect(await contracts.troveManager.baseRate()).to.be.gt(0)
-    })
-
-    it("a redemption made when base rate is non-zero increases the base rate, for negligible time passed", async () => {
-      await setupRedemptionTroves()
-
-      const initialBaseRate = to1e18("0.1")
-      await setBaseRate(contracts, initialBaseRate)
-
-      await performRedemption(contracts, dennis, dennis, to1e18("100"))
-
-      expect(await contracts.troveManager.baseRate()).to.be.gt(initialBaseRate)
-    })
-
-    it("lastFeeOpTime doesn't update if less time than decay interval has passed since the last fee operation", async () => {
-      await setupRedemptionTroves()
-
-      const initialBaseRate = to1e18("0.1")
-      await setBaseRate(contracts, initialBaseRate)
-
-      await performRedemption(contracts, dennis, dennis, to1e18("100"))
-
-      const lastFeeOpTime = await contracts.troveManager.lastFeeOperationTime()
-      await fastForwardTime(45)
-      await performRedemption(contracts, dennis, dennis, to1e18("100"))
-
-      expect(await contracts.troveManager.lastFeeOperationTime()).to.equal(
-        lastFeeOpTime,
-      )
-    })
-
-    it("a redemption made at zero base rate sends a non-zero CollateralFee to PCV contract", async () => {
-      await setBaseRate(contracts, to1e18("0"))
-
-      await setupRedemptionTroves()
+    it("a redemption made at zero base rate sends a non-zero CollateralFee to PCV contract", async () => {
+      await setupRedemptionTroves()
 
       await performRedemption(contracts, dennis, dennis, to1e18("100"))
       await updatePCVSnapshot(contracts, state, "after")
@@ -2789,8 +2820,6 @@ describe("TroveManager in Normal Mode", () => {
     })
 
     it("a redemption made at non-zero base rate sends a non-zero CollateralFee to PCV contract", async () => {
-      await setBaseRate(contracts, to1e18("0.1"))
-
       await setupRedemptionTroves()
 
       await performRedemption(contracts, dennis, dennis, to1e18("100"))
@@ -2800,8 +2829,6 @@ describe("TroveManager in Normal Mode", () => {
     })
 
     it("a redemption made at zero base increases the collateral-fees in PCV contract", async () => {
-      await setBaseRate(contracts, to1e18("0"))
-
       await setupRedemptionTroves()
       await updatePCVSnapshot(contracts, state, "before")
 
@@ -2887,93 +2914,6 @@ describe("TroveManager in Normal Mode", () => {
       ).to.equal(collNeeded)
     })
 
-    it("updates the default pool's interest", async () => {
-      await openTrove(contracts, {
-        musdAmount: "5000",
-        ICR: "200",
-        sender: alice.wallet,
-      })
-      await openTrove(contracts, {
-        musdAmount: "5000",
-        ICR: "300",
-        sender: bob.wallet,
-      })
-      await openTrove(contracts, {
-        musdAmount: "5000",
-        ICR: "400",
-        sender: carol.wallet,
-      })
-
-      // Open another trove for Dennis with a very high ICR
-      await openTrove(contracts, {
-        musdAmount: "20000",
-        ICR: "4000",
-        sender: dennis.wallet,
-      })
-
-      await updateTroveSnapshot(contracts, alice, "before")
-
-      await dropPriceAndLiquidate(contracts, deployer, alice)
-
-      const interestRate = 1000
-      await setInterestRate(contracts, council, interestRate)
-      await updateContractsSnapshot(
-        contracts,
-        state,
-        "defaultPool",
-        "before",
-        addresses,
-      )
-
-      const startTime = BigInt(await getLatestBlockTimestamp())
-
-      await fastForwardTime(365 * 24 * 60 * 60) // 1 year in seconds
-
-      const redemptionAmount = to1e18("100")
-
-      await updateContractsSnapshot(
-        contracts,
-        state,
-        "defaultPool",
-        "before",
-        addresses,
-      )
-      await updateTroveSnapshot(contracts, bob, "before")
-      await updatePendingSnapshot(contracts, bob, "before")
-
-      await performRedemption(contracts, dennis, bob, redemptionAmount)
-
-      await updateTroveSnapshot(contracts, bob, "after")
-      await updatePendingSnapshot(contracts, bob, "after")
-
-      const endTime = BigInt(await getLatestBlockTimestamp())
-
-      await updateContractsSnapshot(
-        contracts,
-        state,
-        "defaultPool",
-        "after",
-        addresses,
-      )
-
-      expect(state.defaultPool.interest.after).to.be.closeTo(
-        state.defaultPool.interest.before +
-          calculateInterestOwed(
-            alice.trove.debt.before,
-            interestRate,
-            startTime,
-            endTime,
-          ) -
-          calculateInterestOwed(
-            bob.pending.principal.before,
-            interestRate,
-            startTime,
-            endTime,
-          ),
-        100n,
-      )
-    })
-
     context("Expected Reverts", () => {
       it("reverts when TCR < MCR", async () => {
         const users = [alice, bob, carol, dennis]
@@ -3011,60 +2951,6 @@ describe("TroveManager in Normal Mode", () => {
         ).to.be.revertedWith("TroveManager: Amount must be greater than zero")
       })
 
-      it("reverts if max fee > 100%", async () => {
-        await setupRedemptionTroves()
-
-        await expect(redeemWithFee(101)).to.be.revertedWith(
-          "Max fee percentage must be between 0.5% and 100%",
-        )
-      })
-
-      it("reverts if max fee < 0.5%", async () => {
-        await setupRedemptionTroves()
-
-        await expect(redeemWithFee(0.49)).to.be.revertedWith(
-          "Max fee percentage must be between 0.5% and 100%",
-        )
-      })
-
-      it("reverts if fee exceeds max fee percentage", async () => {
-        // Open identical troves for everyone but Dennis
-        const users = [alice, bob, carol, dennis]
-        await Promise.all(
-          users.slice(0, -1).map((user) =>
-            openTrove(contracts, {
-              musdAmount: "20000",
-              ICR: "200",
-              sender: user.wallet,
-            }),
-          ),
-        )
-
-        // Open a trove for Dennis with slightly lower ICR
-        await openTrove(contracts, {
-          musdAmount: "40000",
-          ICR: "195",
-          sender: dennis.wallet,
-        })
-
-        // Calculate the fee for redeeming 1/10 of the total supply
-        const totalSupply = await contracts.musd.totalSupply()
-        const attemptedRedemptionAmount = totalSupply / 10n
-        const price = await contracts.priceFeed.fetchPrice()
-        const collNeeded = to1e18(attemptedRedemptionAmount) / price
-        const fee =
-          await contracts.troveManager.getRedemptionFeeWithDecay(collNeeded)
-        const feePercentage = (to1e18(fee) / collNeeded) * 1000n
-
-        // Convert the fee to a number to make it easier to work with
-        const feePercentageNumber = Number(feePercentage) / Number(1e18)
-
-        // Attempt to redeem with a maximum fee just slightly less than the calculated fee
-        await expect(
-          redeemWithFee(feePercentageNumber - 0.01, attemptedRedemptionAmount),
-        ).to.be.revertedWith("Fee exceeded provided maximum")
-      })
-
       it("reverts when requested redemption amount exceeds caller's mUSD token balance", async () => {
         await setupRedemptionTroves()
         await updateWalletSnapshot(contracts, dennis, "before")
@@ -3087,21 +2973,6 @@ describe("TroveManager in Normal Mode", () => {
           performRedemption(contracts, bob, alice, redemptionAmount),
         ).to.be.revertedWith("TroveManager: Only one trove in the system")
       })
-
-      it("reverts if fee eats up all returned collateral", async () => {
-        await setupRedemptionTroves()
-        await updateTroveSnapshot(contracts, alice, "before")
-
-        // Set base rate to 100%
-        await setBaseRate(contracts, to1e18("1"))
-
-        // Attempt to fully redeem Alice's trove
-        await expect(
-          performRedemption(contracts, dennis, dennis, alice.trove.debt.before),
-        ).to.be.revertedWith(
-          "TroveManager: Fee would eat up all returned collateral",
-        )
-      })
     })
 
     context("Emitted Events", () => {
@@ -3172,8 +3043,8 @@ describe("TroveManager in Normal Mode", () => {
     })
   })
 
-  describe("getPendingMUSDDebtReward()", () => {
-    it("returns 0 if there is no pending mUSD reward", async () => {
+  describe("getPendingDebt()", () => {
+    it("returns 0 if there is no pending debt", async () => {
       await setupTroves()
       await openTrove(contracts, {
         musdAmount: "5000",
@@ -3188,7 +3059,7 @@ describe("TroveManager in Normal Mode", () => {
     })
   })
 
-  describe("getPendingCollateralReward()", () => {
+  describe("getPendingCollateral()", () => {
     it("returns 0 if there is no pending collateral reward", async () => {
       await setupTroves()
       await openTrove(contracts, {
@@ -3298,177 +3169,14 @@ describe("TroveManager in Normal Mode", () => {
     })
   })
 
-  describe("setMaxInterestRate()", () => {
-    it("sets the max interest rate", async () => {
-      await contracts.interestRateManager
-        .connect(council.wallet)
-        .setMaxInterestRate(5)
-      expect(await contracts.interestRateManager.maxInterestRate()).to.equal(5)
-    })
-
-    context("Expected Reverts", () => {
-      it("reverts if a non-whitelisted address tries to set the maximum interest rate", async () => {
-        await expect(
-          contracts.interestRateManager
-            .connect(alice.wallet)
-            .setMaxInterestRate(1),
-        ).to.be.revertedWith(
-          "InterestRateManager: Only governance can call this function",
-        )
-      })
-    })
-
-    context("Emitted Events", () => {
-      it("emits MaxInterestRateUpdated when the maximum interest rate is updated", async () => {
-        await expect(
-          contracts.interestRateManager
-            .connect(council.wallet)
-            .setMaxInterestRate(50),
-        )
-          .to.emit(contracts.interestRateManager, "MaxInterestRateUpdated")
-          .withArgs(50)
-      })
-    })
-  })
-
-  describe("proposeInterestRate()", () => {
-    context("Expected Reverts", () => {
-      it("reverts if the proposed rate exceeds the maximum interest rate", async () => {
-        await expect(
-          contracts.interestRateManager
-            .connect(council.wallet)
-            .proposeInterestRate(10001),
-        ).to.be.revertedWith("Interest rate exceeds the maximum interest rate")
-      })
-    })
-  })
-
-  describe("approveInterestRate()", () => {
-    it("requires two transactions to change the interest rate with a 7 day time delay", async () => {
-      await contracts.interestRateManager
-        .connect(council.wallet)
-        .proposeInterestRate(100)
-
-      // Simulate 7 days passing
-      const timeToIncrease = 7 * 24 * 60 * 60 // 7 days in seconds
-      await fastForwardTime(timeToIncrease)
-
-      await contracts.interestRateManager
-        .connect(council.wallet)
-        .approveInterestRate()
-      expect(await contracts.interestRateManager.interestRate()).to.equal(100)
-    })
-
-    context("Expected Reverts", () => {
-      it("reverts if the time delay has not finished", async () => {
-        await contracts.interestRateManager
-          .connect(council.wallet)
-          .proposeInterestRate(100)
-
-        // Simulate 6 days passing
-        const timeToIncrease = 6 * 24 * 60 * 60 // 6 days in seconds
-        await fastForwardTime(timeToIncrease)
-
-        await expect(
-          contracts.interestRateManager
-            .connect(council.wallet)
-            .approveInterestRate(),
-        ).to.be.revertedWith("Proposal delay not met")
-      })
-
-      it("reverts if called by a non-governance address", async () => {
-        await contracts.interestRateManager
-          .connect(council.wallet)
-          .proposeInterestRate(100)
-
-        // Simulate 6 days passing
-        const timeToIncrease = 6 * 24 * 60 * 60 // 6 days in seconds
-        await fastForwardTime(timeToIncrease)
-
-        await expect(
-          contracts.interestRateManager
-            .connect(alice.wallet)
-            .approveInterestRate(),
-        ).to.be.revertedWith(
-          "InterestRateManager: Only governance can call this function",
-        )
-      })
-
-      it("reverts if the proposed interest rate is greater than the maximum interest rate", async () => {
-        await contracts.interestRateManager
-          .connect(council.wallet)
-          .proposeInterestRate(9000)
-
-        // Change max interest rate after proposal
-        await contracts.interestRateManager
-          .connect(council.wallet)
-          .setMaxInterestRate(8000)
-
-        await fastForwardTime(7 * 24 * 60 * 60) // 7 days in seconds
-
-        await expect(
-          contracts.interestRateManager
-            .connect(council.wallet)
-            .approveInterestRate(),
-        ).to.be.revertedWith("Interest rate exceeds the maximum interest rate")
-      })
-    })
-
-    it("updates the default pool's accrued interest", async () => {
-      const interestRate = 100
-      await setInterestRate(contracts, council, interestRate)
-
-      await openTrove(contracts, {
-        musdAmount: "8000",
-        ICR: "500",
-        sender: alice.wallet,
-      })
-      await openTrove(contracts, {
-        musdAmount: "2000",
-        ICR: "200",
-        sender: bob.wallet,
-      })
-
-      await updateTroveSnapshots(contracts, [alice, bob], "before")
-
-      await dropPriceAndLiquidate(contracts, deployer, bob)
-
-      // Fast-forward 1 year
-      await fastForwardTime(365 * 24 * 60 * 60)
-
-      await setInterestRate(contracts, council, 200)
-
-      const endTime = BigInt(await getLatestBlockTimestamp())
-
-      await updateContractsSnapshot(
-        contracts,
-        state,
-        "defaultPool",
-        "after",
-        addresses,
-      )
-
-      expect(state.defaultPool.interest.after).to.be.closeTo(
-        calculateInterestOwed(
-          bob.trove.debt.before,
-          interestRate,
-          bob.trove.lastInterestUpdateTime.before,
-          endTime,
-        ),
-        1000,
-      )
-    })
-  })
-
   describe("calculateInterestOwed()", () => {
     it("should calculate the interest owed for a trove after 15 days", async () => {
-      const interest =
-        await contracts.interestRateManager.calculateInterestOwed(
-          to1e18("10,250"),
-          100n,
-          0n,
-          1296000n, // 15 days in seconds
-        )
+      const interest = await contracts.troveManager.calculateInterestOwed(
+        to1e18("10,250"),
+        100n,
+        0n,
+        1296000n, // 15 days in seconds
+      )
 
       const expectedInterest = calculateInterestOwed(
         to1e18("10,250"),
@@ -3481,13 +3189,12 @@ describe("TroveManager in Normal Mode", () => {
 
     it("should calculate the interest owed for a trove after 30 days", async () => {
       await setupTroveWithInterestRate(100, 30)
-      const interest =
-        await contracts.interestRateManager.calculateInterestOwed(
-          to1e18("10,250"),
-          100n,
-          0n,
-          2592000n, // 30 days in seconds
-        )
+      const interest = await contracts.troveManager.calculateInterestOwed(
+        to1e18("10,250"),
+        100n,
+        0n,
+        2592000n, // 30 days in seconds
+      )
 
       const expectedInterest = calculateInterestOwed(
         to1e18("10,250"),
@@ -3504,16 +3211,28 @@ describe("TroveManager in Normal Mode", () => {
     it("should mint additional calculated interest to the PCV", async () => {
       await setupTroveWithInterestRate(1000, 365)
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
       await updatePCVSnapshot(contracts, state, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
 
       await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "after")
       await updatePCVSnapshot(contracts, state, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
 
       expect(state.pcv.musd.after - state.pcv.musd.before).to.equal(
-        state.interestRateManager.interestRateData[1000].interest.after,
+        state.activePool.interest.after - state.activePool.interest.before,
       )
     })
 
@@ -3568,29 +3287,41 @@ describe("TroveManager in Normal Mode", () => {
         alice.trove.lastInterestUpdateTime.after,
       )
 
-      expect(alice.trove.interestOwed.after).to.be.equal(
+      expect(alice.trove.interestOwed.after).to.be.closeTo(
         alice.trove.interestOwed.before + expectedInterest,
+        2n,
       )
     })
 
     it("should update the system interest", async () => {
       await setupTroveWithInterestRate(100, 30)
-      await updateInterestRateDataSnapshot(contracts, state, 100, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateTroveSnapshot(contracts, alice, "before")
 
       await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 100, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[100].interest.after,
-      ).to.equal(
-        calculateInterestOwed(
-          to1e18(10250),
-          100,
-          state.interestRateManager.interestRateData[100].lastUpdatedTime
-            .before,
-          BigInt(await getLatestBlockTimestamp()),
-        ),
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before +
+          calculateInterestOwed(
+            to1e18(10250),
+            100,
+            alice.trove.lastInterestUpdateTime.before,
+            BigInt(await getLatestBlockTimestamp()),
+          ),
       )
     })
 
@@ -3598,24 +3329,34 @@ describe("TroveManager in Normal Mode", () => {
       await setupTroveWithInterestRate(100, 30)
       await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 100, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
+      await updateTroveSnapshot(contracts, alice, "before")
 
       await fastForwardTime(30 * 24 * 60 * 60)
       await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 100, "after")
+      await updateTroveSnapshot(contracts, alice, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[100].interest.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[100].interest.before +
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before +
           calculateInterestOwed(
             to1e18(10250),
             100,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .before,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .after,
+            alice.trove.lastInterestUpdateTime.before,
+            alice.trove.lastInterestUpdateTime.after,
           ),
       )
     })
@@ -3628,27 +3369,39 @@ describe("TroveManager in Normal Mode", () => {
         musdAmount: "20,000",
       })
 
-      await updateInterestRateDataSnapshot(contracts, state, 100, "before")
       await updateTroveSnapshots(contracts, [alice, bob], "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
 
       await fastForwardTime(30 * 24 * 60 * 60)
       await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
 
-      await updateInterestRateDataSnapshot(contracts, state, 100, "after")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
       await updateTroveSnapshots(contracts, [alice, bob], "after")
 
-      expect(
-        state.interestRateManager.interestRateData[100].interest.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[100].interest.before +
-          calculateInterestOwed(
-            alice.trove.debt.before + bob.trove.debt.before,
-            100,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .before,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .after,
-          ),
+      // We already accrued alice's interest when bob opened his trove, so we
+      // only care about the interest between bob's opening time and when alice was
+      // finally updated.
+      const interest = calculateInterestOwed(
+        alice.trove.debt.before + bob.trove.debt.before,
+        100,
+        bob.trove.lastInterestUpdateTime.before,
+        alice.trove.lastInterestUpdateTime.after,
+      )
+
+      expect(state.activePool.interest.after).to.equal(
+        state.activePool.interest.before + interest,
       )
     })
 
@@ -3661,48 +3414,46 @@ describe("TroveManager in Normal Mode", () => {
         musdAmount: "20,000",
       })
 
-      await updateInterestRateDataSnapshot(contracts, state, 200, "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await updateTroveSnapshots(contracts, [alice, bob], "before")
 
-      await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
-
-      await updateInterestRateDataSnapshot(contracts, state, 100, "before")
-
       await fastForwardTime(30 * 24 * 60 * 60)
-      await contracts.troveManager.updateSystemAndTroveInterest(alice.wallet)
-
-      await updateInterestRateDataSnapshot(contracts, state, 100, "after")
-
       await contracts.troveManager.updateSystemAndTroveInterest(bob.wallet)
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "after",
+        addresses,
+      )
+      await updateTroveSnapshot(contracts, bob, "after")
 
-      await updateInterestRateDataSnapshot(contracts, state, 200, "after")
+      // We already accrued alice's interest when bob opened his trove, so we
+      // only care about the interest between bob's opening time and when bob was
+      // finally updated.
+      const aliceInterest = calculateInterestOwed(
+        alice.trove.debt.before,
+        Number(alice.trove.interestRate.before),
+        bob.trove.lastInterestUpdateTime.before,
+        bob.trove.lastInterestUpdateTime.after,
+      )
 
-      expect(
-        state.interestRateManager.interestRateData[100].interest.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[100].interest.before +
-          calculateInterestOwed(
-            alice.trove.debt.before,
-            100,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .before,
-            state.interestRateManager.interestRateData[100].lastUpdatedTime
-              .after,
-          ),
+      const bobInterest = calculateInterestOwed(
+        bob.trove.debt.before,
+        Number(bob.trove.interestRate.after),
+        bob.trove.lastInterestUpdateTime.before,
+        bob.trove.lastInterestUpdateTime.after,
       )
 
-      expect(
-        state.interestRateManager.interestRateData[200].interest.after,
-      ).to.equal(
-        state.interestRateManager.interestRateData[200].interest.before +
-          calculateInterestOwed(
-            bob.trove.debt.before,
-            200,
-            state.interestRateManager.interestRateData[200].lastUpdatedTime
-              .before,
-            state.interestRateManager.interestRateData[200].lastUpdatedTime
-              .after,
-          ),
+      expect(state.activePool.interest.after).to.be.closeTo(
+        state.activePool.interest.before + aliceInterest + bobInterest,
+        2n,
       )
     })
   })
diff --git a/solidity/test/normal/TroveManager_LiquidationRewards.test.ts b/solidity/test/normal/TroveManager_LiquidationRewards.test.ts
index f9ce962..95a36e5 100644
--- a/solidity/test/normal/TroveManager_LiquidationRewards.test.ts
+++ b/solidity/test/normal/TroveManager_LiquidationRewards.test.ts
@@ -737,8 +737,9 @@ describe("TroveManager - Redistribution reward calculations", () => {
     )
   })
 
-  it("A, B Open. B Liquidated. A receives B's interest and interest from the default pool.", async () => {
-    await setInterestRate(contracts, council, 1000)
+  it("A, B Open. B Liquidated. A receives B's interest from before liquidation.", async () => {
+    const interestRate = 1000
+    await setInterestRate(contracts, council, interestRate)
     await setupTrove(alice, "8000", "500")
     await setupTrove(bob, "2000", "200")
 
@@ -748,26 +749,25 @@ describe("TroveManager - Redistribution reward calculations", () => {
     await fastForwardTime(365 * 24 * 60 * 60)
 
     await dropPriceAndLiquidate(contracts, deployer, bob)
+    const bobLiquidationTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshot(contracts, alice, "before")
 
     await fastForwardTime(365 * 24 * 60 * 60)
 
-    await contracts.troveManager.callUpdateDefaultPoolInterest()
-    const endTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshot(contracts, alice, "after")
 
     expect(alice.pending.interest.after).to.be.closeTo(
       calculateInterestOwed(
         bob.trove.debt.before,
-        1000,
+        interestRate,
         bob.trove.lastInterestUpdateTime.before,
-        endTime,
+        bobLiquidationTime,
       ),
-      1000n,
+      2n,
     )
   })
 
-  it("A, B Open. B Liquidated. A receives interest on B's principal from the default pool at the global rate.", async () => {
+  it("A, B Open. B Liquidated. No interest accrues on default pool debt.", async () => {
     await setupTrove(alice, "8000", "500")
     await setupTrove(bob, "2000", "200")
 
@@ -779,21 +779,15 @@ describe("TroveManager - Redistribution reward calculations", () => {
     await updatePendingSnapshot(contracts, alice, "before")
 
     await setInterestRate(contracts, council, 1000)
-    const startTime = BigInt(await getLatestBlockTimestamp())
 
     await fastForwardTime(365 * 24 * 60 * 60)
 
-    await contracts.troveManager.callUpdateDefaultPoolInterest()
-    const endTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshot(contracts, alice, "after")
 
-    expect(alice.pending.interest.after).to.be.closeTo(
-      calculateInterestOwed(bob.trove.debt.before, 1000, startTime, endTime),
-      1000n,
-    )
+    expect(alice.pending.interest.after).to.equal(0)
   })
 
-  it("A, B, C Open. B Liquidated. A and C receives B's interest and interest from the default pool.", async () => {
+  it("A, B, C Open. B Liquidated. A and C receives B's interest.", async () => {
     const interestRate = 1000
     await setInterestRate(contracts, council, interestRate)
     await setupTrove(alice, "8000", "500")
@@ -806,19 +800,19 @@ describe("TroveManager - Redistribution reward calculations", () => {
     await fastForwardTime(365 * 24 * 60 * 60)
 
     await dropPriceAndLiquidate(contracts, deployer, bob)
+
+    const bobLiquidationTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshot(contracts, alice, "before")
 
     await fastForwardTime(365 * 24 * 60 * 60)
 
-    await contracts.troveManager.callUpdateDefaultPoolInterest()
-    const endTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshots(contracts, [alice, carol], "after")
 
     const accruedInterest = calculateInterestOwed(
       bob.trove.debt.before,
       interestRate,
       bob.trove.lastInterestUpdateTime.before,
-      endTime,
+      bobLiquidationTime,
     )
 
     const totalCollateral =
@@ -826,44 +820,16 @@ describe("TroveManager - Redistribution reward calculations", () => {
 
     expect(alice.pending.interest.after).to.be.closeTo(
       (accruedInterest * alice.trove.collateral.before) / totalCollateral,
-      1000n,
+      2n,
     )
 
     expect(carol.pending.interest.after).to.be.closeTo(
       (accruedInterest * carol.trove.collateral.before) / totalCollateral,
-      1000n,
-    )
-  })
-
-  it("A, B, C Open. B, C Liquidated. Pending interest updates from C's liquidation.", async () => {
-    await setupTrove(carol, "2000", "200")
-    const interestRate = 1000
-    await setInterestRate(contracts, council, interestRate)
-    await setupTrove(alice, "8000", "500")
-    await setupTrove(bob, "2000", "200")
-
-    await updateTroveSnapshots(contracts, [alice, bob, carol], "before")
-
-    await dropPriceAndLiquidate(contracts, deployer, bob)
-
-    await fastForwardTime(365 * 24 * 60 * 60)
-
-    await dropPriceAndLiquidate(contracts, deployer, carol)
-
-    const endTime = BigInt(await getLatestBlockTimestamp())
-    await updatePendingSnapshot(contracts, alice, "after")
-
-    const accruedInterest = calculateInterestOwed(
-      bob.trove.debt.before,
-      interestRate,
-      bob.trove.lastInterestUpdateTime.before,
-      endTime,
+      2n,
     )
-
-    expect(alice.pending.interest.after).to.be.closeTo(accruedInterest, 1000n)
   })
 
-  it("A, B, C Open. B, C Liquidated. Pending interest updates from C's liquidation.", async () => {
+  it("A, B, C Open. B, C Liquidated. A recieves B's interest from before liquidation.", async () => {
     await setupTrove(carol, "2000", "300")
     const interestRate = 1000
     await setInterestRate(contracts, council, interestRate)
@@ -874,20 +840,21 @@ describe("TroveManager - Redistribution reward calculations", () => {
 
     await dropPriceAndLiquidate(contracts, deployer, bob)
 
+    const bobLiquidationTime = BigInt(await getLatestBlockTimestamp())
+
     await fastForwardTime(365 * 24 * 60 * 60)
 
     await dropPriceAndLiquidate(contracts, deployer, carol)
 
-    const endTime = BigInt(await getLatestBlockTimestamp())
     await updatePendingSnapshot(contracts, alice, "after")
 
     const accruedInterest = calculateInterestOwed(
       bob.trove.debt.before,
       interestRate,
       bob.trove.lastInterestUpdateTime.before,
-      endTime,
+      bobLiquidationTime,
     )
 
-    expect(alice.pending.interest.after).to.be.closeTo(accruedInterest, 1000n)
+    expect(alice.pending.interest.after).to.be.closeTo(accruedInterest, 2n)
   })
 })
diff --git a/solidity/test/recovery/BorrowerOperations.test.ts b/solidity/test/recovery/BorrowerOperations.test.ts
index 6d93a7e..e4e133a 100644
--- a/solidity/test/recovery/BorrowerOperations.test.ts
+++ b/solidity/test/recovery/BorrowerOperations.test.ts
@@ -89,17 +89,6 @@ describe("BorrowerOperations in Recovery Mode", () => {
       expect(ICR).is.equal(to1e18(150) / 100n)
     })
 
-    it("Allows max fee < 0.5% in Recovery Mode", async () => {
-      await openTrove(contracts, {
-        musdAmount: "4,000",
-        ICR: "200",
-        sender: carol.wallet,
-        maxFeePercentage: "0.4999999999999999",
-      })
-      const after = await contracts.musd.balanceOf(carol.wallet)
-      expect(after).to.equal(to1e18("4,000"))
-    })
-
     it("Records up-to-date initial snapshots of L_Collateral and L_MUSDDebt", async () => {
       // Liquidate Alice's Trove.
       await contracts.troveManager
@@ -349,13 +338,12 @@ describe("BorrowerOperations in Recovery Mode", () => {
   describe("withdrawMUSD", () => {
     context("Expected Reverts", () => {
       it("reverts when system is in Recovery Mode", async () => {
-        const maxFeePercentage = to1e18(1)
         const amount = 1n
 
         await expect(
           contracts.borrowerOperations
             .connect(bob.wallet)
-            .withdrawMUSD(maxFeePercentage, amount, bob.wallet, bob.wallet),
+            .withdrawMUSD(amount, bob.wallet, bob.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Operation must leave trove with ICR >= CCR",
         )
@@ -432,27 +420,29 @@ describe("BorrowerOperations in Recovery Mode", () => {
     })
   })
 
-  describe("adjustTrove", () => {
+  describe("refinance()", () => {
+    context("Expected Reverts", () => {
+      it("reverts when system is in Recovery Mode", async () => {
+        await expect(
+          contracts.borrowerOperations.connect(bob.wallet).refinance(),
+        ).to.be.revertedWith(
+          "BorrowerOps: Operation not permitted during Recovery Mode",
+        )
+      })
+    })
+  })
+
+  describe("adjustTrove()", () => {
     it("A trove with ICR < CCR in Recovery Mode can adjust their trove to ICR > CCR", async () => {
-      const maxFeePercentage = to1e18(1)
       const collChange = to1e18("20")
 
       await updateTroveSnapshot(contracts, alice, "before")
       // collateral deposit that would increase ICR > CCR
       await contracts.borrowerOperations
         .connect(alice.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          0,
-          false,
-          collChange,
-          alice.wallet,
-          alice.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, 0, false, alice.wallet, alice.wallet, {
+          value: collChange,
+        })
       await updateTroveSnapshot(contracts, alice, "after")
       const ccr = await contracts.troveManager.CCR()
       expect(alice.trove.icr.before).to.be.lessThan(ccr)
@@ -460,7 +450,6 @@ describe("BorrowerOperations in Recovery Mode", () => {
     })
 
     it("A trove with ICR > CCR in Recovery Mode can improve their ICR", async () => {
-      const maxFeePercentage = to1e18(1)
       const collChange = to1e18("20")
 
       await setupCarolsTrove()
@@ -468,48 +457,16 @@ describe("BorrowerOperations in Recovery Mode", () => {
       // collateral deposit that would increase ICR > CCR
       await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          0,
-          false,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, 0, false, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
       await updateTroveSnapshot(contracts, carol, "after")
       const ccr = await contracts.troveManager.CCR()
       expect(carol.trove.icr.before).to.be.greaterThan(ccr)
       expect(carol.trove.icr.after).to.be.greaterThan(carol.trove.icr.before)
     })
 
-    it("allows max fee < 0.5% in Recovery mode", async () => {
-      const maxFeePercentage = 4999999999999999n
-      const collChange = to1e18("20")
-      const debtChange = to1e18("2,000")
-
-      await setupCarolsTrove()
-      await contracts.borrowerOperations
-        .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
-    })
-
     it("debt increase in Recovery Mode charges no fee", async () => {
-      const maxFeePercentage = to1e18(1)
       const collChange = to1e18("20")
       const debtChange = to1e18("2,000")
 
@@ -519,18 +476,9 @@ describe("BorrowerOperations in Recovery Mode", () => {
 
       const tx = await contracts.borrowerOperations
         .connect(carol.wallet)
-        .adjustTrove(
-          maxFeePercentage,
-          0,
-          debtChange,
-          true,
-          collChange,
-          carol.wallet,
-          carol.wallet,
-          {
-            value: collChange,
-          },
-        )
+        .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet, {
+          value: collChange,
+        })
 
       const emittedFee = await getEventArgByName(
         tx,
@@ -547,7 +495,6 @@ describe("BorrowerOperations in Recovery Mode", () => {
 
     context("Expected Reverts", () => {
       it("reverts in Recovery Mode when the adjustment would reduce the TCR", async () => {
-        const maxFeePercentage = to1e18(1)
         const debtChange = to1e18(5000)
         const collChange = to1e18(0.0001)
         await setupCarolsTrove()
@@ -556,15 +503,7 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              collChange,
-              0,
-              false,
-              0,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(collChange, 0, false, carol.wallet, carol.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Collateral withdrawal not permitted Recovery Mode",
         )
@@ -573,15 +512,7 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              0,
-              debtChange,
-              true,
-              0,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode",
         )
@@ -590,22 +521,13 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              0,
-              debtChange,
-              true,
-              collChange,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode",
         )
       })
 
       it("collateral withdrawal reverts in Recovery Mode", async () => {
-        const maxFeePercentage = to1e18(1)
         const collChange = to1e18(0.0001)
         await setupCarolsTrove()
 
@@ -613,22 +535,13 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              collChange,
-              0,
-              false,
-              0,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(collChange, 0, false, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Collateral withdrawal not permitted Recovery Mode",
         )
       })
 
       it("no mintlist, collateral withdrawal reverts in Recovery Mode", async () => {
-        const maxFeePercentage = to1e18(1)
         const collChange = to1e18(0.0001)
         await setupCarolsTrove()
         await removeMintlist(contracts, deployer.wallet)
@@ -637,22 +550,13 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              collChange,
-              0,
-              false,
-              0,
-              alice.wallet,
-              alice.wallet,
-            ),
+            .adjustTrove(collChange, 0, false, alice.wallet, alice.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Collateral withdrawal not permitted Recovery Mode",
         )
       })
 
       it("debt increase that would leave ICR < CCR (150%) reverts in Recovery Mode", async () => {
-        const maxFeePercentage = to1e18(1)
         const collChange = to1e18(1)
         const debtChange = to1e18("2,000")
 
@@ -662,25 +566,15 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(alice.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              0,
-              debtChange,
-              true,
-              collChange,
-              alice.wallet,
-              alice.wallet,
-              {
-                value: collChange,
-              },
-            ),
+            .adjustTrove(0, debtChange, true, alice.wallet, alice.wallet, {
+              value: collChange,
+            }),
         ).to.be.revertedWith(
           "BorrowerOps: Operation must leave trove with ICR >= CCR",
         )
       })
 
       it("debt increase that would reduce the ICR reverts in Recovery Mode", async () => {
-        const maxFeePercentage = to1e18(1)
         const debtChange = to1e18("2,000")
 
         await setupCarolsTrove()
@@ -690,15 +584,7 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(carol.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              0,
-              debtChange,
-              true,
-              0,
-              carol.wallet,
-              carol.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, carol.wallet, carol.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode",
         )
@@ -717,15 +603,7 @@ describe("BorrowerOperations in Recovery Mode", () => {
         await expect(
           contracts.borrowerOperations
             .connect(bob.wallet)
-            .adjustTrove(
-              maxFeePercentage,
-              0,
-              debtChange,
-              true,
-              0,
-              bob.wallet,
-              bob.wallet,
-            ),
+            .adjustTrove(0, debtChange, true, bob.wallet, bob.wallet),
         ).to.be.revertedWith(
           "BorrowerOps: Operation must leave trove with ICR >= CCR",
         )
diff --git a/solidity/test/recovery/TroveManager.test.ts b/solidity/test/recovery/TroveManager.test.ts
index 014fe9c..b003b5a 100644
--- a/solidity/test/recovery/TroveManager.test.ts
+++ b/solidity/test/recovery/TroveManager.test.ts
@@ -1,19 +1,24 @@
 import { expect } from "chai"
 import {
-  NO_GAS,
   Contracts,
   ContractsState,
+  TestingAddresses,
   User,
   applyLiquidationFee,
+  calculateInterestOwed,
   checkTroveActive,
   checkTroveClosedByLiquidation,
   dropPrice,
   dropPriceAndLiquidate,
+  fastForwardTime,
   getEmittedLiquidationValues,
+  getLatestBlockTimestamp,
   getTroveEntireColl,
   openTrove,
   provideToSP,
+  setInterestRate,
   setupTests,
+  updateContractsSnapshot,
   updatePendingSnapshot,
   updateStabilityPoolSnapshot,
   updateStabilityPoolUserSnapshots,
@@ -21,15 +26,11 @@ import {
   updateTroveSnapshot,
   updateTroveSnapshots,
   updateWalletSnapshot,
-  setInterestRate,
-  fastForwardTime,
-  updateInterestRateDataSnapshot,
-  calculateInterestOwed,
-  getLatestBlockTimestamp,
 } from "../helpers"
 import { to1e18 } from "../utils"
 
 describe("TroveManager in Recovery Mode", () => {
+  let addresses: TestingAddresses
   let alice: User
   let bob: User
   let carol: User
@@ -44,6 +45,7 @@ describe("TroveManager in Recovery Mode", () => {
 
   beforeEach(async () => {
     ;({
+      addresses,
       alice,
       bob,
       carol,
@@ -369,17 +371,6 @@ describe("TroveManager in Recovery Mode", () => {
       )
     })
 
-    it("with 110% < ICR < TCR, and StabilityPool mUSD > debt to liquidate: offsets the trove entirely with the pool", async () => {
-      const { spDeposit, totalDebt } = await setupTrovesForStabilityPoolTests()
-
-      await updateStabilityPoolSnapshot(contracts, state, "before")
-      await dropPrice(contracts, deployer, bob, to1e18("112"))
-      await contracts.troveManager.liquidate(bob.address)
-      await updateStabilityPoolSnapshot(contracts, state, "after")
-
-      expect(state.stabilityPool.musd.after).to.equal(spDeposit - totalDebt)
-    })
-
     it("with ICR% = 110 < TCR, and StabilityPool mUSD > debt to liquidate: offsets the trove entirely with the pool, there’s no collateral surplus", async () => {
       await setupTrovesForStabilityPoolTests()
 
@@ -391,170 +382,6 @@ describe("TroveManager in Recovery Mode", () => {
       ).to.equal(0n)
     })
 
-    it("with 110% < ICR < TCR, and StabilityPool mUSD > debt to liquidate: removes stake and updates totalStakes", async () => {
-      await setupTrovesForStabilityPoolTests()
-
-      await updateStabilityPoolSnapshot(contracts, state, "before")
-      await dropPrice(contracts, deployer, bob, to1e18("112"))
-      await contracts.troveManager.liquidate(bob.address)
-      await updateStabilityPoolSnapshot(contracts, state, "after")
-
-      await updateTroveSnapshot(contracts, bob, "after")
-      await updateTroveManagerSnapshot(contracts, state, "after")
-      expect(bob.trove.stake.after).to.equal(0n)
-      expect(state.troveManager.stakes.after).to.equal(
-        alice.trove.collateral.before + dennis.trove.collateral.before,
-      )
-    })
-
-    it("with 110% < ICR < TCR, and StabilityPool mUSD > debt to liquidate: updates system snapshots", async () => {
-      await setupTrovesForStabilityPoolTests()
-      await updateTroveManagerSnapshot(contracts, state, "before")
-      await dropPrice(contracts, deployer, bob, to1e18("112"))
-      await contracts.troveManager.liquidate(bob.address)
-      await updateTroveManagerSnapshot(contracts, state, "after")
-      expect(state.troveManager.stakesSnapshot.after).to.equal(
-        alice.trove.collateral.before + dennis.trove.collateral.before,
-      )
-      expect(state.troveManager.collateralSnapshot.after).to.equal(
-        alice.trove.collateral.before + dennis.trove.collateral.before,
-      )
-    })
-
-    it("with 110% < ICR < TCR, and StabilityPool mUSD > debt to liquidate: closes the Trove", async () => {
-      await setupTrovesForStabilityPoolTests()
-      await dropPrice(contracts, deployer, bob, to1e18("112"))
-      await contracts.troveManager.liquidate(bob.address)
-      expect(await checkTroveClosedByLiquidation(contracts, bob)).to.equal(true)
-    })
-
-    it("with 110% < ICR < TCR, and StabilityPool THUSD > debt to liquidate: can liquidate troves out of order", async () => {
-      await setupTroveAndSnapshot(alice, "5000", "200")
-      await setupTroveAndSnapshot(bob, "5000", "202")
-      await setupTroveAndSnapshot(carol, "5000", "204")
-      await setupTroveAndSnapshot(dennis, "5000", "206")
-      const totalDebtToBeLiquidated =
-        alice.trove.debt.before +
-        bob.trove.debt.before +
-        carol.trove.debt.before +
-        dennis.trove.debt.before
-      await openTrove(contracts, {
-        musdAmount: totalDebtToBeLiquidated + to1e18("5000"),
-        ICR: "210",
-        sender: eric.wallet,
-      })
-
-      await provideToSP(contracts, eric, totalDebtToBeLiquidated + to1e18("1"))
-
-      await dropPrice(contracts, deployer, alice, to1e18("111"))
-
-      // Troves should be ordered by ICR, low to high: A, B, C, D, E
-      await updateTroveSnapshot(contracts, carol, "after")
-
-      // Liquidate out of ICR order
-      await contracts.troveManager.liquidate(carol.address)
-      await contracts.troveManager.liquidate(dennis.address)
-      await contracts.troveManager.liquidate(bob.address)
-      await contracts.troveManager.liquidate(alice.address)
-
-      expect(await checkTroveClosedByLiquidation(contracts, carol)).to.equal(
-        true,
-      )
-      expect(await checkTroveClosedByLiquidation(contracts, dennis)).to.equal(
-        true,
-      )
-      expect(await checkTroveClosedByLiquidation(contracts, bob)).to.equal(true)
-      expect(await checkTroveClosedByLiquidation(contracts, alice)).to.equal(
-        true,
-      )
-    })
-
-    it("with 110% < ICR < TCR, can claim collateral, re-open, be redeemed and claim again", async () => {
-      await setupTrovesForStabilityPoolTests()
-
-      const price = await contracts.priceFeed.fetchPrice()
-      await dropPrice(contracts, deployer, bob, to1e18("111"))
-      expect(await checkRecoveryMode()).to.equal(true)
-
-      await contracts.troveManager.liquidate(bob.address)
-
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .claimCollateral(NO_GAS)
-
-      await contracts.mockAggregator.connect(deployer.wallet).setPrice(price)
-      const { netDebt } = await setupTrove(bob, "1800", "120")
-      await contracts.troveManager
-        .connect(dennis.wallet)
-        .redeemCollateral(
-          netDebt,
-          bob.address,
-          bob.address,
-          bob.address,
-          0,
-          0,
-          to1e18("1"),
-          NO_GAS,
-        )
-      await updateWalletSnapshot(contracts, bob, "before")
-      const surplus = await contracts.collSurplusPool.getCollateral(bob.address)
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .claimCollateral(NO_GAS)
-      await updateWalletSnapshot(contracts, bob, "after")
-      expect(bob.btc.after).to.equal(bob.btc.before + surplus)
-    })
-
-    it("with 110% < ICR < TCR, can claim collateral, after another claim from a redemption", async () => {
-      // Open two troves:
-      const { netDebt } = await setupTrove(bob, "2000", "222")
-      await setupTrove(alice, "5000", "266")
-
-      // A redeems some collateral, creating a surplus for B
-      await contracts.troveManager
-        .connect(alice.wallet)
-        .redeemCollateral(
-          netDebt,
-          bob.address,
-          bob.address,
-          bob.address,
-          0,
-          0,
-          to1e18("1"),
-          NO_GAS,
-        )
-
-      // B claims collateral
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .claimCollateral(NO_GAS)
-
-      // B reopens trove
-      const { totalDebt } = await setupTroveAndSnapshot(bob, "2000", "240")
-
-      // C opens a trove and deposits to SP
-      await setupTrove(carol, "5000", "266")
-      const spDeposit = totalDebt
-      await provideToSP(contracts, carol, spDeposit)
-
-      // Price drops, reducing TCR below 150%
-      await dropPrice(contracts, deployer, alice, to1e18("149"))
-
-      // B is liquidated
-      await contracts.troveManager.liquidate(bob.address)
-
-      // B claims collateral
-      await updateWalletSnapshot(contracts, bob, "before")
-      const surplus = await contracts.collSurplusPool.getCollateral(bob.address)
-      await contracts.borrowerOperations
-        .connect(bob.wallet)
-        .claimCollateral(NO_GAS)
-
-      // Check balance and coll surplus are equal
-      await updateWalletSnapshot(contracts, bob, "after")
-      expect(bob.btc.after).to.equal(bob.btc.before + surplus)
-    })
-
     context("Expected Reverts", () => {
       it("reverts with ICR > 110%, and StabilityPool mUSD < liquidated debt", async () => {
         await setupTrovesStabilityPoolLessThanDebt()
@@ -613,31 +440,36 @@ describe("TroveManager in Recovery Mode", () => {
           contracts.troveManager.liquidate(alice.address),
         ).to.be.revertedWith("TroveManager: Trove does not exist or is closed")
       })
+
+      it("reverts if trove has ICR > MCR", async () => {
+        await setupTroveAndSnapshot(alice, "5000", "200")
+        await setupTroveAndSnapshot(bob, "5000", "200")
+        await dropPrice(contracts, deployer, alice, to1e18("120"))
+        await expect(
+          contracts.troveManager.liquidate(alice.address),
+        ).to.be.revertedWith("TroveManager: nothing to liquidate")
+      })
     })
   })
 
   describe("batchLiquidateTroves()", () => {
     it("liquidating a single trove does not return to normal mode if TCR < MCR", async () => {
       await setupBatchLiquidation()
+      await dropPrice(contracts, deployer, alice, to1e18("109"))
       await contracts.troveManager.batchLiquidateTroves([alice.address])
       expect(await checkRecoveryMode()).to.equal(true)
     })
 
-    it("troves with ICR > MCR can be liquidated", async () => {
-      await setupBatchLiquidation()
-      await contracts.troveManager.batchLiquidateTroves([
-        alice.address,
-        bob.address,
-        carol.address,
-      ])
+    it("liquidating a single trove returns to normal mode if new TCR > CCR", async () => {
+      await setupTroveAndSnapshot(alice, "100,000", "200")
+      await setupTroveAndSnapshot(bob, "30,000", "160")
+      await setupTroveAndSnapshot(carol, "70,000", "120")
+      await provideToSP(contracts, alice, to1e18("100,000"))
+      await dropPrice(contracts, deployer, carol, to1e18("108"))
+      expect(await checkRecoveryMode()).to.equal(true)
 
-      expect(await checkTroveClosedByLiquidation(contracts, alice)).to.equal(
-        true,
-      )
-      expect(await checkTroveClosedByLiquidation(contracts, bob)).to.equal(true)
-      expect(await checkTroveClosedByLiquidation(contracts, carol)).to.equal(
-        true,
-      )
+      await contracts.troveManager.batchLiquidateTroves([carol.address])
+      expect(await checkRecoveryMode()).to.equal(false)
     })
 
     it("a batch liquidation containing Pool offsets increases the TCR", async () => {
@@ -694,8 +526,14 @@ describe("TroveManager in Recovery Mode", () => {
       await setupTrove(bob, "5000", "155")
       await setupTrove(carol, "1800", "150")
 
-      await updateInterestRateDataSnapshot(contracts, state, 1000, "before")
-      await updateTroveSnapshot(contracts, carol, "before")
+      await updateTroveSnapshots(contracts, [alice, bob, carol], "before")
+      await updateContractsSnapshot(
+        contracts,
+        state,
+        "activePool",
+        "before",
+        addresses,
+      )
       await updateTroveManagerSnapshot(contracts, state, "before")
       const entireSystemCollBefore =
         await contracts.troveManager.getEntireSystemColl()
@@ -704,26 +542,26 @@ describe("TroveManager in Recovery Mode", () => {
       const liquidationTx = await contracts.troveManager.batchLiquidateTroves([
         carol.wallet,
       ])
-      await updateTroveSnapshot(contracts, carol, "after")
+      await updateTroveSnapshots(contracts, [alice, bob, carol], "after")
       const { collGasCompensation } =
         await getEmittedLiquidationValues(liquidationTx)
 
       // Calculate interest on total system debt
       const after = await getLatestBlockTimestamp()
+
       const interestOwed =
         calculateInterestOwed(
-          state.interestRateManager.interestRateData[1000].principal.before,
+          state.activePool.principal.before,
           1000,
           carol.trove.lastInterestUpdateTime.before,
           BigInt(after),
-        ) + state.interestRateManager.interestRateData[1000].interest.before
+        ) + state.activePool.interest.before
 
       // Calculate expected tcr
       const remainingColl =
         (entireSystemCollBefore - collGasCompensation) * newPrice
-      const remainingDebt =
-        state.interestRateManager.interestRateData[1000].principal.before +
-        interestOwed
+
+      const remainingDebt = state.activePool.principal.before + interestOwed
 
       await updateTroveManagerSnapshot(contracts, state, "after")
 
@@ -732,53 +570,6 @@ describe("TroveManager in Recovery Mode", () => {
       )
     })
 
-    it("with all ICRs > 110%, liquidates Troves until system leaves recovery mode", async () => {
-      // Open 5 troves
-      await setupTroveAndSnapshot(bob, "5000", "240")
-      await setupTroveAndSnapshot(carol, "5000", "240")
-      await setupTroveAndSnapshot(dennis, "5000", "232")
-      await setupTroveAndSnapshot(eric, "5000", "230")
-      await setupTroveAndSnapshot(frank, "5000", "228")
-
-      // Open a trove for Alice that contains the debt of 3 other troves plus min debt
-      const amount =
-        dennis.trove.debt.before +
-        eric.trove.debt.before +
-        frank.trove.debt.before
-
-      await openTrove(contracts, {
-        musdAmount: amount + to1e18("1800"),
-        sender: alice.wallet,
-        ICR: "400",
-      })
-
-      // Alice provides the total debt to the SP
-      await provideToSP(contracts, alice, amount)
-
-      // Drop the price to put the system into recovery mode (TCR < 150%)
-      // Since frank has the lowest ICR, everyone else should have ICR > 111%
-      await dropPrice(contracts, deployer, frank, to1e18("111"))
-      expect(await checkRecoveryMode()).to.equal(true)
-
-      // Liquidate Troves until the system leaves recovery mode
-      await contracts.troveManager.batchLiquidateTroves(
-        [frank, eric, dennis, carol, bob].map((user) => user.wallet),
-      )
-
-      // Check that we are no longer in recovery mode
-      expect(await checkRecoveryMode()).to.equal(false)
-
-      // Only frank should be liquidated, everyone else is still active
-      expect(await checkTroveActive(contracts, alice)).to.equal(true)
-      expect(await checkTroveActive(contracts, bob)).to.equal(true)
-      expect(await checkTroveActive(contracts, carol)).to.equal(true)
-      expect(await checkTroveActive(contracts, dennis)).to.equal(true)
-      expect(await checkTroveActive(contracts, eric)).to.equal(true)
-      expect(await checkTroveClosedByLiquidation(contracts, frank)).to.equal(
-        true,
-      )
-    })
-
     it("Liquidates Troves until 1) system has left recovery mode AND 2) it reaches a Trove with ICR >= 110%", async () => {
       // Open 5 troves
       await setupTroveAndSnapshot(bob, "5000", "240")
@@ -938,58 +729,6 @@ describe("TroveManager in Recovery Mode", () => {
       expect(await checkTroveClosedByLiquidation(contracts, bob)).to.equal(true)
     })
 
-    it("with a non fulfilled liquidation: still can liquidate further troves after the non-liquidated, emptied pool", async () => {
-      await setupTroveAndSnapshot(alice, "5000", "150")
-      await setupTroveAndSnapshot(bob, "5000", "150")
-      await setupTroveAndSnapshot(carol, "20,000", "180")
-      await setupTroveAndSnapshot(dennis, "2000", "160")
-
-      // Carol deposits enough to cover Alice and Dennis' debt
-      const spDeposit = alice.trove.debt.before + dennis.trove.debt.before
-      await provideToSP(contracts, carol, spDeposit)
-
-      await dropPrice(contracts, deployer, alice, to1e18("115"))
-
-      // Troves in ICR order: Alice, Bob, Dennis, Carol
-      await contracts.troveManager.batchLiquidateTroves(
-        [alice, bob, carol, dennis].map((user) => user.wallet),
-      )
-
-      expect(await checkTroveClosedByLiquidation(contracts, alice)).to.equal(
-        true,
-      )
-      // SP can cover Dennis' debt, so he gets liquidated even though he has a higher ICR than Bob
-      expect(await checkTroveClosedByLiquidation(contracts, dennis)).to.equal(
-        true,
-      )
-      expect(await checkTroveActive(contracts, bob)).to.equal(true)
-      expect(await checkTroveActive(contracts, carol)).to.equal(true)
-    })
-
-    it("with a non fulfilled liquidation: non liquidated trove remains active", async () => {
-      await setupTroveAndSnapshot(alice, "5000", "150")
-      await setupTroveAndSnapshot(bob, "5000", "150")
-      await setupTroveAndSnapshot(carol, "20,000", "160")
-
-      // Carol deposits enough to cover Alice's debt and half of Bob's
-      const spDeposit = alice.trove.debt.before + bob.trove.debt.before / 2n
-      await provideToSP(contracts, carol, spDeposit)
-
-      await dropPrice(contracts, deployer, alice, to1e18("115"))
-
-      await contracts.troveManager.batchLiquidateTroves([
-        alice.wallet,
-        bob.wallet,
-      ])
-
-      expect(await checkTroveClosedByLiquidation(contracts, alice)).to.equal(
-        true,
-      )
-      // Bob should remain active because his trove was only partially liquidated
-      expect(await checkTroveActive(contracts, bob)).to.equal(true)
-      expect(await checkTroveActive(contracts, carol)).to.equal(true)
-    })
-
     it("does not affect the liquidated user's token balances", async () => {
       await setupTrove(alice, "5000", "150")
       await setupTrove(bob, "5000", "150")
@@ -1074,48 +813,6 @@ describe("TroveManager in Recovery Mode", () => {
       )
     })
 
-    it("Liquidating troves at ICR <=100% with SP deposits does not alter their deposit or collateral gain", async () => {
-      // Open three troves: Alice, Bob, Carol
-      await setupTroveAndSnapshot(alice, "2000", "200")
-      await setupTroveAndSnapshot(bob, "2000", "200")
-      await setupTroveAndSnapshot(carol, "20,000", "200")
-
-      // All deposit into the stability pool
-      const aliceDeposit = to1e18("500")
-      const bobDeposit = to1e18("1000")
-      const carolDeposit = to1e18("3000")
-      await provideToSP(contracts, alice, aliceDeposit)
-      await provideToSP(contracts, bob, bobDeposit)
-      await provideToSP(contracts, carol, carolDeposit)
-
-      await updateStabilityPoolUserSnapshots(
-        contracts,
-        [alice, bob, carol],
-        "before",
-      )
-
-      await dropPrice(contracts, deployer, alice, to1e18("100"))
-      await contracts.troveManager.batchLiquidateTroves(
-        [alice, bob, carol].map((user) => user.wallet),
-      )
-
-      // Check that each user's deposit has not changed
-      await updateStabilityPoolUserSnapshots(
-        contracts,
-        [alice, bob, carol],
-        "after",
-      )
-
-      expect(aliceDeposit).to.equal(alice.stabilityPool.compoundedDeposit.after)
-      expect(bobDeposit).to.equal(bob.stabilityPool.compoundedDeposit.after)
-      expect(carolDeposit).to.equal(carol.stabilityPool.compoundedDeposit.after)
-
-      // Check that each user's collateral gain has not changed
-      expect(0n).to.equal(alice.stabilityPool.collateralGain.after)
-      expect(0n).to.equal(bob.stabilityPool.collateralGain.after)
-      expect(0n).to.equal(carol.stabilityPool.collateralGain.after)
-    })
-
     context("Expected Reverts", () => {
       it("does not liquidate troves with ICR > TCR", async () => {
         await setupBatchLiquidation()
diff --git a/solidity/test/upgrade/upgrade-proxy.ts b/solidity/test/upgrade/upgrade-proxy.ts
new file mode 100644
index 0000000..0d72082
--- /dev/null
+++ b/solidity/test/upgrade/upgrade-proxy.ts
@@ -0,0 +1,72 @@
+import { expect } from "chai"
+import { helpers } from "hardhat"
+
+import {
+  Contracts,
+  User,
+  openTrove,
+  setupTests,
+  updateTroveSnapshot,
+} from "../helpers"
+import { to1e18 } from "../utils"
+
+describe("Proxy Upgrades", () => {
+  let contracts: Contracts
+  let carol: User
+  let whale: User
+
+  beforeEach(async () => {
+    ;({ contracts, carol, whale } = await setupTests())
+  })
+
+  const updatePriceFeed = async () =>
+    helpers.upgrades.upgradeProxy("PriceFeed", "PriceFeedUpgradeTester")
+
+  it("do not change the underlying address", async () => {
+    const oldPrice = await contracts.priceFeed.fetchPrice()
+    const oldAddress = await contracts.priceFeed.getAddress()
+    expect(oldPrice).to.equal(to1e18("50,000"))
+
+    await updatePriceFeed()
+
+    const newPrice = await contracts.priceFeed.fetchPrice()
+    const newAddress = await contracts.priceFeed.getAddress()
+    expect(newPrice).to.equal(to1e18("45,000"))
+    expect(newAddress).to.equal(oldAddress)
+  })
+
+  it("automatically interoperate with connected contracts", async () => {
+    await openTrove(contracts, {
+      musdAmount: "300,000",
+      ICR: "200",
+      sender: whale.wallet,
+    })
+
+    await openTrove(contracts, {
+      musdAmount: "2,000",
+      ICR: "120",
+      sender: carol.wallet,
+    })
+
+    // Updating the price feed in place reduces the BTC price from $50k to $45k,
+    // lowering carol's ICR to a liquidatable number.
+    await updatePriceFeed()
+
+    await contracts.troveManager.connect(whale.wallet).liquidate(carol.wallet)
+
+    await updateTroveSnapshot(contracts, carol, "after")
+
+    expect(carol.trove.debt.after).to.equal(0n)
+  })
+
+  it("preserves prior state", async () => {
+    const oldOracle = await contracts.priceFeed.oracle()
+
+    await updatePriceFeed()
+
+    const newOracle = await contracts.priceFeed.oracle()
+
+    expect(newOracle).to.equal(oldOracle)
+    expect(newOracle).to.equal(await contracts.mockAggregator.getAddress())
+  })
+})
